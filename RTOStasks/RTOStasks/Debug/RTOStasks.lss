
RTOStasks.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800100  00000c0a  00000c9e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000c0a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000043f  0080010c  0080010c  00000caa  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000caa  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000cdc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001f0  00000000  00000000  00000d1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002616  00000000  00000000  00000f0c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000dfe  00000000  00000000  00003522  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001442  00000000  00000000  00004320  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000548  00000000  00000000  00005764  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000dce  00000000  00000000  00005cac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001cbf  00000000  00000000  00006a7a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000001e8  00000000  00000000  00008739  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 ad 02 	jmp	0x55a	; 0x55a <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ea e0       	ldi	r30, 0x0A	; 10
  7c:	fc e0       	ldi	r31, 0x0C	; 12
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	ac 30       	cpi	r26, 0x0C	; 12
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	25 e0       	ldi	r18, 0x05	; 5
  8c:	ac e0       	ldi	r26, 0x0C	; 12
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ab 34       	cpi	r26, 0x4B	; 75
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 2f 01 	call	0x25e	; 0x25e <main>
  9e:	0c 94 03 06 	jmp	0xc06	; 0xc06 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  a6:	cf 93       	push	r28
  a8:	df 93       	push	r29
  aa:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
  ac:	0e 94 49 04 	call	0x892	; 0x892 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
  b0:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <__data_end>
  b4:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <__data_end+0x1>
  b8:	89 2b       	or	r24, r25
  ba:	31 f4       	brne	.+12     	; 0xc8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
  bc:	81 e1       	ldi	r24, 0x11	; 17
  be:	91 e0       	ldi	r25, 0x01	; 1
  c0:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <__data_end+0x1>
  c4:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
  c8:	20 91 0e 01 	lds	r18, 0x010E	; 0x80010e <xNextFreeByte>
  cc:	30 91 0f 01 	lds	r19, 0x010F	; 0x80010f <xNextFreeByte+0x1>
  d0:	ce 01       	movw	r24, r28
  d2:	82 0f       	add	r24, r18
  d4:	93 1f       	adc	r25, r19
  d6:	87 3e       	cpi	r24, 0xE7	; 231
  d8:	43 e0       	ldi	r20, 0x03	; 3
  da:	94 07       	cpc	r25, r20
  dc:	70 f4       	brcc	.+28     	; 0xfa <pvPortMalloc+0x54>
  de:	28 17       	cp	r18, r24
  e0:	39 07       	cpc	r19, r25
  e2:	70 f4       	brcc	.+28     	; 0x100 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
  e4:	c0 91 0c 01 	lds	r28, 0x010C	; 0x80010c <__data_end>
  e8:	d0 91 0d 01 	lds	r29, 0x010D	; 0x80010d <__data_end+0x1>
  ec:	c2 0f       	add	r28, r18
  ee:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
  f0:	90 93 0f 01 	sts	0x010F, r25	; 0x80010f <xNextFreeByte+0x1>
  f4:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <xNextFreeByte>
  f8:	05 c0       	rjmp	.+10     	; 0x104 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
  fa:	c0 e0       	ldi	r28, 0x00	; 0
  fc:	d0 e0       	ldi	r29, 0x00	; 0
  fe:	02 c0       	rjmp	.+4      	; 0x104 <pvPortMalloc+0x5e>
 100:	c0 e0       	ldi	r28, 0x00	; 0
 102:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 104:	0e 94 0a 05 	call	0xa14	; 0xa14 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 108:	ce 01       	movw	r24, r28
 10a:	df 91       	pop	r29
 10c:	cf 91       	pop	r28
 10e:	08 95       	ret

00000110 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 110:	08 95       	ret

00000112 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 112:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 114:	03 96       	adiw	r24, 0x03	; 3
 116:	92 83       	std	Z+2, r25	; 0x02
 118:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 11a:	2f ef       	ldi	r18, 0xFF	; 255
 11c:	3f ef       	ldi	r19, 0xFF	; 255
 11e:	34 83       	std	Z+4, r19	; 0x04
 120:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 122:	96 83       	std	Z+6, r25	; 0x06
 124:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 126:	90 87       	std	Z+8, r25	; 0x08
 128:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 12a:	10 82       	st	Z, r1
 12c:	08 95       	ret

0000012e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 12e:	fc 01       	movw	r30, r24
 130:	11 86       	std	Z+9, r1	; 0x09
 132:	10 86       	std	Z+8, r1	; 0x08
 134:	08 95       	ret

00000136 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 136:	cf 93       	push	r28
 138:	df 93       	push	r29
 13a:	9c 01       	movw	r18, r24
 13c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 13e:	dc 01       	movw	r26, r24
 140:	11 96       	adiw	r26, 0x01	; 1
 142:	cd 91       	ld	r28, X+
 144:	dc 91       	ld	r29, X
 146:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 148:	d3 83       	std	Z+3, r29	; 0x03
 14a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 14c:	8c 81       	ldd	r24, Y+4	; 0x04
 14e:	9d 81       	ldd	r25, Y+5	; 0x05
 150:	95 83       	std	Z+5, r25	; 0x05
 152:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 154:	8c 81       	ldd	r24, Y+4	; 0x04
 156:	9d 81       	ldd	r25, Y+5	; 0x05
 158:	dc 01       	movw	r26, r24
 15a:	13 96       	adiw	r26, 0x03	; 3
 15c:	7c 93       	st	X, r23
 15e:	6e 93       	st	-X, r22
 160:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 162:	7d 83       	std	Y+5, r23	; 0x05
 164:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 166:	31 87       	std	Z+9, r19	; 0x09
 168:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 16a:	f9 01       	movw	r30, r18
 16c:	80 81       	ld	r24, Z
 16e:	8f 5f       	subi	r24, 0xFF	; 255
 170:	80 83       	st	Z, r24
}
 172:	df 91       	pop	r29
 174:	cf 91       	pop	r28
 176:	08 95       	ret

00000178 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 178:	cf 93       	push	r28
 17a:	df 93       	push	r29
 17c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 17e:	48 81       	ld	r20, Y
 180:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 182:	4f 3f       	cpi	r20, 0xFF	; 255
 184:	2f ef       	ldi	r18, 0xFF	; 255
 186:	52 07       	cpc	r21, r18
 188:	21 f4       	brne	.+8      	; 0x192 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 18a:	fc 01       	movw	r30, r24
 18c:	a7 81       	ldd	r26, Z+7	; 0x07
 18e:	b0 85       	ldd	r27, Z+8	; 0x08
 190:	0d c0       	rjmp	.+26     	; 0x1ac <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 192:	dc 01       	movw	r26, r24
 194:	13 96       	adiw	r26, 0x03	; 3
 196:	01 c0       	rjmp	.+2      	; 0x19a <vListInsert+0x22>
 198:	df 01       	movw	r26, r30
 19a:	12 96       	adiw	r26, 0x02	; 2
 19c:	ed 91       	ld	r30, X+
 19e:	fc 91       	ld	r31, X
 1a0:	13 97       	sbiw	r26, 0x03	; 3
 1a2:	20 81       	ld	r18, Z
 1a4:	31 81       	ldd	r19, Z+1	; 0x01
 1a6:	42 17       	cp	r20, r18
 1a8:	53 07       	cpc	r21, r19
 1aa:	b0 f7       	brcc	.-20     	; 0x198 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1ac:	12 96       	adiw	r26, 0x02	; 2
 1ae:	ed 91       	ld	r30, X+
 1b0:	fc 91       	ld	r31, X
 1b2:	13 97       	sbiw	r26, 0x03	; 3
 1b4:	fb 83       	std	Y+3, r31	; 0x03
 1b6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1b8:	d5 83       	std	Z+5, r29	; 0x05
 1ba:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 1bc:	bd 83       	std	Y+5, r27	; 0x05
 1be:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 1c0:	13 96       	adiw	r26, 0x03	; 3
 1c2:	dc 93       	st	X, r29
 1c4:	ce 93       	st	-X, r28
 1c6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1c8:	99 87       	std	Y+9, r25	; 0x09
 1ca:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1cc:	fc 01       	movw	r30, r24
 1ce:	20 81       	ld	r18, Z
 1d0:	2f 5f       	subi	r18, 0xFF	; 255
 1d2:	20 83       	st	Z, r18
}
 1d4:	df 91       	pop	r29
 1d6:	cf 91       	pop	r28
 1d8:	08 95       	ret

000001da <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 1da:	cf 93       	push	r28
 1dc:	df 93       	push	r29
 1de:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 1e0:	a0 85       	ldd	r26, Z+8	; 0x08
 1e2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1e4:	c2 81       	ldd	r28, Z+2	; 0x02
 1e6:	d3 81       	ldd	r29, Z+3	; 0x03
 1e8:	84 81       	ldd	r24, Z+4	; 0x04
 1ea:	95 81       	ldd	r25, Z+5	; 0x05
 1ec:	9d 83       	std	Y+5, r25	; 0x05
 1ee:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 1f0:	c4 81       	ldd	r28, Z+4	; 0x04
 1f2:	d5 81       	ldd	r29, Z+5	; 0x05
 1f4:	82 81       	ldd	r24, Z+2	; 0x02
 1f6:	93 81       	ldd	r25, Z+3	; 0x03
 1f8:	9b 83       	std	Y+3, r25	; 0x03
 1fa:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 1fc:	11 96       	adiw	r26, 0x01	; 1
 1fe:	cd 91       	ld	r28, X+
 200:	dc 91       	ld	r29, X
 202:	12 97       	sbiw	r26, 0x02	; 2
 204:	ce 17       	cp	r28, r30
 206:	df 07       	cpc	r29, r31
 208:	31 f4       	brne	.+12     	; 0x216 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 20a:	8c 81       	ldd	r24, Y+4	; 0x04
 20c:	9d 81       	ldd	r25, Y+5	; 0x05
 20e:	12 96       	adiw	r26, 0x02	; 2
 210:	9c 93       	st	X, r25
 212:	8e 93       	st	-X, r24
 214:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 216:	11 86       	std	Z+9, r1	; 0x09
 218:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 21a:	8c 91       	ld	r24, X
 21c:	81 50       	subi	r24, 0x01	; 1
 21e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 220:	df 91       	pop	r29
 222:	cf 91       	pop	r28
 224:	08 95       	ret

00000226 <vTestTask2>:

static void vTestTask2( void *pvParameters )
{
	( void ) pvParameters;
	uint8_t pinmask = 0x02;
	DDRD |= pinmask;
 226:	51 9a       	sbi	0x0a, 1	; 10
	for( ;; )
	{
		PORTD |= pinmask;
 228:	59 9a       	sbi	0x0b, 1	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 22a:	8f e9       	ldi	r24, 0x9F	; 159
 22c:	9f e0       	ldi	r25, 0x0F	; 15
 22e:	01 97       	sbiw	r24, 0x01	; 1
 230:	f1 f7       	brne	.-4      	; 0x22e <vTestTask2+0x8>
 232:	00 c0       	rjmp	.+0      	; 0x234 <vTestTask2+0xe>
 234:	00 00       	nop
		_delay_ms( 1 );   //simulate task work done
		PORTD &= ~pinmask;
 236:	59 98       	cbi	0x0b, 1	; 11
		vTaskDelay( 1 );
 238:	81 e0       	ldi	r24, 0x01	; 1
 23a:	90 e0       	ldi	r25, 0x00	; 0
 23c:	0e 94 89 05 	call	0xb12	; 0xb12 <vTaskDelay>
	}
 240:	f3 cf       	rjmp	.-26     	; 0x228 <vTestTask2+0x2>

00000242 <vTestTask1>:

static void vTestTask1( void *pvParameters )
{
	( void ) pvParameters;
	uint8_t pinmask = 0x01; 
	DDRD |= pinmask;
 242:	50 9a       	sbi	0x0a, 0	; 10
    for( ;; )
	{
		PORTD |= pinmask;
 244:	58 9a       	sbi	0x0b, 0	; 11
 246:	8f e9       	ldi	r24, 0x9F	; 159
 248:	9f e0       	ldi	r25, 0x0F	; 15
 24a:	01 97       	sbiw	r24, 0x01	; 1
 24c:	f1 f7       	brne	.-4      	; 0x24a <vTestTask1+0x8>
 24e:	00 c0       	rjmp	.+0      	; 0x250 <vTestTask1+0xe>
 250:	00 00       	nop
        _delay_ms( 1 );   //simulate task work done
        PORTD &= ~pinmask; 
 252:	58 98       	cbi	0x0b, 0	; 11
        vTaskDelay( 1 );
 254:	81 e0       	ldi	r24, 0x01	; 1
 256:	90 e0       	ldi	r25, 0x00	; 0
 258:	0e 94 89 05 	call	0xb12	; 0xb12 <vTaskDelay>
	}
 25c:	f3 cf       	rjmp	.-26     	; 0x244 <vTestTask1+0x2>

0000025e <main>:
static void vTestTask2( void *pvParameters );
/* FreeRTOS has several hooks available. If enabled in FreeRTOSConfig.h, the OS will call hooks 
   at each corresponding event  */

int main( void )
{
 25e:	ef 92       	push	r14
 260:	ff 92       	push	r15
 262:	0f 93       	push	r16
    // create tasks and start scheduler
	xTaskCreate( vTestTask1, ( const char * ) "T1", 255, (void *)('1'), mainTEST_TASK_PRIORITY, NULL );
 264:	e1 2c       	mov	r14, r1
 266:	f1 2c       	mov	r15, r1
 268:	01 e0       	ldi	r16, 0x01	; 1
 26a:	21 e3       	ldi	r18, 0x31	; 49
 26c:	30 e0       	ldi	r19, 0x00	; 0
 26e:	4f ef       	ldi	r20, 0xFF	; 255
 270:	50 e0       	ldi	r21, 0x00	; 0
 272:	60 e0       	ldi	r22, 0x00	; 0
 274:	71 e0       	ldi	r23, 0x01	; 1
 276:	81 e2       	ldi	r24, 0x21	; 33
 278:	91 e0       	ldi	r25, 0x01	; 1
 27a:	0e 94 1b 03 	call	0x636	; 0x636 <xTaskCreate>
	xTaskCreate( vTestTask2, ( const char * ) "T2", 255, (void *)('2'), mainTEST_TASK_PRIORITY, NULL );
 27e:	22 e3       	ldi	r18, 0x32	; 50
 280:	30 e0       	ldi	r19, 0x00	; 0
 282:	4f ef       	ldi	r20, 0xFF	; 255
 284:	50 e0       	ldi	r21, 0x00	; 0
 286:	63 e0       	ldi	r22, 0x03	; 3
 288:	71 e0       	ldi	r23, 0x01	; 1
 28a:	83 e1       	ldi	r24, 0x13	; 19
 28c:	91 e0       	ldi	r25, 0x01	; 1
 28e:	0e 94 1b 03 	call	0x636	; 0x636 <xTaskCreate>
	vTaskStartScheduler();
 292:	0e 94 1f 04 	call	0x83e	; 0x83e <vTaskStartScheduler>
	return 0;
}
 296:	80 e0       	ldi	r24, 0x00	; 0
 298:	90 e0       	ldi	r25, 0x00	; 0
 29a:	0f 91       	pop	r16
 29c:	ff 90       	pop	r15
 29e:	ef 90       	pop	r14
 2a0:	08 95       	ret

000002a2 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 2a2:	31 e1       	ldi	r19, 0x11	; 17
 2a4:	fc 01       	movw	r30, r24
 2a6:	30 83       	st	Z, r19
 2a8:	31 97       	sbiw	r30, 0x01	; 1
 2aa:	22 e2       	ldi	r18, 0x22	; 34
 2ac:	20 83       	st	Z, r18
 2ae:	31 97       	sbiw	r30, 0x01	; 1
 2b0:	a3 e3       	ldi	r26, 0x33	; 51
 2b2:	a0 83       	st	Z, r26
 2b4:	31 97       	sbiw	r30, 0x01	; 1
 2b6:	60 83       	st	Z, r22
 2b8:	31 97       	sbiw	r30, 0x01	; 1
 2ba:	70 83       	st	Z, r23
 2bc:	31 97       	sbiw	r30, 0x01	; 1
 2be:	10 82       	st	Z, r1
 2c0:	31 97       	sbiw	r30, 0x01	; 1
 2c2:	60 e8       	ldi	r22, 0x80	; 128
 2c4:	60 83       	st	Z, r22
 2c6:	31 97       	sbiw	r30, 0x01	; 1
 2c8:	10 82       	st	Z, r1
 2ca:	31 97       	sbiw	r30, 0x01	; 1
 2cc:	62 e0       	ldi	r22, 0x02	; 2
 2ce:	60 83       	st	Z, r22
 2d0:	31 97       	sbiw	r30, 0x01	; 1
 2d2:	63 e0       	ldi	r22, 0x03	; 3
 2d4:	60 83       	st	Z, r22
 2d6:	31 97       	sbiw	r30, 0x01	; 1
 2d8:	64 e0       	ldi	r22, 0x04	; 4
 2da:	60 83       	st	Z, r22
 2dc:	31 97       	sbiw	r30, 0x01	; 1
 2de:	65 e0       	ldi	r22, 0x05	; 5
 2e0:	60 83       	st	Z, r22
 2e2:	31 97       	sbiw	r30, 0x01	; 1
 2e4:	66 e0       	ldi	r22, 0x06	; 6
 2e6:	60 83       	st	Z, r22
 2e8:	31 97       	sbiw	r30, 0x01	; 1
 2ea:	67 e0       	ldi	r22, 0x07	; 7
 2ec:	60 83       	st	Z, r22
 2ee:	31 97       	sbiw	r30, 0x01	; 1
 2f0:	68 e0       	ldi	r22, 0x08	; 8
 2f2:	60 83       	st	Z, r22
 2f4:	31 97       	sbiw	r30, 0x01	; 1
 2f6:	69 e0       	ldi	r22, 0x09	; 9
 2f8:	60 83       	st	Z, r22
 2fa:	31 97       	sbiw	r30, 0x01	; 1
 2fc:	60 e1       	ldi	r22, 0x10	; 16
 2fe:	60 83       	st	Z, r22
 300:	31 97       	sbiw	r30, 0x01	; 1
 302:	30 83       	st	Z, r19
 304:	31 97       	sbiw	r30, 0x01	; 1
 306:	32 e1       	ldi	r19, 0x12	; 18
 308:	30 83       	st	Z, r19
 30a:	31 97       	sbiw	r30, 0x01	; 1
 30c:	33 e1       	ldi	r19, 0x13	; 19
 30e:	30 83       	st	Z, r19
 310:	31 97       	sbiw	r30, 0x01	; 1
 312:	34 e1       	ldi	r19, 0x14	; 20
 314:	30 83       	st	Z, r19
 316:	31 97       	sbiw	r30, 0x01	; 1
 318:	35 e1       	ldi	r19, 0x15	; 21
 31a:	30 83       	st	Z, r19
 31c:	31 97       	sbiw	r30, 0x01	; 1
 31e:	36 e1       	ldi	r19, 0x16	; 22
 320:	30 83       	st	Z, r19
 322:	31 97       	sbiw	r30, 0x01	; 1
 324:	37 e1       	ldi	r19, 0x17	; 23
 326:	30 83       	st	Z, r19
 328:	31 97       	sbiw	r30, 0x01	; 1
 32a:	38 e1       	ldi	r19, 0x18	; 24
 32c:	30 83       	st	Z, r19
 32e:	31 97       	sbiw	r30, 0x01	; 1
 330:	39 e1       	ldi	r19, 0x19	; 25
 332:	30 83       	st	Z, r19
 334:	31 97       	sbiw	r30, 0x01	; 1
 336:	30 e2       	ldi	r19, 0x20	; 32
 338:	30 83       	st	Z, r19
 33a:	31 97       	sbiw	r30, 0x01	; 1
 33c:	31 e2       	ldi	r19, 0x21	; 33
 33e:	30 83       	st	Z, r19
 340:	31 97       	sbiw	r30, 0x01	; 1
 342:	20 83       	st	Z, r18
 344:	31 97       	sbiw	r30, 0x01	; 1
 346:	23 e2       	ldi	r18, 0x23	; 35
 348:	20 83       	st	Z, r18
 34a:	31 97       	sbiw	r30, 0x01	; 1
 34c:	40 83       	st	Z, r20
 34e:	31 97       	sbiw	r30, 0x01	; 1
 350:	50 83       	st	Z, r21
 352:	31 97       	sbiw	r30, 0x01	; 1
 354:	26 e2       	ldi	r18, 0x26	; 38
 356:	20 83       	st	Z, r18
 358:	31 97       	sbiw	r30, 0x01	; 1
 35a:	27 e2       	ldi	r18, 0x27	; 39
 35c:	20 83       	st	Z, r18
 35e:	31 97       	sbiw	r30, 0x01	; 1
 360:	28 e2       	ldi	r18, 0x28	; 40
 362:	20 83       	st	Z, r18
 364:	31 97       	sbiw	r30, 0x01	; 1
 366:	29 e2       	ldi	r18, 0x29	; 41
 368:	20 83       	st	Z, r18
 36a:	31 97       	sbiw	r30, 0x01	; 1
 36c:	20 e3       	ldi	r18, 0x30	; 48
 36e:	20 83       	st	Z, r18
 370:	31 97       	sbiw	r30, 0x01	; 1
 372:	21 e3       	ldi	r18, 0x31	; 49
 374:	20 83       	st	Z, r18
 376:	86 97       	sbiw	r24, 0x26	; 38
 378:	08 95       	ret

0000037a <xPortStartScheduler>:
 37a:	8a e7       	ldi	r24, 0x7A	; 122
 37c:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 380:	81 e1       	ldi	r24, 0x11	; 17
 382:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 386:	8b e0       	ldi	r24, 0x0B	; 11
 388:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 38c:	ef e6       	ldi	r30, 0x6F	; 111
 38e:	f0 e0       	ldi	r31, 0x00	; 0
 390:	80 81       	ld	r24, Z
 392:	82 60       	ori	r24, 0x02	; 2
 394:	80 83       	st	Z, r24
 396:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 39a:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 39e:	cd 91       	ld	r28, X+
 3a0:	cd bf       	out	0x3d, r28	; 61
 3a2:	dd 91       	ld	r29, X+
 3a4:	de bf       	out	0x3e, r29	; 62
 3a6:	ff 91       	pop	r31
 3a8:	ef 91       	pop	r30
 3aa:	df 91       	pop	r29
 3ac:	cf 91       	pop	r28
 3ae:	bf 91       	pop	r27
 3b0:	af 91       	pop	r26
 3b2:	9f 91       	pop	r25
 3b4:	8f 91       	pop	r24
 3b6:	7f 91       	pop	r23
 3b8:	6f 91       	pop	r22
 3ba:	5f 91       	pop	r21
 3bc:	4f 91       	pop	r20
 3be:	3f 91       	pop	r19
 3c0:	2f 91       	pop	r18
 3c2:	1f 91       	pop	r17
 3c4:	0f 91       	pop	r16
 3c6:	ff 90       	pop	r15
 3c8:	ef 90       	pop	r14
 3ca:	df 90       	pop	r13
 3cc:	cf 90       	pop	r12
 3ce:	bf 90       	pop	r11
 3d0:	af 90       	pop	r10
 3d2:	9f 90       	pop	r9
 3d4:	8f 90       	pop	r8
 3d6:	7f 90       	pop	r7
 3d8:	6f 90       	pop	r6
 3da:	5f 90       	pop	r5
 3dc:	4f 90       	pop	r4
 3de:	3f 90       	pop	r3
 3e0:	2f 90       	pop	r2
 3e2:	1f 90       	pop	r1
 3e4:	0f 90       	pop	r0
 3e6:	0f be       	out	0x3f, r0	; 63
 3e8:	0f 90       	pop	r0
 3ea:	08 95       	ret
 3ec:	81 e0       	ldi	r24, 0x01	; 1
 3ee:	08 95       	ret

000003f0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 3f0:	0f 92       	push	r0
 3f2:	0f b6       	in	r0, 0x3f	; 63
 3f4:	f8 94       	cli
 3f6:	0f 92       	push	r0
 3f8:	1f 92       	push	r1
 3fa:	11 24       	eor	r1, r1
 3fc:	2f 92       	push	r2
 3fe:	3f 92       	push	r3
 400:	4f 92       	push	r4
 402:	5f 92       	push	r5
 404:	6f 92       	push	r6
 406:	7f 92       	push	r7
 408:	8f 92       	push	r8
 40a:	9f 92       	push	r9
 40c:	af 92       	push	r10
 40e:	bf 92       	push	r11
 410:	cf 92       	push	r12
 412:	df 92       	push	r13
 414:	ef 92       	push	r14
 416:	ff 92       	push	r15
 418:	0f 93       	push	r16
 41a:	1f 93       	push	r17
 41c:	2f 93       	push	r18
 41e:	3f 93       	push	r19
 420:	4f 93       	push	r20
 422:	5f 93       	push	r21
 424:	6f 93       	push	r22
 426:	7f 93       	push	r23
 428:	8f 93       	push	r24
 42a:	9f 93       	push	r25
 42c:	af 93       	push	r26
 42e:	bf 93       	push	r27
 430:	cf 93       	push	r28
 432:	df 93       	push	r29
 434:	ef 93       	push	r30
 436:	ff 93       	push	r31
 438:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 43c:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 440:	0d b6       	in	r0, 0x3d	; 61
 442:	0d 92       	st	X+, r0
 444:	0e b6       	in	r0, 0x3e	; 62
 446:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 448:	0e 94 9d 05 	call	0xb3a	; 0xb3a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 44c:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 450:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 454:	cd 91       	ld	r28, X+
 456:	cd bf       	out	0x3d, r28	; 61
 458:	dd 91       	ld	r29, X+
 45a:	de bf       	out	0x3e, r29	; 62
 45c:	ff 91       	pop	r31
 45e:	ef 91       	pop	r30
 460:	df 91       	pop	r29
 462:	cf 91       	pop	r28
 464:	bf 91       	pop	r27
 466:	af 91       	pop	r26
 468:	9f 91       	pop	r25
 46a:	8f 91       	pop	r24
 46c:	7f 91       	pop	r23
 46e:	6f 91       	pop	r22
 470:	5f 91       	pop	r21
 472:	4f 91       	pop	r20
 474:	3f 91       	pop	r19
 476:	2f 91       	pop	r18
 478:	1f 91       	pop	r17
 47a:	0f 91       	pop	r16
 47c:	ff 90       	pop	r15
 47e:	ef 90       	pop	r14
 480:	df 90       	pop	r13
 482:	cf 90       	pop	r12
 484:	bf 90       	pop	r11
 486:	af 90       	pop	r10
 488:	9f 90       	pop	r9
 48a:	8f 90       	pop	r8
 48c:	7f 90       	pop	r7
 48e:	6f 90       	pop	r6
 490:	5f 90       	pop	r5
 492:	4f 90       	pop	r4
 494:	3f 90       	pop	r3
 496:	2f 90       	pop	r2
 498:	1f 90       	pop	r1
 49a:	0f 90       	pop	r0
 49c:	0f be       	out	0x3f, r0	; 63
 49e:	0f 90       	pop	r0

	asm volatile ( "ret" );
 4a0:	08 95       	ret

000004a2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 4a2:	0f 92       	push	r0
 4a4:	0f b6       	in	r0, 0x3f	; 63
 4a6:	f8 94       	cli
 4a8:	0f 92       	push	r0
 4aa:	1f 92       	push	r1
 4ac:	11 24       	eor	r1, r1
 4ae:	2f 92       	push	r2
 4b0:	3f 92       	push	r3
 4b2:	4f 92       	push	r4
 4b4:	5f 92       	push	r5
 4b6:	6f 92       	push	r6
 4b8:	7f 92       	push	r7
 4ba:	8f 92       	push	r8
 4bc:	9f 92       	push	r9
 4be:	af 92       	push	r10
 4c0:	bf 92       	push	r11
 4c2:	cf 92       	push	r12
 4c4:	df 92       	push	r13
 4c6:	ef 92       	push	r14
 4c8:	ff 92       	push	r15
 4ca:	0f 93       	push	r16
 4cc:	1f 93       	push	r17
 4ce:	2f 93       	push	r18
 4d0:	3f 93       	push	r19
 4d2:	4f 93       	push	r20
 4d4:	5f 93       	push	r21
 4d6:	6f 93       	push	r22
 4d8:	7f 93       	push	r23
 4da:	8f 93       	push	r24
 4dc:	9f 93       	push	r25
 4de:	af 93       	push	r26
 4e0:	bf 93       	push	r27
 4e2:	cf 93       	push	r28
 4e4:	df 93       	push	r29
 4e6:	ef 93       	push	r30
 4e8:	ff 93       	push	r31
 4ea:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 4ee:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 4f2:	0d b6       	in	r0, 0x3d	; 61
 4f4:	0d 92       	st	X+, r0
 4f6:	0e b6       	in	r0, 0x3e	; 62
 4f8:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 4fa:	0e 94 4f 04 	call	0x89e	; 0x89e <xTaskIncrementTick>
 4fe:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 500:	0e 94 9d 05 	call	0xb3a	; 0xb3a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 504:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 508:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 50c:	cd 91       	ld	r28, X+
 50e:	cd bf       	out	0x3d, r28	; 61
 510:	dd 91       	ld	r29, X+
 512:	de bf       	out	0x3e, r29	; 62
 514:	ff 91       	pop	r31
 516:	ef 91       	pop	r30
 518:	df 91       	pop	r29
 51a:	cf 91       	pop	r28
 51c:	bf 91       	pop	r27
 51e:	af 91       	pop	r26
 520:	9f 91       	pop	r25
 522:	8f 91       	pop	r24
 524:	7f 91       	pop	r23
 526:	6f 91       	pop	r22
 528:	5f 91       	pop	r21
 52a:	4f 91       	pop	r20
 52c:	3f 91       	pop	r19
 52e:	2f 91       	pop	r18
 530:	1f 91       	pop	r17
 532:	0f 91       	pop	r16
 534:	ff 90       	pop	r15
 536:	ef 90       	pop	r14
 538:	df 90       	pop	r13
 53a:	cf 90       	pop	r12
 53c:	bf 90       	pop	r11
 53e:	af 90       	pop	r10
 540:	9f 90       	pop	r9
 542:	8f 90       	pop	r8
 544:	7f 90       	pop	r7
 546:	6f 90       	pop	r6
 548:	5f 90       	pop	r5
 54a:	4f 90       	pop	r4
 54c:	3f 90       	pop	r3
 54e:	2f 90       	pop	r2
 550:	1f 90       	pop	r1
 552:	0f 90       	pop	r0
 554:	0f be       	out	0x3f, r0	; 63
 556:	0f 90       	pop	r0

	asm volatile ( "ret" );
 558:	08 95       	ret

0000055a <__vector_11>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER1_COMPA_vect , ISR_NAKED )
	{
		vPortYieldFromTick();
 55a:	0e 94 51 02 	call	0x4a2	; 0x4a2 <vPortYieldFromTick>
		asm volatile ( "reti" );
 55e:	18 95       	reti

00000560 <prvResetNextTaskUnblockTime>:
	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
 560:	e0 91 11 05 	lds	r30, 0x0511	; 0x800511 <pxDelayedTaskList>
 564:	f0 91 12 05 	lds	r31, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 568:	80 81       	ld	r24, Z
 56a:	81 11       	cpse	r24, r1
 56c:	07 c0       	rjmp	.+14     	; 0x57c <prvResetNextTaskUnblockTime+0x1c>
 56e:	8f ef       	ldi	r24, 0xFF	; 255
 570:	9f ef       	ldi	r25, 0xFF	; 255
 572:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <xNextTaskUnblockTime+0x1>
 576:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <xNextTaskUnblockTime>
 57a:	08 95       	ret
 57c:	e0 91 11 05 	lds	r30, 0x0511	; 0x800511 <pxDelayedTaskList>
 580:	f0 91 12 05 	lds	r31, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 584:	05 80       	ldd	r0, Z+5	; 0x05
 586:	f6 81       	ldd	r31, Z+6	; 0x06
 588:	e0 2d       	mov	r30, r0
 58a:	06 80       	ldd	r0, Z+6	; 0x06
 58c:	f7 81       	ldd	r31, Z+7	; 0x07
 58e:	e0 2d       	mov	r30, r0
 590:	82 81       	ldd	r24, Z+2	; 0x02
 592:	93 81       	ldd	r25, Z+3	; 0x03
 594:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <xNextTaskUnblockTime+0x1>
 598:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <xNextTaskUnblockTime>
 59c:	08 95       	ret

0000059e <prvIdleTask>:
 59e:	c5 e2       	ldi	r28, 0x25	; 37
 5a0:	d5 e0       	ldi	r29, 0x05	; 5
 5a2:	88 81       	ld	r24, Y
 5a4:	82 30       	cpi	r24, 0x02	; 2
 5a6:	f0 f3       	brcs	.-4      	; 0x5a4 <prvIdleTask+0x6>
 5a8:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <vPortYield>
 5ac:	fa cf       	rjmp	.-12     	; 0x5a2 <prvIdleTask+0x4>

000005ae <prvAddCurrentTaskToDelayedList>:
 5ae:	0f 93       	push	r16
 5b0:	1f 93       	push	r17
 5b2:	cf 93       	push	r28
 5b4:	df 93       	push	r29
 5b6:	ec 01       	movw	r28, r24
 5b8:	00 91 03 05 	lds	r16, 0x0503	; 0x800503 <xTickCount>
 5bc:	10 91 04 05 	lds	r17, 0x0504	; 0x800504 <xTickCount+0x1>
 5c0:	80 91 49 05 	lds	r24, 0x0549	; 0x800549 <pxCurrentTCB>
 5c4:	90 91 4a 05 	lds	r25, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 5c8:	02 96       	adiw	r24, 0x02	; 2
 5ca:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
 5ce:	c0 0f       	add	r28, r16
 5d0:	d1 1f       	adc	r29, r17
 5d2:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 5d6:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 5da:	d3 83       	std	Z+3, r29	; 0x03
 5dc:	c2 83       	std	Z+2, r28	; 0x02
 5de:	c0 17       	cp	r28, r16
 5e0:	d1 07       	cpc	r29, r17
 5e2:	68 f4       	brcc	.+26     	; 0x5fe <prvAddCurrentTaskToDelayedList+0x50>
 5e4:	60 91 49 05 	lds	r22, 0x0549	; 0x800549 <pxCurrentTCB>
 5e8:	70 91 4a 05 	lds	r23, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 5ec:	80 91 0f 05 	lds	r24, 0x050F	; 0x80050f <pxOverflowDelayedTaskList>
 5f0:	90 91 10 05 	lds	r25, 0x0510	; 0x800510 <pxOverflowDelayedTaskList+0x1>
 5f4:	6e 5f       	subi	r22, 0xFE	; 254
 5f6:	7f 4f       	sbci	r23, 0xFF	; 255
 5f8:	0e 94 bc 00 	call	0x178	; 0x178 <vListInsert>
 5fc:	17 c0       	rjmp	.+46     	; 0x62c <prvAddCurrentTaskToDelayedList+0x7e>
 5fe:	60 91 49 05 	lds	r22, 0x0549	; 0x800549 <pxCurrentTCB>
 602:	70 91 4a 05 	lds	r23, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 606:	80 91 11 05 	lds	r24, 0x0511	; 0x800511 <pxDelayedTaskList>
 60a:	90 91 12 05 	lds	r25, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 60e:	6e 5f       	subi	r22, 0xFE	; 254
 610:	7f 4f       	sbci	r23, 0xFF	; 255
 612:	0e 94 bc 00 	call	0x178	; 0x178 <vListInsert>
 616:	80 91 fb 04 	lds	r24, 0x04FB	; 0x8004fb <xNextTaskUnblockTime>
 61a:	90 91 fc 04 	lds	r25, 0x04FC	; 0x8004fc <xNextTaskUnblockTime+0x1>
 61e:	c8 17       	cp	r28, r24
 620:	d9 07       	cpc	r29, r25
 622:	20 f4       	brcc	.+8      	; 0x62c <prvAddCurrentTaskToDelayedList+0x7e>
 624:	d0 93 fc 04 	sts	0x04FC, r29	; 0x8004fc <xNextTaskUnblockTime+0x1>
 628:	c0 93 fb 04 	sts	0x04FB, r28	; 0x8004fb <xNextTaskUnblockTime>
 62c:	df 91       	pop	r29
 62e:	cf 91       	pop	r28
 630:	1f 91       	pop	r17
 632:	0f 91       	pop	r16
 634:	08 95       	ret

00000636 <xTaskCreate>:
 636:	4f 92       	push	r4
 638:	5f 92       	push	r5
 63a:	6f 92       	push	r6
 63c:	7f 92       	push	r7
 63e:	8f 92       	push	r8
 640:	9f 92       	push	r9
 642:	af 92       	push	r10
 644:	bf 92       	push	r11
 646:	cf 92       	push	r12
 648:	df 92       	push	r13
 64a:	ef 92       	push	r14
 64c:	ff 92       	push	r15
 64e:	0f 93       	push	r16
 650:	cf 93       	push	r28
 652:	df 93       	push	r29
 654:	4c 01       	movw	r8, r24
 656:	6b 01       	movw	r12, r22
 658:	5a 01       	movw	r10, r20
 65a:	29 01       	movw	r4, r18
 65c:	ca 01       	movw	r24, r20
 65e:	0e 94 53 00 	call	0xa6	; 0xa6 <pvPortMalloc>
 662:	3c 01       	movw	r6, r24
 664:	89 2b       	or	r24, r25
 666:	09 f4       	brne	.+2      	; 0x66a <xTaskCreate+0x34>
 668:	d9 c0       	rjmp	.+434    	; 0x81c <xTaskCreate+0x1e6>
 66a:	86 e2       	ldi	r24, 0x26	; 38
 66c:	90 e0       	ldi	r25, 0x00	; 0
 66e:	0e 94 53 00 	call	0xa6	; 0xa6 <pvPortMalloc>
 672:	ec 01       	movw	r28, r24
 674:	89 2b       	or	r24, r25
 676:	71 f0       	breq	.+28     	; 0x694 <xTaskCreate+0x5e>
 678:	78 8e       	std	Y+24, r7	; 0x18
 67a:	6f 8a       	std	Y+23, r6	; 0x17
 67c:	81 e0       	ldi	r24, 0x01	; 1
 67e:	a8 1a       	sub	r10, r24
 680:	b1 08       	sbc	r11, r1
 682:	6a 0c       	add	r6, r10
 684:	7b 1c       	adc	r7, r11
 686:	d6 01       	movw	r26, r12
 688:	8c 91       	ld	r24, X
 68a:	89 8f       	std	Y+25, r24	; 0x19
 68c:	8c 91       	ld	r24, X
 68e:	81 11       	cpse	r24, r1
 690:	05 c0       	rjmp	.+10     	; 0x69c <xTaskCreate+0x66>
 692:	18 c0       	rjmp	.+48     	; 0x6c4 <xTaskCreate+0x8e>
 694:	c3 01       	movw	r24, r6
 696:	0e 94 88 00 	call	0x110	; 0x110 <vPortFree>
 69a:	c0 c0       	rjmp	.+384    	; 0x81c <xTaskCreate+0x1e6>
 69c:	ae 01       	movw	r20, r28
 69e:	46 5e       	subi	r20, 0xE6	; 230
 6a0:	5f 4f       	sbci	r21, 0xFF	; 255
 6a2:	f6 01       	movw	r30, r12
 6a4:	31 96       	adiw	r30, 0x01	; 1
 6a6:	b8 e0       	ldi	r27, 0x08	; 8
 6a8:	cb 0e       	add	r12, r27
 6aa:	d1 1c       	adc	r13, r1
 6ac:	cf 01       	movw	r24, r30
 6ae:	21 91       	ld	r18, Z+
 6b0:	da 01       	movw	r26, r20
 6b2:	2d 93       	st	X+, r18
 6b4:	ad 01       	movw	r20, r26
 6b6:	dc 01       	movw	r26, r24
 6b8:	8c 91       	ld	r24, X
 6ba:	88 23       	and	r24, r24
 6bc:	19 f0       	breq	.+6      	; 0x6c4 <xTaskCreate+0x8e>
 6be:	ec 15       	cp	r30, r12
 6c0:	fd 05       	cpc	r31, r13
 6c2:	a1 f7       	brne	.-24     	; 0x6ac <xTaskCreate+0x76>
 6c4:	18 a2       	std	Y+32, r1	; 0x20
 6c6:	04 30       	cpi	r16, 0x04	; 4
 6c8:	08 f0       	brcs	.+2      	; 0x6cc <xTaskCreate+0x96>
 6ca:	03 e0       	ldi	r16, 0x03	; 3
 6cc:	0e 8b       	std	Y+22, r16	; 0x16
 6ce:	6e 01       	movw	r12, r28
 6d0:	b2 e0       	ldi	r27, 0x02	; 2
 6d2:	cb 0e       	add	r12, r27
 6d4:	d1 1c       	adc	r13, r1
 6d6:	c6 01       	movw	r24, r12
 6d8:	0e 94 97 00 	call	0x12e	; 0x12e <vListInitialiseItem>
 6dc:	ce 01       	movw	r24, r28
 6de:	0c 96       	adiw	r24, 0x0c	; 12
 6e0:	0e 94 97 00 	call	0x12e	; 0x12e <vListInitialiseItem>
 6e4:	d9 87       	std	Y+9, r29	; 0x09
 6e6:	c8 87       	std	Y+8, r28	; 0x08
 6e8:	84 e0       	ldi	r24, 0x04	; 4
 6ea:	90 e0       	ldi	r25, 0x00	; 0
 6ec:	80 1b       	sub	r24, r16
 6ee:	91 09       	sbc	r25, r1
 6f0:	9d 87       	std	Y+13, r25	; 0x0d
 6f2:	8c 87       	std	Y+12, r24	; 0x0c
 6f4:	db 8b       	std	Y+19, r29	; 0x13
 6f6:	ca 8b       	std	Y+18, r28	; 0x12
 6f8:	19 a2       	std	Y+33, r1	; 0x21
 6fa:	1a a2       	std	Y+34, r1	; 0x22
 6fc:	1b a2       	std	Y+35, r1	; 0x23
 6fe:	1c a2       	std	Y+36, r1	; 0x24
 700:	1d a2       	std	Y+37, r1	; 0x25
 702:	a2 01       	movw	r20, r4
 704:	b4 01       	movw	r22, r8
 706:	c3 01       	movw	r24, r6
 708:	0e 94 51 01 	call	0x2a2	; 0x2a2 <pxPortInitialiseStack>
 70c:	99 83       	std	Y+1, r25	; 0x01
 70e:	88 83       	st	Y, r24
 710:	e1 14       	cp	r14, r1
 712:	f1 04       	cpc	r15, r1
 714:	19 f0       	breq	.+6      	; 0x71c <xTaskCreate+0xe6>
 716:	f7 01       	movw	r30, r14
 718:	d1 83       	std	Z+1, r29	; 0x01
 71a:	c0 83       	st	Z, r28
 71c:	0f b6       	in	r0, 0x3f	; 63
 71e:	f8 94       	cli
 720:	0f 92       	push	r0
 722:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <uxCurrentNumberOfTasks>
 726:	8f 5f       	subi	r24, 0xFF	; 255
 728:	80 93 05 05 	sts	0x0505, r24	; 0x800505 <uxCurrentNumberOfTasks>
 72c:	80 91 49 05 	lds	r24, 0x0549	; 0x800549 <pxCurrentTCB>
 730:	90 91 4a 05 	lds	r25, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 734:	89 2b       	or	r24, r25
 736:	89 f5       	brne	.+98     	; 0x79a <xTaskCreate+0x164>
 738:	d0 93 4a 05 	sts	0x054A, r29	; 0x80054a <pxCurrentTCB+0x1>
 73c:	c0 93 49 05 	sts	0x0549, r28	; 0x800549 <pxCurrentTCB>
 740:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <uxCurrentNumberOfTasks>
 744:	81 30       	cpi	r24, 0x01	; 1
 746:	c9 f5       	brne	.+114    	; 0x7ba <xTaskCreate+0x184>
 748:	85 e2       	ldi	r24, 0x25	; 37
 74a:	95 e0       	ldi	r25, 0x05	; 5
 74c:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 750:	8e e2       	ldi	r24, 0x2E	; 46
 752:	95 e0       	ldi	r25, 0x05	; 5
 754:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 758:	87 e3       	ldi	r24, 0x37	; 55
 75a:	95 e0       	ldi	r25, 0x05	; 5
 75c:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 760:	80 e4       	ldi	r24, 0x40	; 64
 762:	95 e0       	ldi	r25, 0x05	; 5
 764:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 768:	8c e1       	ldi	r24, 0x1C	; 28
 76a:	95 e0       	ldi	r25, 0x05	; 5
 76c:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 770:	83 e1       	ldi	r24, 0x13	; 19
 772:	95 e0       	ldi	r25, 0x05	; 5
 774:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 778:	86 e0       	ldi	r24, 0x06	; 6
 77a:	95 e0       	ldi	r25, 0x05	; 5
 77c:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 780:	8c e1       	ldi	r24, 0x1C	; 28
 782:	95 e0       	ldi	r25, 0x05	; 5
 784:	90 93 12 05 	sts	0x0512, r25	; 0x800512 <pxDelayedTaskList+0x1>
 788:	80 93 11 05 	sts	0x0511, r24	; 0x800511 <pxDelayedTaskList>
 78c:	83 e1       	ldi	r24, 0x13	; 19
 78e:	95 e0       	ldi	r25, 0x05	; 5
 790:	90 93 10 05 	sts	0x0510, r25	; 0x800510 <pxOverflowDelayedTaskList+0x1>
 794:	80 93 0f 05 	sts	0x050F, r24	; 0x80050f <pxOverflowDelayedTaskList>
 798:	10 c0       	rjmp	.+32     	; 0x7ba <xTaskCreate+0x184>
 79a:	80 91 01 05 	lds	r24, 0x0501	; 0x800501 <xSchedulerRunning>
 79e:	81 11       	cpse	r24, r1
 7a0:	0c c0       	rjmp	.+24     	; 0x7ba <xTaskCreate+0x184>
 7a2:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 7a6:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 7aa:	96 89       	ldd	r25, Z+22	; 0x16
 7ac:	8e 89       	ldd	r24, Y+22	; 0x16
 7ae:	89 17       	cp	r24, r25
 7b0:	20 f0       	brcs	.+8      	; 0x7ba <xTaskCreate+0x184>
 7b2:	d0 93 4a 05 	sts	0x054A, r29	; 0x80054a <pxCurrentTCB+0x1>
 7b6:	c0 93 49 05 	sts	0x0549, r28	; 0x800549 <pxCurrentTCB>
 7ba:	80 91 fd 04 	lds	r24, 0x04FD	; 0x8004fd <uxTaskNumber>
 7be:	8f 5f       	subi	r24, 0xFF	; 255
 7c0:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <uxTaskNumber>
 7c4:	8e 89       	ldd	r24, Y+22	; 0x16
 7c6:	90 91 02 05 	lds	r25, 0x0502	; 0x800502 <uxTopReadyPriority>
 7ca:	98 17       	cp	r25, r24
 7cc:	10 f4       	brcc	.+4      	; 0x7d2 <xTaskCreate+0x19c>
 7ce:	80 93 02 05 	sts	0x0502, r24	; 0x800502 <uxTopReadyPriority>
 7d2:	90 e0       	ldi	r25, 0x00	; 0
 7d4:	9c 01       	movw	r18, r24
 7d6:	22 0f       	add	r18, r18
 7d8:	33 1f       	adc	r19, r19
 7da:	22 0f       	add	r18, r18
 7dc:	33 1f       	adc	r19, r19
 7de:	22 0f       	add	r18, r18
 7e0:	33 1f       	adc	r19, r19
 7e2:	82 0f       	add	r24, r18
 7e4:	93 1f       	adc	r25, r19
 7e6:	b6 01       	movw	r22, r12
 7e8:	8b 5d       	subi	r24, 0xDB	; 219
 7ea:	9a 4f       	sbci	r25, 0xFA	; 250
 7ec:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
 7f0:	0f 90       	pop	r0
 7f2:	0f be       	out	0x3f, r0	; 63
 7f4:	80 91 01 05 	lds	r24, 0x0501	; 0x800501 <xSchedulerRunning>
 7f8:	88 23       	and	r24, r24
 7fa:	61 f0       	breq	.+24     	; 0x814 <xTaskCreate+0x1de>
 7fc:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 800:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 804:	96 89       	ldd	r25, Z+22	; 0x16
 806:	8e 89       	ldd	r24, Y+22	; 0x16
 808:	98 17       	cp	r25, r24
 80a:	30 f4       	brcc	.+12     	; 0x818 <xTaskCreate+0x1e2>
 80c:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <vPortYield>
 810:	81 e0       	ldi	r24, 0x01	; 1
 812:	05 c0       	rjmp	.+10     	; 0x81e <xTaskCreate+0x1e8>
 814:	81 e0       	ldi	r24, 0x01	; 1
 816:	03 c0       	rjmp	.+6      	; 0x81e <xTaskCreate+0x1e8>
 818:	81 e0       	ldi	r24, 0x01	; 1
 81a:	01 c0       	rjmp	.+2      	; 0x81e <xTaskCreate+0x1e8>
 81c:	8f ef       	ldi	r24, 0xFF	; 255
 81e:	df 91       	pop	r29
 820:	cf 91       	pop	r28
 822:	0f 91       	pop	r16
 824:	ff 90       	pop	r15
 826:	ef 90       	pop	r14
 828:	df 90       	pop	r13
 82a:	cf 90       	pop	r12
 82c:	bf 90       	pop	r11
 82e:	af 90       	pop	r10
 830:	9f 90       	pop	r9
 832:	8f 90       	pop	r8
 834:	7f 90       	pop	r7
 836:	6f 90       	pop	r6
 838:	5f 90       	pop	r5
 83a:	4f 90       	pop	r4
 83c:	08 95       	ret

0000083e <vTaskStartScheduler>:
 83e:	ef 92       	push	r14
 840:	ff 92       	push	r15
 842:	0f 93       	push	r16
 844:	0f 2e       	mov	r0, r31
 846:	f9 ef       	ldi	r31, 0xF9	; 249
 848:	ef 2e       	mov	r14, r31
 84a:	f4 e0       	ldi	r31, 0x04	; 4
 84c:	ff 2e       	mov	r15, r31
 84e:	f0 2d       	mov	r31, r0
 850:	00 e0       	ldi	r16, 0x00	; 0
 852:	20 e0       	ldi	r18, 0x00	; 0
 854:	30 e0       	ldi	r19, 0x00	; 0
 856:	40 e5       	ldi	r20, 0x50	; 80
 858:	50 e0       	ldi	r21, 0x00	; 0
 85a:	66 e0       	ldi	r22, 0x06	; 6
 85c:	71 e0       	ldi	r23, 0x01	; 1
 85e:	8f ec       	ldi	r24, 0xCF	; 207
 860:	92 e0       	ldi	r25, 0x02	; 2
 862:	0e 94 1b 03 	call	0x636	; 0x636 <xTaskCreate>
 866:	81 30       	cpi	r24, 0x01	; 1
 868:	81 f4       	brne	.+32     	; 0x88a <vTaskStartScheduler+0x4c>
 86a:	f8 94       	cli
 86c:	8f ef       	ldi	r24, 0xFF	; 255
 86e:	9f ef       	ldi	r25, 0xFF	; 255
 870:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <xNextTaskUnblockTime+0x1>
 874:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <xNextTaskUnblockTime>
 878:	81 e0       	ldi	r24, 0x01	; 1
 87a:	80 93 01 05 	sts	0x0501, r24	; 0x800501 <xSchedulerRunning>
 87e:	10 92 04 05 	sts	0x0504, r1	; 0x800504 <xTickCount+0x1>
 882:	10 92 03 05 	sts	0x0503, r1	; 0x800503 <xTickCount>
 886:	0e 94 bd 01 	call	0x37a	; 0x37a <xPortStartScheduler>
 88a:	0f 91       	pop	r16
 88c:	ff 90       	pop	r15
 88e:	ef 90       	pop	r14
 890:	08 95       	ret

00000892 <vTaskSuspendAll>:
 892:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 896:	8f 5f       	subi	r24, 0xFF	; 255
 898:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <uxSchedulerSuspended>
 89c:	08 95       	ret

0000089e <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 89e:	cf 92       	push	r12
 8a0:	df 92       	push	r13
 8a2:	ef 92       	push	r14
 8a4:	ff 92       	push	r15
 8a6:	0f 93       	push	r16
 8a8:	1f 93       	push	r17
 8aa:	cf 93       	push	r28
 8ac:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8ae:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 8b2:	81 11       	cpse	r24, r1
 8b4:	99 c0       	rjmp	.+306    	; 0x9e8 <__stack+0xe9>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
 8b6:	e0 90 03 05 	lds	r14, 0x0503	; 0x800503 <xTickCount>
 8ba:	f0 90 04 05 	lds	r15, 0x0504	; 0x800504 <xTickCount+0x1>
 8be:	8f ef       	ldi	r24, 0xFF	; 255
 8c0:	e8 1a       	sub	r14, r24
 8c2:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 8c4:	f0 92 04 05 	sts	0x0504, r15	; 0x800504 <xTickCount+0x1>
 8c8:	e0 92 03 05 	sts	0x0503, r14	; 0x800503 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
 8cc:	e1 14       	cp	r14, r1
 8ce:	f1 04       	cpc	r15, r1
 8d0:	b9 f4       	brne	.+46     	; 0x900 <__stack+0x1>
		{
			taskSWITCH_DELAYED_LISTS();
 8d2:	80 91 11 05 	lds	r24, 0x0511	; 0x800511 <pxDelayedTaskList>
 8d6:	90 91 12 05 	lds	r25, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 8da:	20 91 0f 05 	lds	r18, 0x050F	; 0x80050f <pxOverflowDelayedTaskList>
 8de:	30 91 10 05 	lds	r19, 0x0510	; 0x800510 <pxOverflowDelayedTaskList+0x1>
 8e2:	30 93 12 05 	sts	0x0512, r19	; 0x800512 <pxDelayedTaskList+0x1>
 8e6:	20 93 11 05 	sts	0x0511, r18	; 0x800511 <pxDelayedTaskList>
 8ea:	90 93 10 05 	sts	0x0510, r25	; 0x800510 <pxOverflowDelayedTaskList+0x1>
 8ee:	80 93 0f 05 	sts	0x050F, r24	; 0x80050f <pxOverflowDelayedTaskList>
 8f2:	80 91 fe 04 	lds	r24, 0x04FE	; 0x8004fe <xNumOfOverflows>
 8f6:	8f 5f       	subi	r24, 0xFF	; 255
 8f8:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <xNumOfOverflows>
 8fc:	0e 94 b0 02 	call	0x560	; 0x560 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 900:	80 91 fb 04 	lds	r24, 0x04FB	; 0x8004fb <xNextTaskUnblockTime>
 904:	90 91 fc 04 	lds	r25, 0x04FC	; 0x8004fc <xNextTaskUnblockTime+0x1>
 908:	e8 16       	cp	r14, r24
 90a:	f9 06       	cpc	r15, r25
 90c:	10 f4       	brcc	.+4      	; 0x912 <__stack+0x13>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 90e:	d1 2c       	mov	r13, r1
 910:	53 c0       	rjmp	.+166    	; 0x9b8 <__stack+0xb9>
 912:	d1 2c       	mov	r13, r1
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
 914:	cc 24       	eor	r12, r12
 916:	c3 94       	inc	r12
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 918:	e0 91 11 05 	lds	r30, 0x0511	; 0x800511 <pxDelayedTaskList>
 91c:	f0 91 12 05 	lds	r31, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 920:	90 81       	ld	r25, Z
 922:	91 11       	cpse	r25, r1
 924:	07 c0       	rjmp	.+14     	; 0x934 <__stack+0x35>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 926:	8f ef       	ldi	r24, 0xFF	; 255
 928:	9f ef       	ldi	r25, 0xFF	; 255
 92a:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <xNextTaskUnblockTime+0x1>
 92e:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <xNextTaskUnblockTime>
					break;
 932:	42 c0       	rjmp	.+132    	; 0x9b8 <__stack+0xb9>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 934:	e0 91 11 05 	lds	r30, 0x0511	; 0x800511 <pxDelayedTaskList>
 938:	f0 91 12 05 	lds	r31, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 93c:	05 80       	ldd	r0, Z+5	; 0x05
 93e:	f6 81       	ldd	r31, Z+6	; 0x06
 940:	e0 2d       	mov	r30, r0
 942:	c6 81       	ldd	r28, Z+6	; 0x06
 944:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 946:	2a 81       	ldd	r18, Y+2	; 0x02
 948:	3b 81       	ldd	r19, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
 94a:	e2 16       	cp	r14, r18
 94c:	f3 06       	cpc	r15, r19
 94e:	28 f4       	brcc	.+10     	; 0x95a <__stack+0x5b>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 950:	30 93 fc 04 	sts	0x04FC, r19	; 0x8004fc <xNextTaskUnblockTime+0x1>
 954:	20 93 fb 04 	sts	0x04FB, r18	; 0x8004fb <xNextTaskUnblockTime>
						break;
 958:	2f c0       	rjmp	.+94     	; 0x9b8 <__stack+0xb9>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 95a:	8e 01       	movw	r16, r28
 95c:	0e 5f       	subi	r16, 0xFE	; 254
 95e:	1f 4f       	sbci	r17, 0xFF	; 255
 960:	c8 01       	movw	r24, r16
 962:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 966:	8c 89       	ldd	r24, Y+20	; 0x14
 968:	9d 89       	ldd	r25, Y+21	; 0x15
 96a:	89 2b       	or	r24, r25
 96c:	21 f0       	breq	.+8      	; 0x976 <__stack+0x77>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 96e:	ce 01       	movw	r24, r28
 970:	0c 96       	adiw	r24, 0x0c	; 12
 972:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 976:	2e 89       	ldd	r18, Y+22	; 0x16
 978:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <uxTopReadyPriority>
 97c:	82 17       	cp	r24, r18
 97e:	10 f4       	brcc	.+4      	; 0x984 <__stack+0x85>
 980:	20 93 02 05 	sts	0x0502, r18	; 0x800502 <uxTopReadyPriority>
 984:	30 e0       	ldi	r19, 0x00	; 0
 986:	c9 01       	movw	r24, r18
 988:	88 0f       	add	r24, r24
 98a:	99 1f       	adc	r25, r25
 98c:	88 0f       	add	r24, r24
 98e:	99 1f       	adc	r25, r25
 990:	88 0f       	add	r24, r24
 992:	99 1f       	adc	r25, r25
 994:	82 0f       	add	r24, r18
 996:	93 1f       	adc	r25, r19
 998:	b8 01       	movw	r22, r16
 99a:	8b 5d       	subi	r24, 0xDB	; 219
 99c:	9a 4f       	sbci	r25, 0xFA	; 250
 99e:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 9a2:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 9a6:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 9aa:	9e 89       	ldd	r25, Y+22	; 0x16
 9ac:	86 89       	ldd	r24, Z+22	; 0x16
 9ae:	98 17       	cp	r25, r24
 9b0:	08 f4       	brcc	.+2      	; 0x9b4 <__stack+0xb5>
 9b2:	b2 cf       	rjmp	.-156    	; 0x918 <__stack+0x19>
						{
							xSwitchRequired = pdTRUE;
 9b4:	dc 2c       	mov	r13, r12
 9b6:	b0 cf       	rjmp	.-160    	; 0x918 <__stack+0x19>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 9b8:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 9bc:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 9c0:	86 89       	ldd	r24, Z+22	; 0x16
 9c2:	90 e0       	ldi	r25, 0x00	; 0
 9c4:	fc 01       	movw	r30, r24
 9c6:	ee 0f       	add	r30, r30
 9c8:	ff 1f       	adc	r31, r31
 9ca:	ee 0f       	add	r30, r30
 9cc:	ff 1f       	adc	r31, r31
 9ce:	ee 0f       	add	r30, r30
 9d0:	ff 1f       	adc	r31, r31
 9d2:	8e 0f       	add	r24, r30
 9d4:	9f 1f       	adc	r25, r31
 9d6:	fc 01       	movw	r30, r24
 9d8:	eb 5d       	subi	r30, 0xDB	; 219
 9da:	fa 4f       	sbci	r31, 0xFA	; 250
 9dc:	80 81       	ld	r24, Z
 9de:	82 30       	cpi	r24, 0x02	; 2
 9e0:	48 f0       	brcs	.+18     	; 0x9f4 <__stack+0xf5>
			{
				xSwitchRequired = pdTRUE;
 9e2:	dd 24       	eor	r13, r13
 9e4:	d3 94       	inc	r13
 9e6:	06 c0       	rjmp	.+12     	; 0x9f4 <__stack+0xf5>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 9e8:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <uxPendedTicks>
 9ec:	8f 5f       	subi	r24, 0xFF	; 255
 9ee:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 9f2:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 9f4:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <xYieldPending>
 9f8:	88 23       	and	r24, r24
 9fa:	11 f0       	breq	.+4      	; 0xa00 <__stack+0x101>
		{
			xSwitchRequired = pdTRUE;
 9fc:	dd 24       	eor	r13, r13
 9fe:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 a00:	8d 2d       	mov	r24, r13
 a02:	df 91       	pop	r29
 a04:	cf 91       	pop	r28
 a06:	1f 91       	pop	r17
 a08:	0f 91       	pop	r16
 a0a:	ff 90       	pop	r15
 a0c:	ef 90       	pop	r14
 a0e:	df 90       	pop	r13
 a10:	cf 90       	pop	r12
 a12:	08 95       	ret

00000a14 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 a14:	df 92       	push	r13
 a16:	ef 92       	push	r14
 a18:	ff 92       	push	r15
 a1a:	0f 93       	push	r16
 a1c:	1f 93       	push	r17
 a1e:	cf 93       	push	r28
 a20:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 a22:	0f b6       	in	r0, 0x3f	; 63
 a24:	f8 94       	cli
 a26:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 a28:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 a2c:	81 50       	subi	r24, 0x01	; 1
 a2e:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 a32:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 a36:	81 11       	cpse	r24, r1
 a38:	5f c0       	rjmp	.+190    	; 0xaf8 <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 a3a:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <uxCurrentNumberOfTasks>
 a3e:	81 11       	cpse	r24, r1
 a40:	33 c0       	rjmp	.+102    	; 0xaa8 <xTaskResumeAll+0x94>
 a42:	5d c0       	rjmp	.+186    	; 0xafe <xTaskResumeAll+0xea>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 a44:	d7 01       	movw	r26, r14
 a46:	15 96       	adiw	r26, 0x05	; 5
 a48:	ed 91       	ld	r30, X+
 a4a:	fc 91       	ld	r31, X
 a4c:	16 97       	sbiw	r26, 0x06	; 6
 a4e:	c6 81       	ldd	r28, Z+6	; 0x06
 a50:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 a52:	ce 01       	movw	r24, r28
 a54:	0c 96       	adiw	r24, 0x0c	; 12
 a56:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 a5a:	8e 01       	movw	r16, r28
 a5c:	0e 5f       	subi	r16, 0xFE	; 254
 a5e:	1f 4f       	sbci	r17, 0xFF	; 255
 a60:	c8 01       	movw	r24, r16
 a62:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 a66:	2e 89       	ldd	r18, Y+22	; 0x16
 a68:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <uxTopReadyPriority>
 a6c:	82 17       	cp	r24, r18
 a6e:	10 f4       	brcc	.+4      	; 0xa74 <xTaskResumeAll+0x60>
 a70:	20 93 02 05 	sts	0x0502, r18	; 0x800502 <uxTopReadyPriority>
 a74:	30 e0       	ldi	r19, 0x00	; 0
 a76:	c9 01       	movw	r24, r18
 a78:	88 0f       	add	r24, r24
 a7a:	99 1f       	adc	r25, r25
 a7c:	88 0f       	add	r24, r24
 a7e:	99 1f       	adc	r25, r25
 a80:	88 0f       	add	r24, r24
 a82:	99 1f       	adc	r25, r25
 a84:	82 0f       	add	r24, r18
 a86:	93 1f       	adc	r25, r19
 a88:	b8 01       	movw	r22, r16
 a8a:	8b 5d       	subi	r24, 0xDB	; 219
 a8c:	9a 4f       	sbci	r25, 0xFA	; 250
 a8e:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 a92:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 a96:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 a9a:	9e 89       	ldd	r25, Y+22	; 0x16
 a9c:	86 89       	ldd	r24, Z+22	; 0x16
 a9e:	98 17       	cp	r25, r24
 aa0:	68 f0       	brcs	.+26     	; 0xabc <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
 aa2:	d0 92 ff 04 	sts	0x04FF, r13	; 0x8004ff <xYieldPending>
 aa6:	0a c0       	rjmp	.+20     	; 0xabc <xTaskResumeAll+0xa8>
 aa8:	c0 e0       	ldi	r28, 0x00	; 0
 aaa:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 aac:	0f 2e       	mov	r0, r31
 aae:	f6 e0       	ldi	r31, 0x06	; 6
 ab0:	ef 2e       	mov	r14, r31
 ab2:	f5 e0       	ldi	r31, 0x05	; 5
 ab4:	ff 2e       	mov	r15, r31
 ab6:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 ab8:	dd 24       	eor	r13, r13
 aba:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 abc:	f7 01       	movw	r30, r14
 abe:	80 81       	ld	r24, Z
 ac0:	81 11       	cpse	r24, r1
 ac2:	c0 cf       	rjmp	.-128    	; 0xa44 <xTaskResumeAll+0x30>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 ac4:	cd 2b       	or	r28, r29
 ac6:	11 f0       	breq	.+4      	; 0xacc <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 ac8:	0e 94 b0 02 	call	0x560	; 0x560 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 acc:	c0 91 00 05 	lds	r28, 0x0500	; 0x800500 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
 ad0:	cc 23       	and	r28, r28
 ad2:	51 f0       	breq	.+20     	; 0xae8 <xTaskResumeAll+0xd4>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
 ad4:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 ad6:	0e 94 4f 04 	call	0x89e	; 0x89e <xTaskIncrementTick>
 ada:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
 adc:	d0 93 ff 04 	sts	0x04FF, r29	; 0x8004ff <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
 ae0:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 ae2:	c9 f7       	brne	.-14     	; 0xad6 <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
 ae4:	10 92 00 05 	sts	0x0500, r1	; 0x800500 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 ae8:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <xYieldPending>
 aec:	88 23       	and	r24, r24
 aee:	31 f0       	breq	.+12     	; 0xafc <xTaskResumeAll+0xe8>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 af0:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 af4:	81 e0       	ldi	r24, 0x01	; 1
 af6:	03 c0       	rjmp	.+6      	; 0xafe <xTaskResumeAll+0xea>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
 af8:	80 e0       	ldi	r24, 0x00	; 0
 afa:	01 c0       	rjmp	.+2      	; 0xafe <xTaskResumeAll+0xea>
 afc:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 afe:	0f 90       	pop	r0
 b00:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 b02:	df 91       	pop	r29
 b04:	cf 91       	pop	r28
 b06:	1f 91       	pop	r17
 b08:	0f 91       	pop	r16
 b0a:	ff 90       	pop	r15
 b0c:	ef 90       	pop	r14
 b0e:	df 90       	pop	r13
 b10:	08 95       	ret

00000b12 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 b12:	cf 93       	push	r28
 b14:	df 93       	push	r29
 b16:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 b18:	89 2b       	or	r24, r25
 b1a:	51 f0       	breq	.+20     	; 0xb30 <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 b1c:	0e 94 49 04 	call	0x892	; 0x892 <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 b20:	60 e0       	ldi	r22, 0x00	; 0
 b22:	ce 01       	movw	r24, r28
 b24:	0e 94 d7 02 	call	0x5ae	; 0x5ae <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 b28:	0e 94 0a 05 	call	0xa14	; 0xa14 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 b2c:	81 11       	cpse	r24, r1
 b2e:	02 c0       	rjmp	.+4      	; 0xb34 <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
 b30:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 b34:	df 91       	pop	r29
 b36:	cf 91       	pop	r28
 b38:	08 95       	ret

00000b3a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 b3a:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 b3e:	88 23       	and	r24, r24
 b40:	21 f0       	breq	.+8      	; 0xb4a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 b42:	81 e0       	ldi	r24, 0x01	; 1
 b44:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <xYieldPending>
 b48:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 b4a:	10 92 ff 04 	sts	0x04FF, r1	; 0x8004ff <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 b4e:	20 91 02 05 	lds	r18, 0x0502	; 0x800502 <uxTopReadyPriority>
 b52:	82 2f       	mov	r24, r18
 b54:	90 e0       	ldi	r25, 0x00	; 0
 b56:	fc 01       	movw	r30, r24
 b58:	ee 0f       	add	r30, r30
 b5a:	ff 1f       	adc	r31, r31
 b5c:	ee 0f       	add	r30, r30
 b5e:	ff 1f       	adc	r31, r31
 b60:	ee 0f       	add	r30, r30
 b62:	ff 1f       	adc	r31, r31
 b64:	e8 0f       	add	r30, r24
 b66:	f9 1f       	adc	r31, r25
 b68:	eb 5d       	subi	r30, 0xDB	; 219
 b6a:	fa 4f       	sbci	r31, 0xFA	; 250
 b6c:	30 81       	ld	r19, Z
 b6e:	31 11       	cpse	r19, r1
 b70:	11 c0       	rjmp	.+34     	; 0xb94 <vTaskSwitchContext+0x5a>
 b72:	21 50       	subi	r18, 0x01	; 1
 b74:	82 2f       	mov	r24, r18
 b76:	90 e0       	ldi	r25, 0x00	; 0
 b78:	fc 01       	movw	r30, r24
 b7a:	ee 0f       	add	r30, r30
 b7c:	ff 1f       	adc	r31, r31
 b7e:	ee 0f       	add	r30, r30
 b80:	ff 1f       	adc	r31, r31
 b82:	ee 0f       	add	r30, r30
 b84:	ff 1f       	adc	r31, r31
 b86:	e8 0f       	add	r30, r24
 b88:	f9 1f       	adc	r31, r25
 b8a:	eb 5d       	subi	r30, 0xDB	; 219
 b8c:	fa 4f       	sbci	r31, 0xFA	; 250
 b8e:	30 81       	ld	r19, Z
 b90:	33 23       	and	r19, r19
 b92:	79 f3       	breq	.-34     	; 0xb72 <vTaskSwitchContext+0x38>
 b94:	ac 01       	movw	r20, r24
 b96:	44 0f       	add	r20, r20
 b98:	55 1f       	adc	r21, r21
 b9a:	44 0f       	add	r20, r20
 b9c:	55 1f       	adc	r21, r21
 b9e:	44 0f       	add	r20, r20
 ba0:	55 1f       	adc	r21, r21
 ba2:	48 0f       	add	r20, r24
 ba4:	59 1f       	adc	r21, r25
 ba6:	da 01       	movw	r26, r20
 ba8:	ab 5d       	subi	r26, 0xDB	; 219
 baa:	ba 4f       	sbci	r27, 0xFA	; 250
 bac:	11 96       	adiw	r26, 0x01	; 1
 bae:	ed 91       	ld	r30, X+
 bb0:	fc 91       	ld	r31, X
 bb2:	12 97       	sbiw	r26, 0x02	; 2
 bb4:	02 80       	ldd	r0, Z+2	; 0x02
 bb6:	f3 81       	ldd	r31, Z+3	; 0x03
 bb8:	e0 2d       	mov	r30, r0
 bba:	12 96       	adiw	r26, 0x02	; 2
 bbc:	fc 93       	st	X, r31
 bbe:	ee 93       	st	-X, r30
 bc0:	11 97       	sbiw	r26, 0x01	; 1
 bc2:	48 5d       	subi	r20, 0xD8	; 216
 bc4:	5a 4f       	sbci	r21, 0xFA	; 250
 bc6:	e4 17       	cp	r30, r20
 bc8:	f5 07       	cpc	r31, r21
 bca:	29 f4       	brne	.+10     	; 0xbd6 <vTaskSwitchContext+0x9c>
 bcc:	42 81       	ldd	r20, Z+2	; 0x02
 bce:	53 81       	ldd	r21, Z+3	; 0x03
 bd0:	fd 01       	movw	r30, r26
 bd2:	52 83       	std	Z+2, r21	; 0x02
 bd4:	41 83       	std	Z+1, r20	; 0x01
 bd6:	fc 01       	movw	r30, r24
 bd8:	ee 0f       	add	r30, r30
 bda:	ff 1f       	adc	r31, r31
 bdc:	ee 0f       	add	r30, r30
 bde:	ff 1f       	adc	r31, r31
 be0:	ee 0f       	add	r30, r30
 be2:	ff 1f       	adc	r31, r31
 be4:	8e 0f       	add	r24, r30
 be6:	9f 1f       	adc	r25, r31
 be8:	fc 01       	movw	r30, r24
 bea:	eb 5d       	subi	r30, 0xDB	; 219
 bec:	fa 4f       	sbci	r31, 0xFA	; 250
 bee:	01 80       	ldd	r0, Z+1	; 0x01
 bf0:	f2 81       	ldd	r31, Z+2	; 0x02
 bf2:	e0 2d       	mov	r30, r0
 bf4:	86 81       	ldd	r24, Z+6	; 0x06
 bf6:	97 81       	ldd	r25, Z+7	; 0x07
 bf8:	90 93 4a 05 	sts	0x054A, r25	; 0x80054a <pxCurrentTCB+0x1>
 bfc:	80 93 49 05 	sts	0x0549, r24	; 0x800549 <pxCurrentTCB>
 c00:	20 93 02 05 	sts	0x0502, r18	; 0x800502 <uxTopReadyPriority>
 c04:	08 95       	ret

00000c06 <_exit>:
 c06:	f8 94       	cli

00000c08 <__stop_program>:
 c08:	ff cf       	rjmp	.-2      	; 0xc08 <__stop_program>
