
RTOStasks.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800100  00000cea  00000d7e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000cea  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000043f  0080010c  0080010c  00000d8a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000d8a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000dbc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000210  00000000  00000000  00000dfc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000028d9  00000000  00000000  0000100c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e8f  00000000  00000000  000038e5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001546  00000000  00000000  00004774  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000005b0  00000000  00000000  00005cbc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000e9c  00000000  00000000  0000626c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001f63  00000000  00000000  00007108  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000220  00000000  00000000  0000906b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 d4 02 	jmp	0x5a8	; 0x5a8 <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ea ee       	ldi	r30, 0xEA	; 234
  7c:	fc e0       	ldi	r31, 0x0C	; 12
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	ac 30       	cpi	r26, 0x0C	; 12
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	25 e0       	ldi	r18, 0x05	; 5
  8c:	ac e0       	ldi	r26, 0x0C	; 12
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ab 34       	cpi	r26, 0x4B	; 75
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 4d 01 	call	0x29a	; 0x29a <main>
  9e:	0c 94 73 06 	jmp	0xce6	; 0xce6 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  a6:	cf 93       	push	r28
  a8:	df 93       	push	r29
  aa:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
  ac:	0e 94 72 04 	call	0x8e4	; 0x8e4 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
  b0:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <__data_end>
  b4:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <__data_end+0x1>
  b8:	89 2b       	or	r24, r25
  ba:	31 f4       	brne	.+12     	; 0xc8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
  bc:	81 e1       	ldi	r24, 0x11	; 17
  be:	91 e0       	ldi	r25, 0x01	; 1
  c0:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <__data_end+0x1>
  c4:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
  c8:	20 91 0e 01 	lds	r18, 0x010E	; 0x80010e <xNextFreeByte>
  cc:	30 91 0f 01 	lds	r19, 0x010F	; 0x80010f <xNextFreeByte+0x1>
  d0:	ce 01       	movw	r24, r28
  d2:	82 0f       	add	r24, r18
  d4:	93 1f       	adc	r25, r19
  d6:	87 3e       	cpi	r24, 0xE7	; 231
  d8:	43 e0       	ldi	r20, 0x03	; 3
  da:	94 07       	cpc	r25, r20
  dc:	70 f4       	brcc	.+28     	; 0xfa <pvPortMalloc+0x54>
  de:	28 17       	cp	r18, r24
  e0:	39 07       	cpc	r19, r25
  e2:	70 f4       	brcc	.+28     	; 0x100 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
  e4:	c0 91 0c 01 	lds	r28, 0x010C	; 0x80010c <__data_end>
  e8:	d0 91 0d 01 	lds	r29, 0x010D	; 0x80010d <__data_end+0x1>
  ec:	c2 0f       	add	r28, r18
  ee:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
  f0:	90 93 0f 01 	sts	0x010F, r25	; 0x80010f <xNextFreeByte+0x1>
  f4:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <xNextFreeByte>
  f8:	05 c0       	rjmp	.+10     	; 0x104 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
  fa:	c0 e0       	ldi	r28, 0x00	; 0
  fc:	d0 e0       	ldi	r29, 0x00	; 0
  fe:	02 c0       	rjmp	.+4      	; 0x104 <pvPortMalloc+0x5e>
 100:	c0 e0       	ldi	r28, 0x00	; 0
 102:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 104:	0e 94 3d 05 	call	0xa7a	; 0xa7a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 108:	ce 01       	movw	r24, r28
 10a:	df 91       	pop	r29
 10c:	cf 91       	pop	r28
 10e:	08 95       	ret

00000110 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 110:	08 95       	ret

00000112 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 112:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 114:	03 96       	adiw	r24, 0x03	; 3
 116:	92 83       	std	Z+2, r25	; 0x02
 118:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 11a:	2f ef       	ldi	r18, 0xFF	; 255
 11c:	3f ef       	ldi	r19, 0xFF	; 255
 11e:	34 83       	std	Z+4, r19	; 0x04
 120:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 122:	96 83       	std	Z+6, r25	; 0x06
 124:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 126:	90 87       	std	Z+8, r25	; 0x08
 128:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 12a:	10 82       	st	Z, r1
 12c:	08 95       	ret

0000012e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 12e:	fc 01       	movw	r30, r24
 130:	11 86       	std	Z+9, r1	; 0x09
 132:	10 86       	std	Z+8, r1	; 0x08
 134:	08 95       	ret

00000136 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 136:	cf 93       	push	r28
 138:	df 93       	push	r29
 13a:	9c 01       	movw	r18, r24
 13c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 13e:	dc 01       	movw	r26, r24
 140:	11 96       	adiw	r26, 0x01	; 1
 142:	cd 91       	ld	r28, X+
 144:	dc 91       	ld	r29, X
 146:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 148:	d3 83       	std	Z+3, r29	; 0x03
 14a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 14c:	8c 81       	ldd	r24, Y+4	; 0x04
 14e:	9d 81       	ldd	r25, Y+5	; 0x05
 150:	95 83       	std	Z+5, r25	; 0x05
 152:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 154:	8c 81       	ldd	r24, Y+4	; 0x04
 156:	9d 81       	ldd	r25, Y+5	; 0x05
 158:	dc 01       	movw	r26, r24
 15a:	13 96       	adiw	r26, 0x03	; 3
 15c:	7c 93       	st	X, r23
 15e:	6e 93       	st	-X, r22
 160:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 162:	7d 83       	std	Y+5, r23	; 0x05
 164:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 166:	31 87       	std	Z+9, r19	; 0x09
 168:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 16a:	f9 01       	movw	r30, r18
 16c:	80 81       	ld	r24, Z
 16e:	8f 5f       	subi	r24, 0xFF	; 255
 170:	80 83       	st	Z, r24
}
 172:	df 91       	pop	r29
 174:	cf 91       	pop	r28
 176:	08 95       	ret

00000178 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 178:	cf 93       	push	r28
 17a:	df 93       	push	r29
 17c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 17e:	48 81       	ld	r20, Y
 180:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 182:	4f 3f       	cpi	r20, 0xFF	; 255
 184:	2f ef       	ldi	r18, 0xFF	; 255
 186:	52 07       	cpc	r21, r18
 188:	21 f4       	brne	.+8      	; 0x192 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 18a:	fc 01       	movw	r30, r24
 18c:	a7 81       	ldd	r26, Z+7	; 0x07
 18e:	b0 85       	ldd	r27, Z+8	; 0x08
 190:	0d c0       	rjmp	.+26     	; 0x1ac <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 192:	dc 01       	movw	r26, r24
 194:	13 96       	adiw	r26, 0x03	; 3
 196:	01 c0       	rjmp	.+2      	; 0x19a <vListInsert+0x22>
 198:	df 01       	movw	r26, r30
 19a:	12 96       	adiw	r26, 0x02	; 2
 19c:	ed 91       	ld	r30, X+
 19e:	fc 91       	ld	r31, X
 1a0:	13 97       	sbiw	r26, 0x03	; 3
 1a2:	20 81       	ld	r18, Z
 1a4:	31 81       	ldd	r19, Z+1	; 0x01
 1a6:	42 17       	cp	r20, r18
 1a8:	53 07       	cpc	r21, r19
 1aa:	b0 f7       	brcc	.-20     	; 0x198 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1ac:	12 96       	adiw	r26, 0x02	; 2
 1ae:	ed 91       	ld	r30, X+
 1b0:	fc 91       	ld	r31, X
 1b2:	13 97       	sbiw	r26, 0x03	; 3
 1b4:	fb 83       	std	Y+3, r31	; 0x03
 1b6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1b8:	d5 83       	std	Z+5, r29	; 0x05
 1ba:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 1bc:	bd 83       	std	Y+5, r27	; 0x05
 1be:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 1c0:	13 96       	adiw	r26, 0x03	; 3
 1c2:	dc 93       	st	X, r29
 1c4:	ce 93       	st	-X, r28
 1c6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1c8:	99 87       	std	Y+9, r25	; 0x09
 1ca:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1cc:	fc 01       	movw	r30, r24
 1ce:	20 81       	ld	r18, Z
 1d0:	2f 5f       	subi	r18, 0xFF	; 255
 1d2:	20 83       	st	Z, r18
}
 1d4:	df 91       	pop	r29
 1d6:	cf 91       	pop	r28
 1d8:	08 95       	ret

000001da <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 1da:	cf 93       	push	r28
 1dc:	df 93       	push	r29
 1de:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 1e0:	a0 85       	ldd	r26, Z+8	; 0x08
 1e2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1e4:	c2 81       	ldd	r28, Z+2	; 0x02
 1e6:	d3 81       	ldd	r29, Z+3	; 0x03
 1e8:	84 81       	ldd	r24, Z+4	; 0x04
 1ea:	95 81       	ldd	r25, Z+5	; 0x05
 1ec:	9d 83       	std	Y+5, r25	; 0x05
 1ee:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 1f0:	c4 81       	ldd	r28, Z+4	; 0x04
 1f2:	d5 81       	ldd	r29, Z+5	; 0x05
 1f4:	82 81       	ldd	r24, Z+2	; 0x02
 1f6:	93 81       	ldd	r25, Z+3	; 0x03
 1f8:	9b 83       	std	Y+3, r25	; 0x03
 1fa:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 1fc:	11 96       	adiw	r26, 0x01	; 1
 1fe:	cd 91       	ld	r28, X+
 200:	dc 91       	ld	r29, X
 202:	12 97       	sbiw	r26, 0x02	; 2
 204:	ce 17       	cp	r28, r30
 206:	df 07       	cpc	r29, r31
 208:	31 f4       	brne	.+12     	; 0x216 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 20a:	8c 81       	ldd	r24, Y+4	; 0x04
 20c:	9d 81       	ldd	r25, Y+5	; 0x05
 20e:	12 96       	adiw	r26, 0x02	; 2
 210:	9c 93       	st	X, r25
 212:	8e 93       	st	-X, r24
 214:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 216:	11 86       	std	Z+9, r1	; 0x09
 218:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 21a:	8c 91       	ld	r24, X
 21c:	81 50       	subi	r24, 0x01	; 1
 21e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 220:	df 91       	pop	r29
 222:	cf 91       	pop	r28
 224:	08 95       	ret

00000226 <vTestTask2>:
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
	}
}

static void vTestTask2( void *pvParameters )
{
 226:	cf 93       	push	r28
 228:	df 93       	push	r29
 22a:	00 d0       	rcall	.+0      	; 0x22c <vTestTask2+0x6>
 22c:	cd b7       	in	r28, 0x3d	; 61
 22e:	de b7       	in	r29, 0x3e	; 62
	( void ) pvParameters;
	vTaskSetApplicationTaskTag( NULL, ( void * ) 0x02 );
 230:	62 e0       	ldi	r22, 0x02	; 2
 232:	70 e0       	ldi	r23, 0x00	; 0
 234:	80 e0       	ldi	r24, 0x00	; 0
 236:	90 e0       	ldi	r25, 0x00	; 0
 238:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <vTaskSetApplicationTaskTag>
	uint8_t pinmask = 0x02;
	TickType_t xLastWakeTime;
	DDRD |= pinmask;
 23c:	51 9a       	sbi	0x0a, 1	; 10
	for( ;; )
	{
		xLastWakeTime = xTaskGetTickCount();
 23e:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskGetTickCount>
 242:	9a 83       	std	Y+2, r25	; 0x02
 244:	89 83       	std	Y+1, r24	; 0x01
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 246:	8f e9       	ldi	r24, 0x9F	; 159
 248:	9f e0       	ldi	r25, 0x0F	; 15
 24a:	01 97       	sbiw	r24, 0x01	; 1
 24c:	f1 f7       	brne	.-4      	; 0x24a <vTestTask2+0x24>
 24e:	00 c0       	rjmp	.+0      	; 0x250 <vTestTask2+0x2a>
 250:	00 00       	nop
		_delay_ms( 1 );   //simulate task work done
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
 252:	61 e0       	ldi	r22, 0x01	; 1
 254:	70 e0       	ldi	r23, 0x00	; 0
 256:	ce 01       	movw	r24, r28
 258:	01 96       	adiw	r24, 0x01	; 1
 25a:	0e 94 bc 05 	call	0xb78	; 0xb78 <vTaskDelayUntil>
	}
 25e:	ef cf       	rjmp	.-34     	; 0x23e <vTestTask2+0x18>

00000260 <vTestTask1>:
	vTaskStartScheduler();
	return 0;
}

static void vTestTask1( void *pvParameters )
{
 260:	cf 93       	push	r28
 262:	df 93       	push	r29
 264:	00 d0       	rcall	.+0      	; 0x266 <vTestTask1+0x6>
 266:	cd b7       	in	r28, 0x3d	; 61
 268:	de b7       	in	r29, 0x3e	; 62
	( void ) pvParameters;
	vTaskSetApplicationTaskTag( NULL, ( void * ) 0x01 );
 26a:	61 e0       	ldi	r22, 0x01	; 1
 26c:	70 e0       	ldi	r23, 0x00	; 0
 26e:	80 e0       	ldi	r24, 0x00	; 0
 270:	90 e0       	ldi	r25, 0x00	; 0
 272:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <vTaskSetApplicationTaskTag>
	uint8_t pinmask = 0x01;
	TickType_t xLastWakeTime;
	DDRD |= pinmask;
 276:	50 9a       	sbi	0x0a, 0	; 10
    for( ;; )
	{
		xLastWakeTime = xTaskGetTickCount();
 278:	0e 94 78 04 	call	0x8f0	; 0x8f0 <xTaskGetTickCount>
 27c:	9a 83       	std	Y+2, r25	; 0x02
 27e:	89 83       	std	Y+1, r24	; 0x01
 280:	8f e9       	ldi	r24, 0x9F	; 159
 282:	9f e0       	ldi	r25, 0x0F	; 15
 284:	01 97       	sbiw	r24, 0x01	; 1
 286:	f1 f7       	brne	.-4      	; 0x284 <vTestTask1+0x24>
 288:	00 c0       	rjmp	.+0      	; 0x28a <vTestTask1+0x2a>
 28a:	00 00       	nop
        _delay_ms( 1 );   //simulate task work done 
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
 28c:	61 e0       	ldi	r22, 0x01	; 1
 28e:	70 e0       	ldi	r23, 0x00	; 0
 290:	ce 01       	movw	r24, r28
 292:	01 96       	adiw	r24, 0x01	; 1
 294:	0e 94 bc 05 	call	0xb78	; 0xb78 <vTaskDelayUntil>
	}
 298:	ef cf       	rjmp	.-34     	; 0x278 <vTestTask1+0x18>

0000029a <main>:
void vContextSwitch();

const TickType_t xFrequency = 1;

int main( void )
{
 29a:	ef 92       	push	r14
 29c:	ff 92       	push	r15
 29e:	0f 93       	push	r16
	//PORTD |= 0x01;
    // create tasks and start scheduler
	xTaskCreate( vTestTask1, ( const char * ) "T1", 255, (void *)('1'), mainTEST_TASK_PRIORITY, NULL );
 2a0:	e1 2c       	mov	r14, r1
 2a2:	f1 2c       	mov	r15, r1
 2a4:	01 e0       	ldi	r16, 0x01	; 1
 2a6:	21 e3       	ldi	r18, 0x31	; 49
 2a8:	30 e0       	ldi	r19, 0x00	; 0
 2aa:	4f ef       	ldi	r20, 0xFF	; 255
 2ac:	50 e0       	ldi	r21, 0x00	; 0
 2ae:	60 e0       	ldi	r22, 0x00	; 0
 2b0:	71 e0       	ldi	r23, 0x01	; 1
 2b2:	80 e3       	ldi	r24, 0x30	; 48
 2b4:	91 e0       	ldi	r25, 0x01	; 1
 2b6:	0e 94 42 03 	call	0x684	; 0x684 <xTaskCreate>
	xTaskCreate( vTestTask2, ( const char * ) "T2", 255, (void *)('2'), mainTEST_TASK_PRIORITY, NULL );
 2ba:	22 e3       	ldi	r18, 0x32	; 50
 2bc:	30 e0       	ldi	r19, 0x00	; 0
 2be:	4f ef       	ldi	r20, 0xFF	; 255
 2c0:	50 e0       	ldi	r21, 0x00	; 0
 2c2:	63 e0       	ldi	r22, 0x03	; 3
 2c4:	71 e0       	ldi	r23, 0x01	; 1
 2c6:	83 e1       	ldi	r24, 0x13	; 19
 2c8:	91 e0       	ldi	r25, 0x01	; 1
 2ca:	0e 94 42 03 	call	0x684	; 0x684 <xTaskCreate>
	vTaskStartScheduler();
 2ce:	0e 94 48 04 	call	0x890	; 0x890 <vTaskStartScheduler>
	return 0;
}
 2d2:	80 e0       	ldi	r24, 0x00	; 0
 2d4:	90 e0       	ldi	r25, 0x00	; 0
 2d6:	0f 91       	pop	r16
 2d8:	ff 90       	pop	r15
 2da:	ef 90       	pop	r14
 2dc:	08 95       	ret

000002de <vContextSwitch>:
		vTaskDelayUntil( &xLastWakeTime, xFrequency );
	}
}

void vContextSwitch() {
	if (PORTD == 0x01) {
 2de:	8b b1       	in	r24, 0x0b	; 11
 2e0:	81 30       	cpi	r24, 0x01	; 1
 2e2:	19 f4       	brne	.+6      	; 0x2ea <vContextSwitch+0xc>
		PORTD &= ~0x01;
 2e4:	58 98       	cbi	0x0b, 0	; 11
		PORTD |= 0x02;
 2e6:	59 9a       	sbi	0x0b, 1	; 11
 2e8:	08 95       	ret
	} else {
		PORTD &= ~0x02;
 2ea:	59 98       	cbi	0x0b, 1	; 11
		PORTD |= 0x01;
 2ec:	58 9a       	sbi	0x0b, 0	; 11
 2ee:	08 95       	ret

000002f0 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 2f0:	31 e1       	ldi	r19, 0x11	; 17
 2f2:	fc 01       	movw	r30, r24
 2f4:	30 83       	st	Z, r19
 2f6:	31 97       	sbiw	r30, 0x01	; 1
 2f8:	22 e2       	ldi	r18, 0x22	; 34
 2fa:	20 83       	st	Z, r18
 2fc:	31 97       	sbiw	r30, 0x01	; 1
 2fe:	a3 e3       	ldi	r26, 0x33	; 51
 300:	a0 83       	st	Z, r26
 302:	31 97       	sbiw	r30, 0x01	; 1
 304:	60 83       	st	Z, r22
 306:	31 97       	sbiw	r30, 0x01	; 1
 308:	70 83       	st	Z, r23
 30a:	31 97       	sbiw	r30, 0x01	; 1
 30c:	10 82       	st	Z, r1
 30e:	31 97       	sbiw	r30, 0x01	; 1
 310:	60 e8       	ldi	r22, 0x80	; 128
 312:	60 83       	st	Z, r22
 314:	31 97       	sbiw	r30, 0x01	; 1
 316:	10 82       	st	Z, r1
 318:	31 97       	sbiw	r30, 0x01	; 1
 31a:	62 e0       	ldi	r22, 0x02	; 2
 31c:	60 83       	st	Z, r22
 31e:	31 97       	sbiw	r30, 0x01	; 1
 320:	63 e0       	ldi	r22, 0x03	; 3
 322:	60 83       	st	Z, r22
 324:	31 97       	sbiw	r30, 0x01	; 1
 326:	64 e0       	ldi	r22, 0x04	; 4
 328:	60 83       	st	Z, r22
 32a:	31 97       	sbiw	r30, 0x01	; 1
 32c:	65 e0       	ldi	r22, 0x05	; 5
 32e:	60 83       	st	Z, r22
 330:	31 97       	sbiw	r30, 0x01	; 1
 332:	66 e0       	ldi	r22, 0x06	; 6
 334:	60 83       	st	Z, r22
 336:	31 97       	sbiw	r30, 0x01	; 1
 338:	67 e0       	ldi	r22, 0x07	; 7
 33a:	60 83       	st	Z, r22
 33c:	31 97       	sbiw	r30, 0x01	; 1
 33e:	68 e0       	ldi	r22, 0x08	; 8
 340:	60 83       	st	Z, r22
 342:	31 97       	sbiw	r30, 0x01	; 1
 344:	69 e0       	ldi	r22, 0x09	; 9
 346:	60 83       	st	Z, r22
 348:	31 97       	sbiw	r30, 0x01	; 1
 34a:	60 e1       	ldi	r22, 0x10	; 16
 34c:	60 83       	st	Z, r22
 34e:	31 97       	sbiw	r30, 0x01	; 1
 350:	30 83       	st	Z, r19
 352:	31 97       	sbiw	r30, 0x01	; 1
 354:	32 e1       	ldi	r19, 0x12	; 18
 356:	30 83       	st	Z, r19
 358:	31 97       	sbiw	r30, 0x01	; 1
 35a:	33 e1       	ldi	r19, 0x13	; 19
 35c:	30 83       	st	Z, r19
 35e:	31 97       	sbiw	r30, 0x01	; 1
 360:	34 e1       	ldi	r19, 0x14	; 20
 362:	30 83       	st	Z, r19
 364:	31 97       	sbiw	r30, 0x01	; 1
 366:	35 e1       	ldi	r19, 0x15	; 21
 368:	30 83       	st	Z, r19
 36a:	31 97       	sbiw	r30, 0x01	; 1
 36c:	36 e1       	ldi	r19, 0x16	; 22
 36e:	30 83       	st	Z, r19
 370:	31 97       	sbiw	r30, 0x01	; 1
 372:	37 e1       	ldi	r19, 0x17	; 23
 374:	30 83       	st	Z, r19
 376:	31 97       	sbiw	r30, 0x01	; 1
 378:	38 e1       	ldi	r19, 0x18	; 24
 37a:	30 83       	st	Z, r19
 37c:	31 97       	sbiw	r30, 0x01	; 1
 37e:	39 e1       	ldi	r19, 0x19	; 25
 380:	30 83       	st	Z, r19
 382:	31 97       	sbiw	r30, 0x01	; 1
 384:	30 e2       	ldi	r19, 0x20	; 32
 386:	30 83       	st	Z, r19
 388:	31 97       	sbiw	r30, 0x01	; 1
 38a:	31 e2       	ldi	r19, 0x21	; 33
 38c:	30 83       	st	Z, r19
 38e:	31 97       	sbiw	r30, 0x01	; 1
 390:	20 83       	st	Z, r18
 392:	31 97       	sbiw	r30, 0x01	; 1
 394:	23 e2       	ldi	r18, 0x23	; 35
 396:	20 83       	st	Z, r18
 398:	31 97       	sbiw	r30, 0x01	; 1
 39a:	40 83       	st	Z, r20
 39c:	31 97       	sbiw	r30, 0x01	; 1
 39e:	50 83       	st	Z, r21
 3a0:	31 97       	sbiw	r30, 0x01	; 1
 3a2:	26 e2       	ldi	r18, 0x26	; 38
 3a4:	20 83       	st	Z, r18
 3a6:	31 97       	sbiw	r30, 0x01	; 1
 3a8:	27 e2       	ldi	r18, 0x27	; 39
 3aa:	20 83       	st	Z, r18
 3ac:	31 97       	sbiw	r30, 0x01	; 1
 3ae:	28 e2       	ldi	r18, 0x28	; 40
 3b0:	20 83       	st	Z, r18
 3b2:	31 97       	sbiw	r30, 0x01	; 1
 3b4:	29 e2       	ldi	r18, 0x29	; 41
 3b6:	20 83       	st	Z, r18
 3b8:	31 97       	sbiw	r30, 0x01	; 1
 3ba:	20 e3       	ldi	r18, 0x30	; 48
 3bc:	20 83       	st	Z, r18
 3be:	31 97       	sbiw	r30, 0x01	; 1
 3c0:	21 e3       	ldi	r18, 0x31	; 49
 3c2:	20 83       	st	Z, r18
 3c4:	86 97       	sbiw	r24, 0x26	; 38
 3c6:	08 95       	ret

000003c8 <xPortStartScheduler>:
 3c8:	8a e7       	ldi	r24, 0x7A	; 122
 3ca:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 3ce:	81 e1       	ldi	r24, 0x11	; 17
 3d0:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 3d4:	8b e0       	ldi	r24, 0x0B	; 11
 3d6:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 3da:	ef e6       	ldi	r30, 0x6F	; 111
 3dc:	f0 e0       	ldi	r31, 0x00	; 0
 3de:	80 81       	ld	r24, Z
 3e0:	82 60       	ori	r24, 0x02	; 2
 3e2:	80 83       	st	Z, r24
 3e4:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 3e8:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 3ec:	cd 91       	ld	r28, X+
 3ee:	cd bf       	out	0x3d, r28	; 61
 3f0:	dd 91       	ld	r29, X+
 3f2:	de bf       	out	0x3e, r29	; 62
 3f4:	ff 91       	pop	r31
 3f6:	ef 91       	pop	r30
 3f8:	df 91       	pop	r29
 3fa:	cf 91       	pop	r28
 3fc:	bf 91       	pop	r27
 3fe:	af 91       	pop	r26
 400:	9f 91       	pop	r25
 402:	8f 91       	pop	r24
 404:	7f 91       	pop	r23
 406:	6f 91       	pop	r22
 408:	5f 91       	pop	r21
 40a:	4f 91       	pop	r20
 40c:	3f 91       	pop	r19
 40e:	2f 91       	pop	r18
 410:	1f 91       	pop	r17
 412:	0f 91       	pop	r16
 414:	ff 90       	pop	r15
 416:	ef 90       	pop	r14
 418:	df 90       	pop	r13
 41a:	cf 90       	pop	r12
 41c:	bf 90       	pop	r11
 41e:	af 90       	pop	r10
 420:	9f 90       	pop	r9
 422:	8f 90       	pop	r8
 424:	7f 90       	pop	r7
 426:	6f 90       	pop	r6
 428:	5f 90       	pop	r5
 42a:	4f 90       	pop	r4
 42c:	3f 90       	pop	r3
 42e:	2f 90       	pop	r2
 430:	1f 90       	pop	r1
 432:	0f 90       	pop	r0
 434:	0f be       	out	0x3f, r0	; 63
 436:	0f 90       	pop	r0
 438:	08 95       	ret
 43a:	81 e0       	ldi	r24, 0x01	; 1
 43c:	08 95       	ret

0000043e <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 43e:	0f 92       	push	r0
 440:	0f b6       	in	r0, 0x3f	; 63
 442:	f8 94       	cli
 444:	0f 92       	push	r0
 446:	1f 92       	push	r1
 448:	11 24       	eor	r1, r1
 44a:	2f 92       	push	r2
 44c:	3f 92       	push	r3
 44e:	4f 92       	push	r4
 450:	5f 92       	push	r5
 452:	6f 92       	push	r6
 454:	7f 92       	push	r7
 456:	8f 92       	push	r8
 458:	9f 92       	push	r9
 45a:	af 92       	push	r10
 45c:	bf 92       	push	r11
 45e:	cf 92       	push	r12
 460:	df 92       	push	r13
 462:	ef 92       	push	r14
 464:	ff 92       	push	r15
 466:	0f 93       	push	r16
 468:	1f 93       	push	r17
 46a:	2f 93       	push	r18
 46c:	3f 93       	push	r19
 46e:	4f 93       	push	r20
 470:	5f 93       	push	r21
 472:	6f 93       	push	r22
 474:	7f 93       	push	r23
 476:	8f 93       	push	r24
 478:	9f 93       	push	r25
 47a:	af 93       	push	r26
 47c:	bf 93       	push	r27
 47e:	cf 93       	push	r28
 480:	df 93       	push	r29
 482:	ef 93       	push	r30
 484:	ff 93       	push	r31
 486:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 48a:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 48e:	0d b6       	in	r0, 0x3d	; 61
 490:	0d 92       	st	X+, r0
 492:	0e b6       	in	r0, 0x3e	; 62
 494:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 496:	0e 94 0b 06 	call	0xc16	; 0xc16 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 49a:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 49e:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 4a2:	cd 91       	ld	r28, X+
 4a4:	cd bf       	out	0x3d, r28	; 61
 4a6:	dd 91       	ld	r29, X+
 4a8:	de bf       	out	0x3e, r29	; 62
 4aa:	ff 91       	pop	r31
 4ac:	ef 91       	pop	r30
 4ae:	df 91       	pop	r29
 4b0:	cf 91       	pop	r28
 4b2:	bf 91       	pop	r27
 4b4:	af 91       	pop	r26
 4b6:	9f 91       	pop	r25
 4b8:	8f 91       	pop	r24
 4ba:	7f 91       	pop	r23
 4bc:	6f 91       	pop	r22
 4be:	5f 91       	pop	r21
 4c0:	4f 91       	pop	r20
 4c2:	3f 91       	pop	r19
 4c4:	2f 91       	pop	r18
 4c6:	1f 91       	pop	r17
 4c8:	0f 91       	pop	r16
 4ca:	ff 90       	pop	r15
 4cc:	ef 90       	pop	r14
 4ce:	df 90       	pop	r13
 4d0:	cf 90       	pop	r12
 4d2:	bf 90       	pop	r11
 4d4:	af 90       	pop	r10
 4d6:	9f 90       	pop	r9
 4d8:	8f 90       	pop	r8
 4da:	7f 90       	pop	r7
 4dc:	6f 90       	pop	r6
 4de:	5f 90       	pop	r5
 4e0:	4f 90       	pop	r4
 4e2:	3f 90       	pop	r3
 4e4:	2f 90       	pop	r2
 4e6:	1f 90       	pop	r1
 4e8:	0f 90       	pop	r0
 4ea:	0f be       	out	0x3f, r0	; 63
 4ec:	0f 90       	pop	r0

	asm volatile ( "ret" );
 4ee:	08 95       	ret

000004f0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 4f0:	0f 92       	push	r0
 4f2:	0f b6       	in	r0, 0x3f	; 63
 4f4:	f8 94       	cli
 4f6:	0f 92       	push	r0
 4f8:	1f 92       	push	r1
 4fa:	11 24       	eor	r1, r1
 4fc:	2f 92       	push	r2
 4fe:	3f 92       	push	r3
 500:	4f 92       	push	r4
 502:	5f 92       	push	r5
 504:	6f 92       	push	r6
 506:	7f 92       	push	r7
 508:	8f 92       	push	r8
 50a:	9f 92       	push	r9
 50c:	af 92       	push	r10
 50e:	bf 92       	push	r11
 510:	cf 92       	push	r12
 512:	df 92       	push	r13
 514:	ef 92       	push	r14
 516:	ff 92       	push	r15
 518:	0f 93       	push	r16
 51a:	1f 93       	push	r17
 51c:	2f 93       	push	r18
 51e:	3f 93       	push	r19
 520:	4f 93       	push	r20
 522:	5f 93       	push	r21
 524:	6f 93       	push	r22
 526:	7f 93       	push	r23
 528:	8f 93       	push	r24
 52a:	9f 93       	push	r25
 52c:	af 93       	push	r26
 52e:	bf 93       	push	r27
 530:	cf 93       	push	r28
 532:	df 93       	push	r29
 534:	ef 93       	push	r30
 536:	ff 93       	push	r31
 538:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 53c:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 540:	0d b6       	in	r0, 0x3d	; 61
 542:	0d 92       	st	X+, r0
 544:	0e b6       	in	r0, 0x3e	; 62
 546:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 548:	0e 94 82 04 	call	0x904	; 0x904 <xTaskIncrementTick>
 54c:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 54e:	0e 94 0b 06 	call	0xc16	; 0xc16 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 552:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 556:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 55a:	cd 91       	ld	r28, X+
 55c:	cd bf       	out	0x3d, r28	; 61
 55e:	dd 91       	ld	r29, X+
 560:	de bf       	out	0x3e, r29	; 62
 562:	ff 91       	pop	r31
 564:	ef 91       	pop	r30
 566:	df 91       	pop	r29
 568:	cf 91       	pop	r28
 56a:	bf 91       	pop	r27
 56c:	af 91       	pop	r26
 56e:	9f 91       	pop	r25
 570:	8f 91       	pop	r24
 572:	7f 91       	pop	r23
 574:	6f 91       	pop	r22
 576:	5f 91       	pop	r21
 578:	4f 91       	pop	r20
 57a:	3f 91       	pop	r19
 57c:	2f 91       	pop	r18
 57e:	1f 91       	pop	r17
 580:	0f 91       	pop	r16
 582:	ff 90       	pop	r15
 584:	ef 90       	pop	r14
 586:	df 90       	pop	r13
 588:	cf 90       	pop	r12
 58a:	bf 90       	pop	r11
 58c:	af 90       	pop	r10
 58e:	9f 90       	pop	r9
 590:	8f 90       	pop	r8
 592:	7f 90       	pop	r7
 594:	6f 90       	pop	r6
 596:	5f 90       	pop	r5
 598:	4f 90       	pop	r4
 59a:	3f 90       	pop	r3
 59c:	2f 90       	pop	r2
 59e:	1f 90       	pop	r1
 5a0:	0f 90       	pop	r0
 5a2:	0f be       	out	0x3f, r0	; 63
 5a4:	0f 90       	pop	r0

	asm volatile ( "ret" );
 5a6:	08 95       	ret

000005a8 <__vector_11>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER1_COMPA_vect , ISR_NAKED )
	{
		vPortYieldFromTick();
 5a8:	0e 94 78 02 	call	0x4f0	; 0x4f0 <vPortYieldFromTick>
		asm volatile ( "reti" );
 5ac:	18 95       	reti

000005ae <prvResetNextTaskUnblockTime>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
 5ae:	e0 91 11 05 	lds	r30, 0x0511	; 0x800511 <pxDelayedTaskList>
 5b2:	f0 91 12 05 	lds	r31, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 5b6:	80 81       	ld	r24, Z
 5b8:	81 11       	cpse	r24, r1
 5ba:	07 c0       	rjmp	.+14     	; 0x5ca <prvResetNextTaskUnblockTime+0x1c>
 5bc:	8f ef       	ldi	r24, 0xFF	; 255
 5be:	9f ef       	ldi	r25, 0xFF	; 255
 5c0:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <xNextTaskUnblockTime+0x1>
 5c4:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <xNextTaskUnblockTime>
 5c8:	08 95       	ret
 5ca:	e0 91 11 05 	lds	r30, 0x0511	; 0x800511 <pxDelayedTaskList>
 5ce:	f0 91 12 05 	lds	r31, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 5d2:	05 80       	ldd	r0, Z+5	; 0x05
 5d4:	f6 81       	ldd	r31, Z+6	; 0x06
 5d6:	e0 2d       	mov	r30, r0
 5d8:	06 80       	ldd	r0, Z+6	; 0x06
 5da:	f7 81       	ldd	r31, Z+7	; 0x07
 5dc:	e0 2d       	mov	r30, r0
 5de:	82 81       	ldd	r24, Z+2	; 0x02
 5e0:	93 81       	ldd	r25, Z+3	; 0x03
 5e2:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <xNextTaskUnblockTime+0x1>
 5e6:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <xNextTaskUnblockTime>
 5ea:	08 95       	ret

000005ec <prvIdleTask>:
 5ec:	c5 e2       	ldi	r28, 0x25	; 37
 5ee:	d5 e0       	ldi	r29, 0x05	; 5
 5f0:	88 81       	ld	r24, Y
 5f2:	82 30       	cpi	r24, 0x02	; 2
 5f4:	f0 f3       	brcs	.-4      	; 0x5f2 <prvIdleTask+0x6>
 5f6:	0e 94 1f 02 	call	0x43e	; 0x43e <vPortYield>
 5fa:	fa cf       	rjmp	.-12     	; 0x5f0 <prvIdleTask+0x4>

000005fc <prvAddCurrentTaskToDelayedList>:
 5fc:	0f 93       	push	r16
 5fe:	1f 93       	push	r17
 600:	cf 93       	push	r28
 602:	df 93       	push	r29
 604:	ec 01       	movw	r28, r24
 606:	00 91 03 05 	lds	r16, 0x0503	; 0x800503 <xTickCount>
 60a:	10 91 04 05 	lds	r17, 0x0504	; 0x800504 <xTickCount+0x1>
 60e:	80 91 49 05 	lds	r24, 0x0549	; 0x800549 <pxCurrentTCB>
 612:	90 91 4a 05 	lds	r25, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 616:	02 96       	adiw	r24, 0x02	; 2
 618:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
 61c:	c0 0f       	add	r28, r16
 61e:	d1 1f       	adc	r29, r17
 620:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 624:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 628:	d3 83       	std	Z+3, r29	; 0x03
 62a:	c2 83       	std	Z+2, r28	; 0x02
 62c:	c0 17       	cp	r28, r16
 62e:	d1 07       	cpc	r29, r17
 630:	68 f4       	brcc	.+26     	; 0x64c <prvAddCurrentTaskToDelayedList+0x50>
 632:	60 91 49 05 	lds	r22, 0x0549	; 0x800549 <pxCurrentTCB>
 636:	70 91 4a 05 	lds	r23, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 63a:	80 91 0f 05 	lds	r24, 0x050F	; 0x80050f <pxOverflowDelayedTaskList>
 63e:	90 91 10 05 	lds	r25, 0x0510	; 0x800510 <pxOverflowDelayedTaskList+0x1>
 642:	6e 5f       	subi	r22, 0xFE	; 254
 644:	7f 4f       	sbci	r23, 0xFF	; 255
 646:	0e 94 bc 00 	call	0x178	; 0x178 <vListInsert>
 64a:	17 c0       	rjmp	.+46     	; 0x67a <prvAddCurrentTaskToDelayedList+0x7e>
 64c:	60 91 49 05 	lds	r22, 0x0549	; 0x800549 <pxCurrentTCB>
 650:	70 91 4a 05 	lds	r23, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 654:	80 91 11 05 	lds	r24, 0x0511	; 0x800511 <pxDelayedTaskList>
 658:	90 91 12 05 	lds	r25, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 65c:	6e 5f       	subi	r22, 0xFE	; 254
 65e:	7f 4f       	sbci	r23, 0xFF	; 255
 660:	0e 94 bc 00 	call	0x178	; 0x178 <vListInsert>
 664:	80 91 fb 04 	lds	r24, 0x04FB	; 0x8004fb <xNextTaskUnblockTime>
 668:	90 91 fc 04 	lds	r25, 0x04FC	; 0x8004fc <xNextTaskUnblockTime+0x1>
 66c:	c8 17       	cp	r28, r24
 66e:	d9 07       	cpc	r29, r25
 670:	20 f4       	brcc	.+8      	; 0x67a <prvAddCurrentTaskToDelayedList+0x7e>
 672:	d0 93 fc 04 	sts	0x04FC, r29	; 0x8004fc <xNextTaskUnblockTime+0x1>
 676:	c0 93 fb 04 	sts	0x04FB, r28	; 0x8004fb <xNextTaskUnblockTime>
 67a:	df 91       	pop	r29
 67c:	cf 91       	pop	r28
 67e:	1f 91       	pop	r17
 680:	0f 91       	pop	r16
 682:	08 95       	ret

00000684 <xTaskCreate>:
 684:	4f 92       	push	r4
 686:	5f 92       	push	r5
 688:	6f 92       	push	r6
 68a:	7f 92       	push	r7
 68c:	8f 92       	push	r8
 68e:	9f 92       	push	r9
 690:	af 92       	push	r10
 692:	bf 92       	push	r11
 694:	cf 92       	push	r12
 696:	df 92       	push	r13
 698:	ef 92       	push	r14
 69a:	ff 92       	push	r15
 69c:	0f 93       	push	r16
 69e:	cf 93       	push	r28
 6a0:	df 93       	push	r29
 6a2:	4c 01       	movw	r8, r24
 6a4:	6b 01       	movw	r12, r22
 6a6:	5a 01       	movw	r10, r20
 6a8:	29 01       	movw	r4, r18
 6aa:	ca 01       	movw	r24, r20
 6ac:	0e 94 53 00 	call	0xa6	; 0xa6 <pvPortMalloc>
 6b0:	3c 01       	movw	r6, r24
 6b2:	89 2b       	or	r24, r25
 6b4:	09 f4       	brne	.+2      	; 0x6b8 <xTaskCreate+0x34>
 6b6:	db c0       	rjmp	.+438    	; 0x86e <xTaskCreate+0x1ea>
 6b8:	88 e2       	ldi	r24, 0x28	; 40
 6ba:	90 e0       	ldi	r25, 0x00	; 0
 6bc:	0e 94 53 00 	call	0xa6	; 0xa6 <pvPortMalloc>
 6c0:	ec 01       	movw	r28, r24
 6c2:	89 2b       	or	r24, r25
 6c4:	71 f0       	breq	.+28     	; 0x6e2 <xTaskCreate+0x5e>
 6c6:	78 8e       	std	Y+24, r7	; 0x18
 6c8:	6f 8a       	std	Y+23, r6	; 0x17
 6ca:	81 e0       	ldi	r24, 0x01	; 1
 6cc:	a8 1a       	sub	r10, r24
 6ce:	b1 08       	sbc	r11, r1
 6d0:	6a 0c       	add	r6, r10
 6d2:	7b 1c       	adc	r7, r11
 6d4:	d6 01       	movw	r26, r12
 6d6:	8c 91       	ld	r24, X
 6d8:	89 8f       	std	Y+25, r24	; 0x19
 6da:	8c 91       	ld	r24, X
 6dc:	81 11       	cpse	r24, r1
 6de:	05 c0       	rjmp	.+10     	; 0x6ea <xTaskCreate+0x66>
 6e0:	18 c0       	rjmp	.+48     	; 0x712 <xTaskCreate+0x8e>
 6e2:	c3 01       	movw	r24, r6
 6e4:	0e 94 88 00 	call	0x110	; 0x110 <vPortFree>
 6e8:	c2 c0       	rjmp	.+388    	; 0x86e <xTaskCreate+0x1ea>
 6ea:	ae 01       	movw	r20, r28
 6ec:	46 5e       	subi	r20, 0xE6	; 230
 6ee:	5f 4f       	sbci	r21, 0xFF	; 255
 6f0:	f6 01       	movw	r30, r12
 6f2:	31 96       	adiw	r30, 0x01	; 1
 6f4:	b8 e0       	ldi	r27, 0x08	; 8
 6f6:	cb 0e       	add	r12, r27
 6f8:	d1 1c       	adc	r13, r1
 6fa:	cf 01       	movw	r24, r30
 6fc:	21 91       	ld	r18, Z+
 6fe:	da 01       	movw	r26, r20
 700:	2d 93       	st	X+, r18
 702:	ad 01       	movw	r20, r26
 704:	dc 01       	movw	r26, r24
 706:	8c 91       	ld	r24, X
 708:	88 23       	and	r24, r24
 70a:	19 f0       	breq	.+6      	; 0x712 <xTaskCreate+0x8e>
 70c:	ec 15       	cp	r30, r12
 70e:	fd 05       	cpc	r31, r13
 710:	a1 f7       	brne	.-24     	; 0x6fa <xTaskCreate+0x76>
 712:	18 a2       	std	Y+32, r1	; 0x20
 714:	04 30       	cpi	r16, 0x04	; 4
 716:	08 f0       	brcs	.+2      	; 0x71a <xTaskCreate+0x96>
 718:	03 e0       	ldi	r16, 0x03	; 3
 71a:	0e 8b       	std	Y+22, r16	; 0x16
 71c:	6e 01       	movw	r12, r28
 71e:	b2 e0       	ldi	r27, 0x02	; 2
 720:	cb 0e       	add	r12, r27
 722:	d1 1c       	adc	r13, r1
 724:	c6 01       	movw	r24, r12
 726:	0e 94 97 00 	call	0x12e	; 0x12e <vListInitialiseItem>
 72a:	ce 01       	movw	r24, r28
 72c:	0c 96       	adiw	r24, 0x0c	; 12
 72e:	0e 94 97 00 	call	0x12e	; 0x12e <vListInitialiseItem>
 732:	d9 87       	std	Y+9, r29	; 0x09
 734:	c8 87       	std	Y+8, r28	; 0x08
 736:	84 e0       	ldi	r24, 0x04	; 4
 738:	90 e0       	ldi	r25, 0x00	; 0
 73a:	80 1b       	sub	r24, r16
 73c:	91 09       	sbc	r25, r1
 73e:	9d 87       	std	Y+13, r25	; 0x0d
 740:	8c 87       	std	Y+12, r24	; 0x0c
 742:	db 8b       	std	Y+19, r29	; 0x13
 744:	ca 8b       	std	Y+18, r28	; 0x12
 746:	1a a2       	std	Y+34, r1	; 0x22
 748:	19 a2       	std	Y+33, r1	; 0x21
 74a:	1b a2       	std	Y+35, r1	; 0x23
 74c:	1c a2       	std	Y+36, r1	; 0x24
 74e:	1d a2       	std	Y+37, r1	; 0x25
 750:	1e a2       	std	Y+38, r1	; 0x26
 752:	1f a2       	std	Y+39, r1	; 0x27
 754:	a2 01       	movw	r20, r4
 756:	b4 01       	movw	r22, r8
 758:	c3 01       	movw	r24, r6
 75a:	0e 94 78 01 	call	0x2f0	; 0x2f0 <pxPortInitialiseStack>
 75e:	99 83       	std	Y+1, r25	; 0x01
 760:	88 83       	st	Y, r24
 762:	e1 14       	cp	r14, r1
 764:	f1 04       	cpc	r15, r1
 766:	19 f0       	breq	.+6      	; 0x76e <xTaskCreate+0xea>
 768:	f7 01       	movw	r30, r14
 76a:	d1 83       	std	Z+1, r29	; 0x01
 76c:	c0 83       	st	Z, r28
 76e:	0f b6       	in	r0, 0x3f	; 63
 770:	f8 94       	cli
 772:	0f 92       	push	r0
 774:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <uxCurrentNumberOfTasks>
 778:	8f 5f       	subi	r24, 0xFF	; 255
 77a:	80 93 05 05 	sts	0x0505, r24	; 0x800505 <uxCurrentNumberOfTasks>
 77e:	80 91 49 05 	lds	r24, 0x0549	; 0x800549 <pxCurrentTCB>
 782:	90 91 4a 05 	lds	r25, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 786:	89 2b       	or	r24, r25
 788:	89 f5       	brne	.+98     	; 0x7ec <xTaskCreate+0x168>
 78a:	d0 93 4a 05 	sts	0x054A, r29	; 0x80054a <pxCurrentTCB+0x1>
 78e:	c0 93 49 05 	sts	0x0549, r28	; 0x800549 <pxCurrentTCB>
 792:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <uxCurrentNumberOfTasks>
 796:	81 30       	cpi	r24, 0x01	; 1
 798:	c9 f5       	brne	.+114    	; 0x80c <xTaskCreate+0x188>
 79a:	85 e2       	ldi	r24, 0x25	; 37
 79c:	95 e0       	ldi	r25, 0x05	; 5
 79e:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 7a2:	8e e2       	ldi	r24, 0x2E	; 46
 7a4:	95 e0       	ldi	r25, 0x05	; 5
 7a6:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 7aa:	87 e3       	ldi	r24, 0x37	; 55
 7ac:	95 e0       	ldi	r25, 0x05	; 5
 7ae:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 7b2:	80 e4       	ldi	r24, 0x40	; 64
 7b4:	95 e0       	ldi	r25, 0x05	; 5
 7b6:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 7ba:	8c e1       	ldi	r24, 0x1C	; 28
 7bc:	95 e0       	ldi	r25, 0x05	; 5
 7be:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 7c2:	83 e1       	ldi	r24, 0x13	; 19
 7c4:	95 e0       	ldi	r25, 0x05	; 5
 7c6:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 7ca:	86 e0       	ldi	r24, 0x06	; 6
 7cc:	95 e0       	ldi	r25, 0x05	; 5
 7ce:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 7d2:	8c e1       	ldi	r24, 0x1C	; 28
 7d4:	95 e0       	ldi	r25, 0x05	; 5
 7d6:	90 93 12 05 	sts	0x0512, r25	; 0x800512 <pxDelayedTaskList+0x1>
 7da:	80 93 11 05 	sts	0x0511, r24	; 0x800511 <pxDelayedTaskList>
 7de:	83 e1       	ldi	r24, 0x13	; 19
 7e0:	95 e0       	ldi	r25, 0x05	; 5
 7e2:	90 93 10 05 	sts	0x0510, r25	; 0x800510 <pxOverflowDelayedTaskList+0x1>
 7e6:	80 93 0f 05 	sts	0x050F, r24	; 0x80050f <pxOverflowDelayedTaskList>
 7ea:	10 c0       	rjmp	.+32     	; 0x80c <xTaskCreate+0x188>
 7ec:	80 91 01 05 	lds	r24, 0x0501	; 0x800501 <xSchedulerRunning>
 7f0:	81 11       	cpse	r24, r1
 7f2:	0c c0       	rjmp	.+24     	; 0x80c <xTaskCreate+0x188>
 7f4:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 7f8:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 7fc:	96 89       	ldd	r25, Z+22	; 0x16
 7fe:	8e 89       	ldd	r24, Y+22	; 0x16
 800:	89 17       	cp	r24, r25
 802:	20 f0       	brcs	.+8      	; 0x80c <xTaskCreate+0x188>
 804:	d0 93 4a 05 	sts	0x054A, r29	; 0x80054a <pxCurrentTCB+0x1>
 808:	c0 93 49 05 	sts	0x0549, r28	; 0x800549 <pxCurrentTCB>
 80c:	80 91 fd 04 	lds	r24, 0x04FD	; 0x8004fd <uxTaskNumber>
 810:	8f 5f       	subi	r24, 0xFF	; 255
 812:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <uxTaskNumber>
 816:	8e 89       	ldd	r24, Y+22	; 0x16
 818:	90 91 02 05 	lds	r25, 0x0502	; 0x800502 <uxTopReadyPriority>
 81c:	98 17       	cp	r25, r24
 81e:	10 f4       	brcc	.+4      	; 0x824 <xTaskCreate+0x1a0>
 820:	80 93 02 05 	sts	0x0502, r24	; 0x800502 <uxTopReadyPriority>
 824:	90 e0       	ldi	r25, 0x00	; 0
 826:	9c 01       	movw	r18, r24
 828:	22 0f       	add	r18, r18
 82a:	33 1f       	adc	r19, r19
 82c:	22 0f       	add	r18, r18
 82e:	33 1f       	adc	r19, r19
 830:	22 0f       	add	r18, r18
 832:	33 1f       	adc	r19, r19
 834:	82 0f       	add	r24, r18
 836:	93 1f       	adc	r25, r19
 838:	b6 01       	movw	r22, r12
 83a:	8b 5d       	subi	r24, 0xDB	; 219
 83c:	9a 4f       	sbci	r25, 0xFA	; 250
 83e:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
 842:	0f 90       	pop	r0
 844:	0f be       	out	0x3f, r0	; 63
 846:	80 91 01 05 	lds	r24, 0x0501	; 0x800501 <xSchedulerRunning>
 84a:	88 23       	and	r24, r24
 84c:	61 f0       	breq	.+24     	; 0x866 <xTaskCreate+0x1e2>
 84e:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 852:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 856:	96 89       	ldd	r25, Z+22	; 0x16
 858:	8e 89       	ldd	r24, Y+22	; 0x16
 85a:	98 17       	cp	r25, r24
 85c:	30 f4       	brcc	.+12     	; 0x86a <xTaskCreate+0x1e6>
 85e:	0e 94 1f 02 	call	0x43e	; 0x43e <vPortYield>
 862:	81 e0       	ldi	r24, 0x01	; 1
 864:	05 c0       	rjmp	.+10     	; 0x870 <xTaskCreate+0x1ec>
 866:	81 e0       	ldi	r24, 0x01	; 1
 868:	03 c0       	rjmp	.+6      	; 0x870 <xTaskCreate+0x1ec>
 86a:	81 e0       	ldi	r24, 0x01	; 1
 86c:	01 c0       	rjmp	.+2      	; 0x870 <xTaskCreate+0x1ec>
 86e:	8f ef       	ldi	r24, 0xFF	; 255
 870:	df 91       	pop	r29
 872:	cf 91       	pop	r28
 874:	0f 91       	pop	r16
 876:	ff 90       	pop	r15
 878:	ef 90       	pop	r14
 87a:	df 90       	pop	r13
 87c:	cf 90       	pop	r12
 87e:	bf 90       	pop	r11
 880:	af 90       	pop	r10
 882:	9f 90       	pop	r9
 884:	8f 90       	pop	r8
 886:	7f 90       	pop	r7
 888:	6f 90       	pop	r6
 88a:	5f 90       	pop	r5
 88c:	4f 90       	pop	r4
 88e:	08 95       	ret

00000890 <vTaskStartScheduler>:
 890:	ef 92       	push	r14
 892:	ff 92       	push	r15
 894:	0f 93       	push	r16
 896:	0f 2e       	mov	r0, r31
 898:	f9 ef       	ldi	r31, 0xF9	; 249
 89a:	ef 2e       	mov	r14, r31
 89c:	f4 e0       	ldi	r31, 0x04	; 4
 89e:	ff 2e       	mov	r15, r31
 8a0:	f0 2d       	mov	r31, r0
 8a2:	00 e0       	ldi	r16, 0x00	; 0
 8a4:	20 e0       	ldi	r18, 0x00	; 0
 8a6:	30 e0       	ldi	r19, 0x00	; 0
 8a8:	40 e5       	ldi	r20, 0x50	; 80
 8aa:	50 e0       	ldi	r21, 0x00	; 0
 8ac:	66 e0       	ldi	r22, 0x06	; 6
 8ae:	71 e0       	ldi	r23, 0x01	; 1
 8b0:	86 ef       	ldi	r24, 0xF6	; 246
 8b2:	92 e0       	ldi	r25, 0x02	; 2
 8b4:	0e 94 42 03 	call	0x684	; 0x684 <xTaskCreate>
 8b8:	81 30       	cpi	r24, 0x01	; 1
 8ba:	81 f4       	brne	.+32     	; 0x8dc <vTaskStartScheduler+0x4c>
 8bc:	f8 94       	cli
 8be:	8f ef       	ldi	r24, 0xFF	; 255
 8c0:	9f ef       	ldi	r25, 0xFF	; 255
 8c2:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <xNextTaskUnblockTime+0x1>
 8c6:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <xNextTaskUnblockTime>
 8ca:	81 e0       	ldi	r24, 0x01	; 1
 8cc:	80 93 01 05 	sts	0x0501, r24	; 0x800501 <xSchedulerRunning>
 8d0:	10 92 04 05 	sts	0x0504, r1	; 0x800504 <xTickCount+0x1>
 8d4:	10 92 03 05 	sts	0x0503, r1	; 0x800503 <xTickCount>
 8d8:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <xPortStartScheduler>
 8dc:	0f 91       	pop	r16
 8de:	ff 90       	pop	r15
 8e0:	ef 90       	pop	r14
 8e2:	08 95       	ret

000008e4 <vTaskSuspendAll>:
 8e4:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 8e8:	8f 5f       	subi	r24, 0xFF	; 255
 8ea:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <uxSchedulerSuspended>
 8ee:	08 95       	ret

000008f0 <xTaskGetTickCount>:
 8f0:	0f b6       	in	r0, 0x3f	; 63
 8f2:	f8 94       	cli
 8f4:	0f 92       	push	r0
 8f6:	80 91 03 05 	lds	r24, 0x0503	; 0x800503 <xTickCount>
 8fa:	90 91 04 05 	lds	r25, 0x0504	; 0x800504 <xTickCount+0x1>
 8fe:	0f 90       	pop	r0
 900:	0f be       	out	0x3f, r0	; 63
 902:	08 95       	ret

00000904 <xTaskIncrementTick>:
 904:	cf 92       	push	r12
 906:	df 92       	push	r13
 908:	ef 92       	push	r14
 90a:	ff 92       	push	r15
 90c:	0f 93       	push	r16
 90e:	1f 93       	push	r17
 910:	cf 93       	push	r28
 912:	df 93       	push	r29
 914:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 918:	81 11       	cpse	r24, r1
 91a:	99 c0       	rjmp	.+306    	; 0xa4e <xTaskIncrementTick+0x14a>
 91c:	e0 90 03 05 	lds	r14, 0x0503	; 0x800503 <xTickCount>
 920:	f0 90 04 05 	lds	r15, 0x0504	; 0x800504 <xTickCount+0x1>
 924:	8f ef       	ldi	r24, 0xFF	; 255
 926:	e8 1a       	sub	r14, r24
 928:	f8 0a       	sbc	r15, r24
 92a:	f0 92 04 05 	sts	0x0504, r15	; 0x800504 <xTickCount+0x1>
 92e:	e0 92 03 05 	sts	0x0503, r14	; 0x800503 <xTickCount>
 932:	e1 14       	cp	r14, r1
 934:	f1 04       	cpc	r15, r1
 936:	b9 f4       	brne	.+46     	; 0x966 <xTaskIncrementTick+0x62>
 938:	80 91 11 05 	lds	r24, 0x0511	; 0x800511 <pxDelayedTaskList>
 93c:	90 91 12 05 	lds	r25, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 940:	20 91 0f 05 	lds	r18, 0x050F	; 0x80050f <pxOverflowDelayedTaskList>
 944:	30 91 10 05 	lds	r19, 0x0510	; 0x800510 <pxOverflowDelayedTaskList+0x1>
 948:	30 93 12 05 	sts	0x0512, r19	; 0x800512 <pxDelayedTaskList+0x1>
 94c:	20 93 11 05 	sts	0x0511, r18	; 0x800511 <pxDelayedTaskList>
 950:	90 93 10 05 	sts	0x0510, r25	; 0x800510 <pxOverflowDelayedTaskList+0x1>
 954:	80 93 0f 05 	sts	0x050F, r24	; 0x80050f <pxOverflowDelayedTaskList>
 958:	80 91 fe 04 	lds	r24, 0x04FE	; 0x8004fe <xNumOfOverflows>
 95c:	8f 5f       	subi	r24, 0xFF	; 255
 95e:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <xNumOfOverflows>
 962:	0e 94 d7 02 	call	0x5ae	; 0x5ae <prvResetNextTaskUnblockTime>
 966:	80 91 fb 04 	lds	r24, 0x04FB	; 0x8004fb <xNextTaskUnblockTime>
 96a:	90 91 fc 04 	lds	r25, 0x04FC	; 0x8004fc <xNextTaskUnblockTime+0x1>
 96e:	e8 16       	cp	r14, r24
 970:	f9 06       	cpc	r15, r25
 972:	10 f4       	brcc	.+4      	; 0x978 <xTaskIncrementTick+0x74>
 974:	d1 2c       	mov	r13, r1
 976:	53 c0       	rjmp	.+166    	; 0xa1e <xTaskIncrementTick+0x11a>
 978:	d1 2c       	mov	r13, r1
 97a:	cc 24       	eor	r12, r12
 97c:	c3 94       	inc	r12
 97e:	e0 91 11 05 	lds	r30, 0x0511	; 0x800511 <pxDelayedTaskList>
 982:	f0 91 12 05 	lds	r31, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 986:	90 81       	ld	r25, Z
 988:	91 11       	cpse	r25, r1
 98a:	07 c0       	rjmp	.+14     	; 0x99a <xTaskIncrementTick+0x96>
 98c:	8f ef       	ldi	r24, 0xFF	; 255
 98e:	9f ef       	ldi	r25, 0xFF	; 255
 990:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <xNextTaskUnblockTime+0x1>
 994:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <xNextTaskUnblockTime>
 998:	42 c0       	rjmp	.+132    	; 0xa1e <xTaskIncrementTick+0x11a>
 99a:	e0 91 11 05 	lds	r30, 0x0511	; 0x800511 <pxDelayedTaskList>
 99e:	f0 91 12 05 	lds	r31, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 9a2:	05 80       	ldd	r0, Z+5	; 0x05
 9a4:	f6 81       	ldd	r31, Z+6	; 0x06
 9a6:	e0 2d       	mov	r30, r0
 9a8:	c6 81       	ldd	r28, Z+6	; 0x06
 9aa:	d7 81       	ldd	r29, Z+7	; 0x07
 9ac:	2a 81       	ldd	r18, Y+2	; 0x02
 9ae:	3b 81       	ldd	r19, Y+3	; 0x03
 9b0:	e2 16       	cp	r14, r18
 9b2:	f3 06       	cpc	r15, r19
 9b4:	28 f4       	brcc	.+10     	; 0x9c0 <xTaskIncrementTick+0xbc>
 9b6:	30 93 fc 04 	sts	0x04FC, r19	; 0x8004fc <xNextTaskUnblockTime+0x1>
 9ba:	20 93 fb 04 	sts	0x04FB, r18	; 0x8004fb <xNextTaskUnblockTime>
 9be:	2f c0       	rjmp	.+94     	; 0xa1e <xTaskIncrementTick+0x11a>
 9c0:	8e 01       	movw	r16, r28
 9c2:	0e 5f       	subi	r16, 0xFE	; 254
 9c4:	1f 4f       	sbci	r17, 0xFF	; 255
 9c6:	c8 01       	movw	r24, r16
 9c8:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
 9cc:	8c 89       	ldd	r24, Y+20	; 0x14
 9ce:	9d 89       	ldd	r25, Y+21	; 0x15
 9d0:	89 2b       	or	r24, r25
 9d2:	21 f0       	breq	.+8      	; 0x9dc <xTaskIncrementTick+0xd8>
 9d4:	ce 01       	movw	r24, r28
 9d6:	0c 96       	adiw	r24, 0x0c	; 12
 9d8:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
 9dc:	2e 89       	ldd	r18, Y+22	; 0x16
 9de:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <uxTopReadyPriority>
 9e2:	82 17       	cp	r24, r18
 9e4:	10 f4       	brcc	.+4      	; 0x9ea <xTaskIncrementTick+0xe6>
 9e6:	20 93 02 05 	sts	0x0502, r18	; 0x800502 <uxTopReadyPriority>
 9ea:	30 e0       	ldi	r19, 0x00	; 0
 9ec:	c9 01       	movw	r24, r18
 9ee:	88 0f       	add	r24, r24
 9f0:	99 1f       	adc	r25, r25
 9f2:	88 0f       	add	r24, r24
 9f4:	99 1f       	adc	r25, r25
 9f6:	88 0f       	add	r24, r24
 9f8:	99 1f       	adc	r25, r25
 9fa:	82 0f       	add	r24, r18
 9fc:	93 1f       	adc	r25, r19
 9fe:	b8 01       	movw	r22, r16
 a00:	8b 5d       	subi	r24, 0xDB	; 219
 a02:	9a 4f       	sbci	r25, 0xFA	; 250
 a04:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
 a08:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 a0c:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 a10:	9e 89       	ldd	r25, Y+22	; 0x16
 a12:	86 89       	ldd	r24, Z+22	; 0x16
 a14:	98 17       	cp	r25, r24
 a16:	08 f4       	brcc	.+2      	; 0xa1a <xTaskIncrementTick+0x116>
 a18:	b2 cf       	rjmp	.-156    	; 0x97e <xTaskIncrementTick+0x7a>
 a1a:	dc 2c       	mov	r13, r12
 a1c:	b0 cf       	rjmp	.-160    	; 0x97e <xTaskIncrementTick+0x7a>
 a1e:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 a22:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 a26:	86 89       	ldd	r24, Z+22	; 0x16
 a28:	90 e0       	ldi	r25, 0x00	; 0
 a2a:	fc 01       	movw	r30, r24
 a2c:	ee 0f       	add	r30, r30
 a2e:	ff 1f       	adc	r31, r31
 a30:	ee 0f       	add	r30, r30
 a32:	ff 1f       	adc	r31, r31
 a34:	ee 0f       	add	r30, r30
 a36:	ff 1f       	adc	r31, r31
 a38:	8e 0f       	add	r24, r30
 a3a:	9f 1f       	adc	r25, r31
 a3c:	fc 01       	movw	r30, r24
 a3e:	eb 5d       	subi	r30, 0xDB	; 219
 a40:	fa 4f       	sbci	r31, 0xFA	; 250
 a42:	80 81       	ld	r24, Z
 a44:	82 30       	cpi	r24, 0x02	; 2
 a46:	48 f0       	brcs	.+18     	; 0xa5a <xTaskIncrementTick+0x156>
 a48:	dd 24       	eor	r13, r13
 a4a:	d3 94       	inc	r13
 a4c:	06 c0       	rjmp	.+12     	; 0xa5a <xTaskIncrementTick+0x156>
 a4e:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <uxPendedTicks>
 a52:	8f 5f       	subi	r24, 0xFF	; 255
 a54:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <uxPendedTicks>
 a58:	d1 2c       	mov	r13, r1
 a5a:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <xYieldPending>
 a5e:	88 23       	and	r24, r24
 a60:	11 f0       	breq	.+4      	; 0xa66 <xTaskIncrementTick+0x162>
 a62:	dd 24       	eor	r13, r13
 a64:	d3 94       	inc	r13
 a66:	8d 2d       	mov	r24, r13
 a68:	df 91       	pop	r29
 a6a:	cf 91       	pop	r28
 a6c:	1f 91       	pop	r17
 a6e:	0f 91       	pop	r16
 a70:	ff 90       	pop	r15
 a72:	ef 90       	pop	r14
 a74:	df 90       	pop	r13
 a76:	cf 90       	pop	r12
 a78:	08 95       	ret

00000a7a <xTaskResumeAll>:
 a7a:	df 92       	push	r13
 a7c:	ef 92       	push	r14
 a7e:	ff 92       	push	r15
 a80:	0f 93       	push	r16
 a82:	1f 93       	push	r17
 a84:	cf 93       	push	r28
 a86:	df 93       	push	r29
 a88:	0f b6       	in	r0, 0x3f	; 63
 a8a:	f8 94       	cli
 a8c:	0f 92       	push	r0
 a8e:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 a92:	81 50       	subi	r24, 0x01	; 1
 a94:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <uxSchedulerSuspended>
 a98:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 a9c:	81 11       	cpse	r24, r1
 a9e:	5f c0       	rjmp	.+190    	; 0xb5e <xTaskResumeAll+0xe4>
 aa0:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <uxCurrentNumberOfTasks>
 aa4:	81 11       	cpse	r24, r1
 aa6:	33 c0       	rjmp	.+102    	; 0xb0e <xTaskResumeAll+0x94>
 aa8:	5d c0       	rjmp	.+186    	; 0xb64 <xTaskResumeAll+0xea>
 aaa:	d7 01       	movw	r26, r14
 aac:	15 96       	adiw	r26, 0x05	; 5
 aae:	ed 91       	ld	r30, X+
 ab0:	fc 91       	ld	r31, X
 ab2:	16 97       	sbiw	r26, 0x06	; 6
 ab4:	c6 81       	ldd	r28, Z+6	; 0x06
 ab6:	d7 81       	ldd	r29, Z+7	; 0x07
 ab8:	ce 01       	movw	r24, r28
 aba:	0c 96       	adiw	r24, 0x0c	; 12
 abc:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
 ac0:	8e 01       	movw	r16, r28
 ac2:	0e 5f       	subi	r16, 0xFE	; 254
 ac4:	1f 4f       	sbci	r17, 0xFF	; 255
 ac6:	c8 01       	movw	r24, r16
 ac8:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
 acc:	2e 89       	ldd	r18, Y+22	; 0x16
 ace:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <uxTopReadyPriority>
 ad2:	82 17       	cp	r24, r18
 ad4:	10 f4       	brcc	.+4      	; 0xada <xTaskResumeAll+0x60>
 ad6:	20 93 02 05 	sts	0x0502, r18	; 0x800502 <uxTopReadyPriority>
 ada:	30 e0       	ldi	r19, 0x00	; 0
 adc:	c9 01       	movw	r24, r18
 ade:	88 0f       	add	r24, r24
 ae0:	99 1f       	adc	r25, r25
 ae2:	88 0f       	add	r24, r24
 ae4:	99 1f       	adc	r25, r25
 ae6:	88 0f       	add	r24, r24
 ae8:	99 1f       	adc	r25, r25
 aea:	82 0f       	add	r24, r18
 aec:	93 1f       	adc	r25, r19
 aee:	b8 01       	movw	r22, r16
 af0:	8b 5d       	subi	r24, 0xDB	; 219
 af2:	9a 4f       	sbci	r25, 0xFA	; 250
 af4:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
 af8:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 afc:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 b00:	9e 89       	ldd	r25, Y+22	; 0x16
 b02:	86 89       	ldd	r24, Z+22	; 0x16
 b04:	98 17       	cp	r25, r24
 b06:	68 f0       	brcs	.+26     	; 0xb22 <xTaskResumeAll+0xa8>
 b08:	d0 92 ff 04 	sts	0x04FF, r13	; 0x8004ff <xYieldPending>
 b0c:	0a c0       	rjmp	.+20     	; 0xb22 <xTaskResumeAll+0xa8>
 b0e:	c0 e0       	ldi	r28, 0x00	; 0
 b10:	d0 e0       	ldi	r29, 0x00	; 0
 b12:	0f 2e       	mov	r0, r31
 b14:	f6 e0       	ldi	r31, 0x06	; 6
 b16:	ef 2e       	mov	r14, r31
 b18:	f5 e0       	ldi	r31, 0x05	; 5
 b1a:	ff 2e       	mov	r15, r31
 b1c:	f0 2d       	mov	r31, r0
 b1e:	dd 24       	eor	r13, r13
 b20:	d3 94       	inc	r13
 b22:	f7 01       	movw	r30, r14
 b24:	80 81       	ld	r24, Z
 b26:	81 11       	cpse	r24, r1
 b28:	c0 cf       	rjmp	.-128    	; 0xaaa <xTaskResumeAll+0x30>
 b2a:	cd 2b       	or	r28, r29
 b2c:	11 f0       	breq	.+4      	; 0xb32 <xTaskResumeAll+0xb8>
 b2e:	0e 94 d7 02 	call	0x5ae	; 0x5ae <prvResetNextTaskUnblockTime>
 b32:	c0 91 00 05 	lds	r28, 0x0500	; 0x800500 <uxPendedTicks>
 b36:	cc 23       	and	r28, r28
 b38:	51 f0       	breq	.+20     	; 0xb4e <xTaskResumeAll+0xd4>
 b3a:	d1 e0       	ldi	r29, 0x01	; 1
 b3c:	0e 94 82 04 	call	0x904	; 0x904 <xTaskIncrementTick>
 b40:	81 11       	cpse	r24, r1
 b42:	d0 93 ff 04 	sts	0x04FF, r29	; 0x8004ff <xYieldPending>
 b46:	c1 50       	subi	r28, 0x01	; 1
 b48:	c9 f7       	brne	.-14     	; 0xb3c <xTaskResumeAll+0xc2>
 b4a:	10 92 00 05 	sts	0x0500, r1	; 0x800500 <uxPendedTicks>
 b4e:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <xYieldPending>
 b52:	88 23       	and	r24, r24
 b54:	31 f0       	breq	.+12     	; 0xb62 <xTaskResumeAll+0xe8>
 b56:	0e 94 1f 02 	call	0x43e	; 0x43e <vPortYield>
 b5a:	81 e0       	ldi	r24, 0x01	; 1
 b5c:	03 c0       	rjmp	.+6      	; 0xb64 <xTaskResumeAll+0xea>
 b5e:	80 e0       	ldi	r24, 0x00	; 0
 b60:	01 c0       	rjmp	.+2      	; 0xb64 <xTaskResumeAll+0xea>
 b62:	80 e0       	ldi	r24, 0x00	; 0
 b64:	0f 90       	pop	r0
 b66:	0f be       	out	0x3f, r0	; 63
 b68:	df 91       	pop	r29
 b6a:	cf 91       	pop	r28
 b6c:	1f 91       	pop	r17
 b6e:	0f 91       	pop	r16
 b70:	ff 90       	pop	r15
 b72:	ef 90       	pop	r14
 b74:	df 90       	pop	r13
 b76:	08 95       	ret

00000b78 <vTaskDelayUntil>:
 b78:	0f 93       	push	r16
 b7a:	1f 93       	push	r17
 b7c:	cf 93       	push	r28
 b7e:	df 93       	push	r29
 b80:	8c 01       	movw	r16, r24
 b82:	eb 01       	movw	r28, r22
 b84:	0e 94 72 04 	call	0x8e4	; 0x8e4 <vTaskSuspendAll>
 b88:	80 91 03 05 	lds	r24, 0x0503	; 0x800503 <xTickCount>
 b8c:	90 91 04 05 	lds	r25, 0x0504	; 0x800504 <xTickCount+0x1>
 b90:	f8 01       	movw	r30, r16
 b92:	40 81       	ld	r20, Z
 b94:	51 81       	ldd	r21, Z+1	; 0x01
 b96:	9a 01       	movw	r18, r20
 b98:	2c 0f       	add	r18, r28
 b9a:	3d 1f       	adc	r19, r29
 b9c:	84 17       	cp	r24, r20
 b9e:	95 07       	cpc	r25, r21
 ba0:	48 f4       	brcc	.+18     	; 0xbb4 <vTaskDelayUntil+0x3c>
 ba2:	24 17       	cp	r18, r20
 ba4:	35 07       	cpc	r19, r21
 ba6:	f8 f4       	brcc	.+62     	; 0xbe6 <vTaskDelayUntil+0x6e>
 ba8:	31 83       	std	Z+1, r19	; 0x01
 baa:	20 83       	st	Z, r18
 bac:	82 17       	cp	r24, r18
 bae:	93 07       	cpc	r25, r19
 bb0:	78 f4       	brcc	.+30     	; 0xbd0 <vTaskDelayUntil+0x58>
 bb2:	07 c0       	rjmp	.+14     	; 0xbc2 <vTaskDelayUntil+0x4a>
 bb4:	24 17       	cp	r18, r20
 bb6:	35 07       	cpc	r19, r21
 bb8:	90 f0       	brcs	.+36     	; 0xbde <vTaskDelayUntil+0x66>
 bba:	82 17       	cp	r24, r18
 bbc:	93 07       	cpc	r25, r19
 bbe:	78 f0       	brcs	.+30     	; 0xbde <vTaskDelayUntil+0x66>
 bc0:	12 c0       	rjmp	.+36     	; 0xbe6 <vTaskDelayUntil+0x6e>
 bc2:	60 e0       	ldi	r22, 0x00	; 0
 bc4:	a9 01       	movw	r20, r18
 bc6:	48 1b       	sub	r20, r24
 bc8:	59 0b       	sbc	r21, r25
 bca:	ca 01       	movw	r24, r20
 bcc:	0e 94 fe 02 	call	0x5fc	; 0x5fc <prvAddCurrentTaskToDelayedList>
 bd0:	0e 94 3d 05 	call	0xa7a	; 0xa7a <xTaskResumeAll>
 bd4:	81 11       	cpse	r24, r1
 bd6:	0b c0       	rjmp	.+22     	; 0xbee <vTaskDelayUntil+0x76>
 bd8:	0e 94 1f 02 	call	0x43e	; 0x43e <vPortYield>
 bdc:	08 c0       	rjmp	.+16     	; 0xbee <vTaskDelayUntil+0x76>
 bde:	f8 01       	movw	r30, r16
 be0:	31 83       	std	Z+1, r19	; 0x01
 be2:	20 83       	st	Z, r18
 be4:	ee cf       	rjmp	.-36     	; 0xbc2 <vTaskDelayUntil+0x4a>
 be6:	f8 01       	movw	r30, r16
 be8:	31 83       	std	Z+1, r19	; 0x01
 bea:	20 83       	st	Z, r18
 bec:	f1 cf       	rjmp	.-30     	; 0xbd0 <vTaskDelayUntil+0x58>
 bee:	df 91       	pop	r29
 bf0:	cf 91       	pop	r28
 bf2:	1f 91       	pop	r17
 bf4:	0f 91       	pop	r16
 bf6:	08 95       	ret

00000bf8 <vTaskSetApplicationTaskTag>:
 bf8:	00 97       	sbiw	r24, 0x00	; 0
 bfa:	21 f4       	brne	.+8      	; 0xc04 <vTaskSetApplicationTaskTag+0xc>
 bfc:	80 91 49 05 	lds	r24, 0x0549	; 0x800549 <pxCurrentTCB>
 c00:	90 91 4a 05 	lds	r25, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 c04:	0f b6       	in	r0, 0x3f	; 63
 c06:	f8 94       	cli
 c08:	0f 92       	push	r0
 c0a:	fc 01       	movw	r30, r24
 c0c:	72 a3       	std	Z+34, r23	; 0x22
 c0e:	61 a3       	std	Z+33, r22	; 0x21
 c10:	0f 90       	pop	r0
 c12:	0f be       	out	0x3f, r0	; 63
 c14:	08 95       	ret

00000c16 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 c16:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 c1a:	88 23       	and	r24, r24
 c1c:	21 f0       	breq	.+8      	; 0xc26 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 c1e:	81 e0       	ldi	r24, 0x01	; 1
 c20:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <xYieldPending>
 c24:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 c26:	10 92 ff 04 	sts	0x04FF, r1	; 0x8004ff <xYieldPending>
		traceTASK_SWITCHED_OUT();
 c2a:	0e 94 6f 01 	call	0x2de	; 0x2de <vContextSwitch>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 c2e:	20 91 02 05 	lds	r18, 0x0502	; 0x800502 <uxTopReadyPriority>
 c32:	82 2f       	mov	r24, r18
 c34:	90 e0       	ldi	r25, 0x00	; 0
 c36:	fc 01       	movw	r30, r24
 c38:	ee 0f       	add	r30, r30
 c3a:	ff 1f       	adc	r31, r31
 c3c:	ee 0f       	add	r30, r30
 c3e:	ff 1f       	adc	r31, r31
 c40:	ee 0f       	add	r30, r30
 c42:	ff 1f       	adc	r31, r31
 c44:	e8 0f       	add	r30, r24
 c46:	f9 1f       	adc	r31, r25
 c48:	eb 5d       	subi	r30, 0xDB	; 219
 c4a:	fa 4f       	sbci	r31, 0xFA	; 250
 c4c:	30 81       	ld	r19, Z
 c4e:	31 11       	cpse	r19, r1
 c50:	11 c0       	rjmp	.+34     	; 0xc74 <vTaskSwitchContext+0x5e>
 c52:	21 50       	subi	r18, 0x01	; 1
 c54:	82 2f       	mov	r24, r18
 c56:	90 e0       	ldi	r25, 0x00	; 0
 c58:	fc 01       	movw	r30, r24
 c5a:	ee 0f       	add	r30, r30
 c5c:	ff 1f       	adc	r31, r31
 c5e:	ee 0f       	add	r30, r30
 c60:	ff 1f       	adc	r31, r31
 c62:	ee 0f       	add	r30, r30
 c64:	ff 1f       	adc	r31, r31
 c66:	e8 0f       	add	r30, r24
 c68:	f9 1f       	adc	r31, r25
 c6a:	eb 5d       	subi	r30, 0xDB	; 219
 c6c:	fa 4f       	sbci	r31, 0xFA	; 250
 c6e:	30 81       	ld	r19, Z
 c70:	33 23       	and	r19, r19
 c72:	79 f3       	breq	.-34     	; 0xc52 <vTaskSwitchContext+0x3c>
 c74:	ac 01       	movw	r20, r24
 c76:	44 0f       	add	r20, r20
 c78:	55 1f       	adc	r21, r21
 c7a:	44 0f       	add	r20, r20
 c7c:	55 1f       	adc	r21, r21
 c7e:	44 0f       	add	r20, r20
 c80:	55 1f       	adc	r21, r21
 c82:	48 0f       	add	r20, r24
 c84:	59 1f       	adc	r21, r25
 c86:	da 01       	movw	r26, r20
 c88:	ab 5d       	subi	r26, 0xDB	; 219
 c8a:	ba 4f       	sbci	r27, 0xFA	; 250
 c8c:	11 96       	adiw	r26, 0x01	; 1
 c8e:	ed 91       	ld	r30, X+
 c90:	fc 91       	ld	r31, X
 c92:	12 97       	sbiw	r26, 0x02	; 2
 c94:	02 80       	ldd	r0, Z+2	; 0x02
 c96:	f3 81       	ldd	r31, Z+3	; 0x03
 c98:	e0 2d       	mov	r30, r0
 c9a:	12 96       	adiw	r26, 0x02	; 2
 c9c:	fc 93       	st	X, r31
 c9e:	ee 93       	st	-X, r30
 ca0:	11 97       	sbiw	r26, 0x01	; 1
 ca2:	48 5d       	subi	r20, 0xD8	; 216
 ca4:	5a 4f       	sbci	r21, 0xFA	; 250
 ca6:	e4 17       	cp	r30, r20
 ca8:	f5 07       	cpc	r31, r21
 caa:	29 f4       	brne	.+10     	; 0xcb6 <vTaskSwitchContext+0xa0>
 cac:	42 81       	ldd	r20, Z+2	; 0x02
 cae:	53 81       	ldd	r21, Z+3	; 0x03
 cb0:	fd 01       	movw	r30, r26
 cb2:	52 83       	std	Z+2, r21	; 0x02
 cb4:	41 83       	std	Z+1, r20	; 0x01
 cb6:	fc 01       	movw	r30, r24
 cb8:	ee 0f       	add	r30, r30
 cba:	ff 1f       	adc	r31, r31
 cbc:	ee 0f       	add	r30, r30
 cbe:	ff 1f       	adc	r31, r31
 cc0:	ee 0f       	add	r30, r30
 cc2:	ff 1f       	adc	r31, r31
 cc4:	8e 0f       	add	r24, r30
 cc6:	9f 1f       	adc	r25, r31
 cc8:	fc 01       	movw	r30, r24
 cca:	eb 5d       	subi	r30, 0xDB	; 219
 ccc:	fa 4f       	sbci	r31, 0xFA	; 250
 cce:	01 80       	ldd	r0, Z+1	; 0x01
 cd0:	f2 81       	ldd	r31, Z+2	; 0x02
 cd2:	e0 2d       	mov	r30, r0
 cd4:	86 81       	ldd	r24, Z+6	; 0x06
 cd6:	97 81       	ldd	r25, Z+7	; 0x07
 cd8:	90 93 4a 05 	sts	0x054A, r25	; 0x80054a <pxCurrentTCB+0x1>
 cdc:	80 93 49 05 	sts	0x0549, r24	; 0x800549 <pxCurrentTCB>
 ce0:	20 93 02 05 	sts	0x0502, r18	; 0x800502 <uxTopReadyPriority>
 ce4:	08 95       	ret

00000ce6 <_exit>:
 ce6:	f8 94       	cli

00000ce8 <__stop_program>:
 ce8:	ff cf       	rjmp	.-2      	; 0xce8 <__stop_program>
