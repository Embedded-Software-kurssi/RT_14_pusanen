
RTOStasks.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000010  00800100  00000e48  00000edc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000e48  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000043f  00800110  00800110  00000eec  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000eec  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000f1c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000001f8  00000000  00000000  00000f5c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000273e  00000000  00000000  00001154  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000eca  00000000  00000000  00003892  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001501  00000000  00000000  0000475c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000058c  00000000  00000000  00005c60  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000e0a  00000000  00000000  000061ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001dcc  00000000  00000000  00006ff6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000208  00000000  00000000  00008dc2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 f2 02 	jmp	0x5e4	; 0x5e4 <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e8 e4       	ldi	r30, 0x48	; 72
  7c:	fe e0       	ldi	r31, 0x0E	; 14
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a0 31       	cpi	r26, 0x10	; 16
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	25 e0       	ldi	r18, 0x05	; 5
  8c:	a0 e1       	ldi	r26, 0x10	; 16
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	af 34       	cpi	r26, 0x4F	; 79
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 59 01 	call	0x2b2	; 0x2b2 <main>
  9e:	0c 94 22 07 	jmp	0xe44	; 0xe44 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <pvPortMalloc>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
  a6:	cf 93       	push	r28
  a8:	df 93       	push	r29
  aa:	ec 01       	movw	r28, r24
  ac:	0e 94 8e 04 	call	0x91c	; 0x91c <vTaskSuspendAll>
  b0:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__data_end>
  b4:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <__data_end+0x1>
  b8:	89 2b       	or	r24, r25
  ba:	31 f4       	brne	.+12     	; 0xc8 <pvPortMalloc+0x22>
  bc:	85 e1       	ldi	r24, 0x15	; 21
  be:	91 e0       	ldi	r25, 0x01	; 1
  c0:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <__data_end+0x1>
  c4:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <__data_end>
  c8:	20 91 12 01 	lds	r18, 0x0112	; 0x800112 <xNextFreeByte>
  cc:	30 91 13 01 	lds	r19, 0x0113	; 0x800113 <xNextFreeByte+0x1>
  d0:	ce 01       	movw	r24, r28
  d2:	82 0f       	add	r24, r18
  d4:	93 1f       	adc	r25, r19
  d6:	87 3e       	cpi	r24, 0xE7	; 231
  d8:	43 e0       	ldi	r20, 0x03	; 3
  da:	94 07       	cpc	r25, r20
  dc:	70 f4       	brcc	.+28     	; 0xfa <pvPortMalloc+0x54>
  de:	28 17       	cp	r18, r24
  e0:	39 07       	cpc	r19, r25
  e2:	70 f4       	brcc	.+28     	; 0x100 <pvPortMalloc+0x5a>
  e4:	c0 91 10 01 	lds	r28, 0x0110	; 0x800110 <__data_end>
  e8:	d0 91 11 01 	lds	r29, 0x0111	; 0x800111 <__data_end+0x1>
  ec:	c2 0f       	add	r28, r18
  ee:	d3 1f       	adc	r29, r19
  f0:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <xNextFreeByte+0x1>
  f4:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <xNextFreeByte>
  f8:	05 c0       	rjmp	.+10     	; 0x104 <pvPortMalloc+0x5e>
  fa:	c0 e0       	ldi	r28, 0x00	; 0
  fc:	d0 e0       	ldi	r29, 0x00	; 0
  fe:	02 c0       	rjmp	.+4      	; 0x104 <pvPortMalloc+0x5e>
 100:	c0 e0       	ldi	r28, 0x00	; 0
 102:	d0 e0       	ldi	r29, 0x00	; 0
 104:	0e 94 4f 05 	call	0xa9e	; 0xa9e <xTaskResumeAll>
 108:	ce 01       	movw	r24, r28
 10a:	df 91       	pop	r29
 10c:	cf 91       	pop	r28
 10e:	08 95       	ret

00000110 <vPortFree>:
 110:	08 95       	ret

00000112 <xPortGetFreeHeapSize>:
}
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
 112:	20 91 12 01 	lds	r18, 0x0112	; 0x800112 <xNextFreeByte>
 116:	30 91 13 01 	lds	r19, 0x0113	; 0x800113 <xNextFreeByte+0x1>
}
 11a:	87 ee       	ldi	r24, 0xE7	; 231
 11c:	93 e0       	ldi	r25, 0x03	; 3
 11e:	82 1b       	sub	r24, r18
 120:	93 0b       	sbc	r25, r19
 122:	08 95       	ret

00000124 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 124:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 126:	03 96       	adiw	r24, 0x03	; 3
 128:	92 83       	std	Z+2, r25	; 0x02
 12a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 12c:	2f ef       	ldi	r18, 0xFF	; 255
 12e:	3f ef       	ldi	r19, 0xFF	; 255
 130:	34 83       	std	Z+4, r19	; 0x04
 132:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 134:	96 83       	std	Z+6, r25	; 0x06
 136:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 138:	90 87       	std	Z+8, r25	; 0x08
 13a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 13c:	10 82       	st	Z, r1
 13e:	08 95       	ret

00000140 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 140:	fc 01       	movw	r30, r24
 142:	11 86       	std	Z+9, r1	; 0x09
 144:	10 86       	std	Z+8, r1	; 0x08
 146:	08 95       	ret

00000148 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 148:	cf 93       	push	r28
 14a:	df 93       	push	r29
 14c:	9c 01       	movw	r18, r24
 14e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 150:	dc 01       	movw	r26, r24
 152:	11 96       	adiw	r26, 0x01	; 1
 154:	cd 91       	ld	r28, X+
 156:	dc 91       	ld	r29, X
 158:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 15a:	d3 83       	std	Z+3, r29	; 0x03
 15c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 15e:	8c 81       	ldd	r24, Y+4	; 0x04
 160:	9d 81       	ldd	r25, Y+5	; 0x05
 162:	95 83       	std	Z+5, r25	; 0x05
 164:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 166:	8c 81       	ldd	r24, Y+4	; 0x04
 168:	9d 81       	ldd	r25, Y+5	; 0x05
 16a:	dc 01       	movw	r26, r24
 16c:	13 96       	adiw	r26, 0x03	; 3
 16e:	7c 93       	st	X, r23
 170:	6e 93       	st	-X, r22
 172:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 174:	7d 83       	std	Y+5, r23	; 0x05
 176:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 178:	31 87       	std	Z+9, r19	; 0x09
 17a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 17c:	f9 01       	movw	r30, r18
 17e:	80 81       	ld	r24, Z
 180:	8f 5f       	subi	r24, 0xFF	; 255
 182:	80 83       	st	Z, r24
}
 184:	df 91       	pop	r29
 186:	cf 91       	pop	r28
 188:	08 95       	ret

0000018a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 18a:	cf 93       	push	r28
 18c:	df 93       	push	r29
 18e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 190:	48 81       	ld	r20, Y
 192:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 194:	4f 3f       	cpi	r20, 0xFF	; 255
 196:	2f ef       	ldi	r18, 0xFF	; 255
 198:	52 07       	cpc	r21, r18
 19a:	21 f4       	brne	.+8      	; 0x1a4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 19c:	fc 01       	movw	r30, r24
 19e:	a7 81       	ldd	r26, Z+7	; 0x07
 1a0:	b0 85       	ldd	r27, Z+8	; 0x08
 1a2:	0d c0       	rjmp	.+26     	; 0x1be <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 1a4:	dc 01       	movw	r26, r24
 1a6:	13 96       	adiw	r26, 0x03	; 3
 1a8:	01 c0       	rjmp	.+2      	; 0x1ac <vListInsert+0x22>
 1aa:	df 01       	movw	r26, r30
 1ac:	12 96       	adiw	r26, 0x02	; 2
 1ae:	ed 91       	ld	r30, X+
 1b0:	fc 91       	ld	r31, X
 1b2:	13 97       	sbiw	r26, 0x03	; 3
 1b4:	20 81       	ld	r18, Z
 1b6:	31 81       	ldd	r19, Z+1	; 0x01
 1b8:	42 17       	cp	r20, r18
 1ba:	53 07       	cpc	r21, r19
 1bc:	b0 f7       	brcc	.-20     	; 0x1aa <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1be:	12 96       	adiw	r26, 0x02	; 2
 1c0:	ed 91       	ld	r30, X+
 1c2:	fc 91       	ld	r31, X
 1c4:	13 97       	sbiw	r26, 0x03	; 3
 1c6:	fb 83       	std	Y+3, r31	; 0x03
 1c8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1ca:	d5 83       	std	Z+5, r29	; 0x05
 1cc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 1ce:	bd 83       	std	Y+5, r27	; 0x05
 1d0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 1d2:	13 96       	adiw	r26, 0x03	; 3
 1d4:	dc 93       	st	X, r29
 1d6:	ce 93       	st	-X, r28
 1d8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1da:	99 87       	std	Y+9, r25	; 0x09
 1dc:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1de:	fc 01       	movw	r30, r24
 1e0:	20 81       	ld	r18, Z
 1e2:	2f 5f       	subi	r18, 0xFF	; 255
 1e4:	20 83       	st	Z, r18
}
 1e6:	df 91       	pop	r29
 1e8:	cf 91       	pop	r28
 1ea:	08 95       	ret

000001ec <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 1ec:	cf 93       	push	r28
 1ee:	df 93       	push	r29
 1f0:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 1f2:	a0 85       	ldd	r26, Z+8	; 0x08
 1f4:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1f6:	c2 81       	ldd	r28, Z+2	; 0x02
 1f8:	d3 81       	ldd	r29, Z+3	; 0x03
 1fa:	84 81       	ldd	r24, Z+4	; 0x04
 1fc:	95 81       	ldd	r25, Z+5	; 0x05
 1fe:	9d 83       	std	Y+5, r25	; 0x05
 200:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 202:	c4 81       	ldd	r28, Z+4	; 0x04
 204:	d5 81       	ldd	r29, Z+5	; 0x05
 206:	82 81       	ldd	r24, Z+2	; 0x02
 208:	93 81       	ldd	r25, Z+3	; 0x03
 20a:	9b 83       	std	Y+3, r25	; 0x03
 20c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 20e:	11 96       	adiw	r26, 0x01	; 1
 210:	cd 91       	ld	r28, X+
 212:	dc 91       	ld	r29, X
 214:	12 97       	sbiw	r26, 0x02	; 2
 216:	ce 17       	cp	r28, r30
 218:	df 07       	cpc	r29, r31
 21a:	31 f4       	brne	.+12     	; 0x228 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 21c:	8c 81       	ldd	r24, Y+4	; 0x04
 21e:	9d 81       	ldd	r25, Y+5	; 0x05
 220:	12 96       	adiw	r26, 0x02	; 2
 222:	9c 93       	st	X, r25
 224:	8e 93       	st	-X, r24
 226:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 228:	11 86       	std	Z+9, r1	; 0x09
 22a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 22c:	8c 91       	ld	r24, X
 22e:	81 50       	subi	r24, 0x01	; 1
 230:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 232:	df 91       	pop	r29
 234:	cf 91       	pop	r28
 236:	08 95       	ret

00000238 <vTestTask2>:

static void vTestTask2( void *pvParameters )
{
	( void ) pvParameters;
	uint8_t pinmask = 0x02;
	DDRD |= pinmask;
 238:	51 9a       	sbi	0x0a, 1	; 10
	for( ;; )
	{
		PORTD |= pinmask;
 23a:	59 9a       	sbi	0x0b, 1	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 23c:	8f e9       	ldi	r24, 0x9F	; 159
 23e:	9f e0       	ldi	r25, 0x0F	; 15
 240:	01 97       	sbiw	r24, 0x01	; 1
 242:	f1 f7       	brne	.-4      	; 0x240 <vTestTask2+0x8>
 244:	00 c0       	rjmp	.+0      	; 0x246 <vTestTask2+0xe>
 246:	00 00       	nop
		_delay_ms( 1 );   //simulate task work done
		PORTD &= ~pinmask;
 248:	59 98       	cbi	0x0b, 1	; 11
		vTaskDelay( 1 );
 24a:	81 e0       	ldi	r24, 0x01	; 1
 24c:	90 e0       	ldi	r25, 0x00	; 0
 24e:	0e 94 ce 05 	call	0xb9c	; 0xb9c <vTaskDelay>
	}
 252:	f3 cf       	rjmp	.-26     	; 0x23a <vTestTask2+0x2>

00000254 <vTestTask1>:
	volatile a = 1;
}


static void vTestTask1( void *pvParameters )
{
 254:	cf 93       	push	r28
 256:	df 93       	push	r29
 258:	cd b7       	in	r28, 0x3d	; 61
 25a:	de b7       	in	r29, 0x3e	; 62
 25c:	c2 5d       	subi	r28, 0xD2	; 210
 25e:	d1 09       	sbc	r29, r1
 260:	0f b6       	in	r0, 0x3f	; 63
 262:	f8 94       	cli
 264:	de bf       	out	0x3e, r29	; 62
 266:	0f be       	out	0x3f, r0	; 63
 268:	cd bf       	out	0x3d, r28	; 61
	( void ) pvParameters;
	uint8_t pinmask = 0x01; 
	DDRD |= pinmask;
 26a:	50 9a       	sbi	0x0a, 0	; 10
    for( ;; )
	{
		PORTD |= pinmask;
		volatile unsigned short lista[105];
		for (unsigned short i = 0; i < 105; i++) {
 26c:	e1 2c       	mov	r14, r1
 26e:	f1 2c       	mov	r15, r1
	( void ) pvParameters;
	uint8_t pinmask = 0x01; 
	DDRD |= pinmask;
    for( ;; )
	{
		PORTD |= pinmask;
 270:	58 9a       	sbi	0x0b, 0	; 11
		volatile unsigned short lista[105];
		for (unsigned short i = 0; i < 105; i++) {
 272:	0e 2d       	mov	r16, r14
 274:	1f 2d       	mov	r17, r15
			lista[i] = rand();
 276:	0e 94 af 06 	call	0xd5e	; 0xd5e <rand>
 27a:	f8 01       	movw	r30, r16
 27c:	ee 0f       	add	r30, r30
 27e:	ff 1f       	adc	r31, r31
 280:	21 e0       	ldi	r18, 0x01	; 1
 282:	30 e0       	ldi	r19, 0x00	; 0
 284:	2c 0f       	add	r18, r28
 286:	3d 1f       	adc	r19, r29
 288:	e2 0f       	add	r30, r18
 28a:	f3 1f       	adc	r31, r19
 28c:	91 83       	std	Z+1, r25	; 0x01
 28e:	80 83       	st	Z, r24
	DDRD |= pinmask;
    for( ;; )
	{
		PORTD |= pinmask;
		volatile unsigned short lista[105];
		for (unsigned short i = 0; i < 105; i++) {
 290:	0f 5f       	subi	r16, 0xFF	; 255
 292:	1f 4f       	sbci	r17, 0xFF	; 255
 294:	09 36       	cpi	r16, 0x69	; 105
 296:	11 05       	cpc	r17, r1
 298:	71 f7       	brne	.-36     	; 0x276 <vTestTask1+0x22>
 29a:	8f e9       	ldi	r24, 0x9F	; 159
 29c:	9f e0       	ldi	r25, 0x0F	; 15
 29e:	01 97       	sbiw	r24, 0x01	; 1
 2a0:	f1 f7       	brne	.-4      	; 0x29e <vTestTask1+0x4a>
 2a2:	00 c0       	rjmp	.+0      	; 0x2a4 <vTestTask1+0x50>
 2a4:	00 00       	nop
			lista[i] = rand();
		}		
        _delay_ms( 1 );   //simulate task work done
        PORTD &= ~pinmask; 
 2a6:	58 98       	cbi	0x0b, 0	; 11
        vTaskDelay( 1 );
 2a8:	81 e0       	ldi	r24, 0x01	; 1
 2aa:	90 e0       	ldi	r25, 0x00	; 0
 2ac:	0e 94 ce 05 	call	0xb9c	; 0xb9c <vTaskDelay>
	}
 2b0:	df cf       	rjmp	.-66     	; 0x270 <vTestTask1+0x1c>

000002b2 <main>:
static void vTestTask2( void *pvParameters );
/* FreeRTOS has several hooks available. If enabled in FreeRTOSConfig.h, the OS will call hooks 
   at each corresponding event  */

int main( void )
{
 2b2:	ef 92       	push	r14
 2b4:	ff 92       	push	r15
 2b6:	0f 93       	push	r16
 2b8:	cf 93       	push	r28
 2ba:	df 93       	push	r29
 2bc:	00 d0       	rcall	.+0      	; 0x2be <main+0xc>
 2be:	cd b7       	in	r28, 0x3d	; 61
 2c0:	de b7       	in	r29, 0x3e	; 62
    // create tasks and start scheduler
	xTaskCreate( vTestTask1, ( const char * ) "T1", 255, (void *)('1'), mainTEST_TASK_PRIORITY, NULL );
 2c2:	e1 2c       	mov	r14, r1
 2c4:	f1 2c       	mov	r15, r1
 2c6:	01 e0       	ldi	r16, 0x01	; 1
 2c8:	21 e3       	ldi	r18, 0x31	; 49
 2ca:	30 e0       	ldi	r19, 0x00	; 0
 2cc:	4f ef       	ldi	r20, 0xFF	; 255
 2ce:	50 e0       	ldi	r21, 0x00	; 0
 2d0:	64 e0       	ldi	r22, 0x04	; 4
 2d2:	71 e0       	ldi	r23, 0x01	; 1
 2d4:	8a e2       	ldi	r24, 0x2A	; 42
 2d6:	91 e0       	ldi	r25, 0x01	; 1
 2d8:	0e 94 60 03 	call	0x6c0	; 0x6c0 <xTaskCreate>
	xTaskCreate( vTestTask2, ( const char * ) "T2", 255, (void *)('2'), mainTEST_TASK_PRIORITY, NULL );
 2dc:	22 e3       	ldi	r18, 0x32	; 50
 2de:	30 e0       	ldi	r19, 0x00	; 0
 2e0:	4f ef       	ldi	r20, 0xFF	; 255
 2e2:	50 e0       	ldi	r21, 0x00	; 0
 2e4:	67 e0       	ldi	r22, 0x07	; 7
 2e6:	71 e0       	ldi	r23, 0x01	; 1
 2e8:	8c e1       	ldi	r24, 0x1C	; 28
 2ea:	91 e0       	ldi	r25, 0x01	; 1
 2ec:	0e 94 60 03 	call	0x6c0	; 0x6c0 <xTaskCreate>
	volatile int a = xPortGetFreeHeapSize();
 2f0:	0e 94 89 00 	call	0x112	; 0x112 <xPortGetFreeHeapSize>
 2f4:	9a 83       	std	Y+2, r25	; 0x02
 2f6:	89 83       	std	Y+1, r24	; 0x01
	vTaskStartScheduler();
 2f8:	0e 94 64 04 	call	0x8c8	; 0x8c8 <vTaskStartScheduler>
	return 0;
}
 2fc:	80 e0       	ldi	r24, 0x00	; 0
 2fe:	90 e0       	ldi	r25, 0x00	; 0
 300:	0f 90       	pop	r0
 302:	0f 90       	pop	r0
 304:	df 91       	pop	r29
 306:	cf 91       	pop	r28
 308:	0f 91       	pop	r16
 30a:	ff 90       	pop	r15
 30c:	ef 90       	pop	r14
 30e:	08 95       	ret

00000310 <vApplicationStackOverflowHook>:

void vApplicationStackOverflowHook( TaskHandle_t xTask,
                                    signed char *pcTaskName ) {
 310:	cf 93       	push	r28
 312:	df 93       	push	r29
 314:	00 d0       	rcall	.+0      	; 0x316 <vApplicationStackOverflowHook+0x6>
 316:	cd b7       	in	r28, 0x3d	; 61
 318:	de b7       	in	r29, 0x3e	; 62
	volatile a = 1;
 31a:	81 e0       	ldi	r24, 0x01	; 1
 31c:	90 e0       	ldi	r25, 0x00	; 0
 31e:	9a 83       	std	Y+2, r25	; 0x02
 320:	89 83       	std	Y+1, r24	; 0x01
}
 322:	0f 90       	pop	r0
 324:	0f 90       	pop	r0
 326:	df 91       	pop	r29
 328:	cf 91       	pop	r28
 32a:	08 95       	ret

0000032c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 32c:	31 e1       	ldi	r19, 0x11	; 17
 32e:	fc 01       	movw	r30, r24
 330:	30 83       	st	Z, r19
 332:	31 97       	sbiw	r30, 0x01	; 1
 334:	22 e2       	ldi	r18, 0x22	; 34
 336:	20 83       	st	Z, r18
 338:	31 97       	sbiw	r30, 0x01	; 1
 33a:	a3 e3       	ldi	r26, 0x33	; 51
 33c:	a0 83       	st	Z, r26
 33e:	31 97       	sbiw	r30, 0x01	; 1
 340:	60 83       	st	Z, r22
 342:	31 97       	sbiw	r30, 0x01	; 1
 344:	70 83       	st	Z, r23
 346:	31 97       	sbiw	r30, 0x01	; 1
 348:	10 82       	st	Z, r1
 34a:	31 97       	sbiw	r30, 0x01	; 1
 34c:	60 e8       	ldi	r22, 0x80	; 128
 34e:	60 83       	st	Z, r22
 350:	31 97       	sbiw	r30, 0x01	; 1
 352:	10 82       	st	Z, r1
 354:	31 97       	sbiw	r30, 0x01	; 1
 356:	62 e0       	ldi	r22, 0x02	; 2
 358:	60 83       	st	Z, r22
 35a:	31 97       	sbiw	r30, 0x01	; 1
 35c:	63 e0       	ldi	r22, 0x03	; 3
 35e:	60 83       	st	Z, r22
 360:	31 97       	sbiw	r30, 0x01	; 1
 362:	64 e0       	ldi	r22, 0x04	; 4
 364:	60 83       	st	Z, r22
 366:	31 97       	sbiw	r30, 0x01	; 1
 368:	65 e0       	ldi	r22, 0x05	; 5
 36a:	60 83       	st	Z, r22
 36c:	31 97       	sbiw	r30, 0x01	; 1
 36e:	66 e0       	ldi	r22, 0x06	; 6
 370:	60 83       	st	Z, r22
 372:	31 97       	sbiw	r30, 0x01	; 1
 374:	67 e0       	ldi	r22, 0x07	; 7
 376:	60 83       	st	Z, r22
 378:	31 97       	sbiw	r30, 0x01	; 1
 37a:	68 e0       	ldi	r22, 0x08	; 8
 37c:	60 83       	st	Z, r22
 37e:	31 97       	sbiw	r30, 0x01	; 1
 380:	69 e0       	ldi	r22, 0x09	; 9
 382:	60 83       	st	Z, r22
 384:	31 97       	sbiw	r30, 0x01	; 1
 386:	60 e1       	ldi	r22, 0x10	; 16
 388:	60 83       	st	Z, r22
 38a:	31 97       	sbiw	r30, 0x01	; 1
 38c:	30 83       	st	Z, r19
 38e:	31 97       	sbiw	r30, 0x01	; 1
 390:	32 e1       	ldi	r19, 0x12	; 18
 392:	30 83       	st	Z, r19
 394:	31 97       	sbiw	r30, 0x01	; 1
 396:	33 e1       	ldi	r19, 0x13	; 19
 398:	30 83       	st	Z, r19
 39a:	31 97       	sbiw	r30, 0x01	; 1
 39c:	34 e1       	ldi	r19, 0x14	; 20
 39e:	30 83       	st	Z, r19
 3a0:	31 97       	sbiw	r30, 0x01	; 1
 3a2:	35 e1       	ldi	r19, 0x15	; 21
 3a4:	30 83       	st	Z, r19
 3a6:	31 97       	sbiw	r30, 0x01	; 1
 3a8:	36 e1       	ldi	r19, 0x16	; 22
 3aa:	30 83       	st	Z, r19
 3ac:	31 97       	sbiw	r30, 0x01	; 1
 3ae:	37 e1       	ldi	r19, 0x17	; 23
 3b0:	30 83       	st	Z, r19
 3b2:	31 97       	sbiw	r30, 0x01	; 1
 3b4:	38 e1       	ldi	r19, 0x18	; 24
 3b6:	30 83       	st	Z, r19
 3b8:	31 97       	sbiw	r30, 0x01	; 1
 3ba:	39 e1       	ldi	r19, 0x19	; 25
 3bc:	30 83       	st	Z, r19
 3be:	31 97       	sbiw	r30, 0x01	; 1
 3c0:	30 e2       	ldi	r19, 0x20	; 32
 3c2:	30 83       	st	Z, r19
 3c4:	31 97       	sbiw	r30, 0x01	; 1
 3c6:	31 e2       	ldi	r19, 0x21	; 33
 3c8:	30 83       	st	Z, r19
 3ca:	31 97       	sbiw	r30, 0x01	; 1
 3cc:	20 83       	st	Z, r18
 3ce:	31 97       	sbiw	r30, 0x01	; 1
 3d0:	23 e2       	ldi	r18, 0x23	; 35
 3d2:	20 83       	st	Z, r18
 3d4:	31 97       	sbiw	r30, 0x01	; 1
 3d6:	40 83       	st	Z, r20
 3d8:	31 97       	sbiw	r30, 0x01	; 1
 3da:	50 83       	st	Z, r21
 3dc:	31 97       	sbiw	r30, 0x01	; 1
 3de:	26 e2       	ldi	r18, 0x26	; 38
 3e0:	20 83       	st	Z, r18
 3e2:	31 97       	sbiw	r30, 0x01	; 1
 3e4:	27 e2       	ldi	r18, 0x27	; 39
 3e6:	20 83       	st	Z, r18
 3e8:	31 97       	sbiw	r30, 0x01	; 1
 3ea:	28 e2       	ldi	r18, 0x28	; 40
 3ec:	20 83       	st	Z, r18
 3ee:	31 97       	sbiw	r30, 0x01	; 1
 3f0:	29 e2       	ldi	r18, 0x29	; 41
 3f2:	20 83       	st	Z, r18
 3f4:	31 97       	sbiw	r30, 0x01	; 1
 3f6:	20 e3       	ldi	r18, 0x30	; 48
 3f8:	20 83       	st	Z, r18
 3fa:	31 97       	sbiw	r30, 0x01	; 1
 3fc:	21 e3       	ldi	r18, 0x31	; 49
 3fe:	20 83       	st	Z, r18
 400:	86 97       	sbiw	r24, 0x26	; 38
 402:	08 95       	ret

00000404 <xPortStartScheduler>:
 404:	8a e7       	ldi	r24, 0x7A	; 122
 406:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 40a:	81 e1       	ldi	r24, 0x11	; 17
 40c:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 410:	8b e0       	ldi	r24, 0x0B	; 11
 412:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 416:	ef e6       	ldi	r30, 0x6F	; 111
 418:	f0 e0       	ldi	r31, 0x00	; 0
 41a:	80 81       	ld	r24, Z
 41c:	82 60       	ori	r24, 0x02	; 2
 41e:	80 83       	st	Z, r24
 420:	a0 91 4d 05 	lds	r26, 0x054D	; 0x80054d <pxCurrentTCB>
 424:	b0 91 4e 05 	lds	r27, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 428:	cd 91       	ld	r28, X+
 42a:	cd bf       	out	0x3d, r28	; 61
 42c:	dd 91       	ld	r29, X+
 42e:	de bf       	out	0x3e, r29	; 62
 430:	ff 91       	pop	r31
 432:	ef 91       	pop	r30
 434:	df 91       	pop	r29
 436:	cf 91       	pop	r28
 438:	bf 91       	pop	r27
 43a:	af 91       	pop	r26
 43c:	9f 91       	pop	r25
 43e:	8f 91       	pop	r24
 440:	7f 91       	pop	r23
 442:	6f 91       	pop	r22
 444:	5f 91       	pop	r21
 446:	4f 91       	pop	r20
 448:	3f 91       	pop	r19
 44a:	2f 91       	pop	r18
 44c:	1f 91       	pop	r17
 44e:	0f 91       	pop	r16
 450:	ff 90       	pop	r15
 452:	ef 90       	pop	r14
 454:	df 90       	pop	r13
 456:	cf 90       	pop	r12
 458:	bf 90       	pop	r11
 45a:	af 90       	pop	r10
 45c:	9f 90       	pop	r9
 45e:	8f 90       	pop	r8
 460:	7f 90       	pop	r7
 462:	6f 90       	pop	r6
 464:	5f 90       	pop	r5
 466:	4f 90       	pop	r4
 468:	3f 90       	pop	r3
 46a:	2f 90       	pop	r2
 46c:	1f 90       	pop	r1
 46e:	0f 90       	pop	r0
 470:	0f be       	out	0x3f, r0	; 63
 472:	0f 90       	pop	r0
 474:	08 95       	ret
 476:	81 e0       	ldi	r24, 0x01	; 1
 478:	08 95       	ret

0000047a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 47a:	0f 92       	push	r0
 47c:	0f b6       	in	r0, 0x3f	; 63
 47e:	f8 94       	cli
 480:	0f 92       	push	r0
 482:	1f 92       	push	r1
 484:	11 24       	eor	r1, r1
 486:	2f 92       	push	r2
 488:	3f 92       	push	r3
 48a:	4f 92       	push	r4
 48c:	5f 92       	push	r5
 48e:	6f 92       	push	r6
 490:	7f 92       	push	r7
 492:	8f 92       	push	r8
 494:	9f 92       	push	r9
 496:	af 92       	push	r10
 498:	bf 92       	push	r11
 49a:	cf 92       	push	r12
 49c:	df 92       	push	r13
 49e:	ef 92       	push	r14
 4a0:	ff 92       	push	r15
 4a2:	0f 93       	push	r16
 4a4:	1f 93       	push	r17
 4a6:	2f 93       	push	r18
 4a8:	3f 93       	push	r19
 4aa:	4f 93       	push	r20
 4ac:	5f 93       	push	r21
 4ae:	6f 93       	push	r22
 4b0:	7f 93       	push	r23
 4b2:	8f 93       	push	r24
 4b4:	9f 93       	push	r25
 4b6:	af 93       	push	r26
 4b8:	bf 93       	push	r27
 4ba:	cf 93       	push	r28
 4bc:	df 93       	push	r29
 4be:	ef 93       	push	r30
 4c0:	ff 93       	push	r31
 4c2:	a0 91 4d 05 	lds	r26, 0x054D	; 0x80054d <pxCurrentTCB>
 4c6:	b0 91 4e 05 	lds	r27, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 4ca:	0d b6       	in	r0, 0x3d	; 61
 4cc:	0d 92       	st	X+, r0
 4ce:	0e b6       	in	r0, 0x3e	; 62
 4d0:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 4d2:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 4d6:	a0 91 4d 05 	lds	r26, 0x054D	; 0x80054d <pxCurrentTCB>
 4da:	b0 91 4e 05 	lds	r27, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 4de:	cd 91       	ld	r28, X+
 4e0:	cd bf       	out	0x3d, r28	; 61
 4e2:	dd 91       	ld	r29, X+
 4e4:	de bf       	out	0x3e, r29	; 62
 4e6:	ff 91       	pop	r31
 4e8:	ef 91       	pop	r30
 4ea:	df 91       	pop	r29
 4ec:	cf 91       	pop	r28
 4ee:	bf 91       	pop	r27
 4f0:	af 91       	pop	r26
 4f2:	9f 91       	pop	r25
 4f4:	8f 91       	pop	r24
 4f6:	7f 91       	pop	r23
 4f8:	6f 91       	pop	r22
 4fa:	5f 91       	pop	r21
 4fc:	4f 91       	pop	r20
 4fe:	3f 91       	pop	r19
 500:	2f 91       	pop	r18
 502:	1f 91       	pop	r17
 504:	0f 91       	pop	r16
 506:	ff 90       	pop	r15
 508:	ef 90       	pop	r14
 50a:	df 90       	pop	r13
 50c:	cf 90       	pop	r12
 50e:	bf 90       	pop	r11
 510:	af 90       	pop	r10
 512:	9f 90       	pop	r9
 514:	8f 90       	pop	r8
 516:	7f 90       	pop	r7
 518:	6f 90       	pop	r6
 51a:	5f 90       	pop	r5
 51c:	4f 90       	pop	r4
 51e:	3f 90       	pop	r3
 520:	2f 90       	pop	r2
 522:	1f 90       	pop	r1
 524:	0f 90       	pop	r0
 526:	0f be       	out	0x3f, r0	; 63
 528:	0f 90       	pop	r0

	asm volatile ( "ret" );
 52a:	08 95       	ret

0000052c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 52c:	0f 92       	push	r0
 52e:	0f b6       	in	r0, 0x3f	; 63
 530:	f8 94       	cli
 532:	0f 92       	push	r0
 534:	1f 92       	push	r1
 536:	11 24       	eor	r1, r1
 538:	2f 92       	push	r2
 53a:	3f 92       	push	r3
 53c:	4f 92       	push	r4
 53e:	5f 92       	push	r5
 540:	6f 92       	push	r6
 542:	7f 92       	push	r7
 544:	8f 92       	push	r8
 546:	9f 92       	push	r9
 548:	af 92       	push	r10
 54a:	bf 92       	push	r11
 54c:	cf 92       	push	r12
 54e:	df 92       	push	r13
 550:	ef 92       	push	r14
 552:	ff 92       	push	r15
 554:	0f 93       	push	r16
 556:	1f 93       	push	r17
 558:	2f 93       	push	r18
 55a:	3f 93       	push	r19
 55c:	4f 93       	push	r20
 55e:	5f 93       	push	r21
 560:	6f 93       	push	r22
 562:	7f 93       	push	r23
 564:	8f 93       	push	r24
 566:	9f 93       	push	r25
 568:	af 93       	push	r26
 56a:	bf 93       	push	r27
 56c:	cf 93       	push	r28
 56e:	df 93       	push	r29
 570:	ef 93       	push	r30
 572:	ff 93       	push	r31
 574:	a0 91 4d 05 	lds	r26, 0x054D	; 0x80054d <pxCurrentTCB>
 578:	b0 91 4e 05 	lds	r27, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 57c:	0d b6       	in	r0, 0x3d	; 61
 57e:	0d 92       	st	X+, r0
 580:	0e b6       	in	r0, 0x3e	; 62
 582:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 584:	0e 94 94 04 	call	0x928	; 0x928 <xTaskIncrementTick>
 588:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 58a:	0e 94 e2 05 	call	0xbc4	; 0xbc4 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 58e:	a0 91 4d 05 	lds	r26, 0x054D	; 0x80054d <pxCurrentTCB>
 592:	b0 91 4e 05 	lds	r27, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 596:	cd 91       	ld	r28, X+
 598:	cd bf       	out	0x3d, r28	; 61
 59a:	dd 91       	ld	r29, X+
 59c:	de bf       	out	0x3e, r29	; 62
 59e:	ff 91       	pop	r31
 5a0:	ef 91       	pop	r30
 5a2:	df 91       	pop	r29
 5a4:	cf 91       	pop	r28
 5a6:	bf 91       	pop	r27
 5a8:	af 91       	pop	r26
 5aa:	9f 91       	pop	r25
 5ac:	8f 91       	pop	r24
 5ae:	7f 91       	pop	r23
 5b0:	6f 91       	pop	r22
 5b2:	5f 91       	pop	r21
 5b4:	4f 91       	pop	r20
 5b6:	3f 91       	pop	r19
 5b8:	2f 91       	pop	r18
 5ba:	1f 91       	pop	r17
 5bc:	0f 91       	pop	r16
 5be:	ff 90       	pop	r15
 5c0:	ef 90       	pop	r14
 5c2:	df 90       	pop	r13
 5c4:	cf 90       	pop	r12
 5c6:	bf 90       	pop	r11
 5c8:	af 90       	pop	r10
 5ca:	9f 90       	pop	r9
 5cc:	8f 90       	pop	r8
 5ce:	7f 90       	pop	r7
 5d0:	6f 90       	pop	r6
 5d2:	5f 90       	pop	r5
 5d4:	4f 90       	pop	r4
 5d6:	3f 90       	pop	r3
 5d8:	2f 90       	pop	r2
 5da:	1f 90       	pop	r1
 5dc:	0f 90       	pop	r0
 5de:	0f be       	out	0x3f, r0	; 63
 5e0:	0f 90       	pop	r0

	asm volatile ( "ret" );
 5e2:	08 95       	ret

000005e4 <__vector_11>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER1_COMPA_vect , ISR_NAKED )
	{
		vPortYieldFromTick();
 5e4:	0e 94 96 02 	call	0x52c	; 0x52c <vPortYieldFromTick>
		asm volatile ( "reti" );
 5e8:	18 95       	reti

000005ea <prvResetNextTaskUnblockTime>:
	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
 5ea:	e0 91 15 05 	lds	r30, 0x0515	; 0x800515 <pxDelayedTaskList>
 5ee:	f0 91 16 05 	lds	r31, 0x0516	; 0x800516 <pxDelayedTaskList+0x1>
 5f2:	80 81       	ld	r24, Z
 5f4:	81 11       	cpse	r24, r1
 5f6:	07 c0       	rjmp	.+14     	; 0x606 <prvResetNextTaskUnblockTime+0x1c>
 5f8:	8f ef       	ldi	r24, 0xFF	; 255
 5fa:	9f ef       	ldi	r25, 0xFF	; 255
 5fc:	90 93 00 05 	sts	0x0500, r25	; 0x800500 <xNextTaskUnblockTime+0x1>
 600:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <xNextTaskUnblockTime>
 604:	08 95       	ret
 606:	e0 91 15 05 	lds	r30, 0x0515	; 0x800515 <pxDelayedTaskList>
 60a:	f0 91 16 05 	lds	r31, 0x0516	; 0x800516 <pxDelayedTaskList+0x1>
 60e:	05 80       	ldd	r0, Z+5	; 0x05
 610:	f6 81       	ldd	r31, Z+6	; 0x06
 612:	e0 2d       	mov	r30, r0
 614:	06 80       	ldd	r0, Z+6	; 0x06
 616:	f7 81       	ldd	r31, Z+7	; 0x07
 618:	e0 2d       	mov	r30, r0
 61a:	82 81       	ldd	r24, Z+2	; 0x02
 61c:	93 81       	ldd	r25, Z+3	; 0x03
 61e:	90 93 00 05 	sts	0x0500, r25	; 0x800500 <xNextTaskUnblockTime+0x1>
 622:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <xNextTaskUnblockTime>
 626:	08 95       	ret

00000628 <prvIdleTask>:
 628:	c9 e2       	ldi	r28, 0x29	; 41
 62a:	d5 e0       	ldi	r29, 0x05	; 5
 62c:	88 81       	ld	r24, Y
 62e:	82 30       	cpi	r24, 0x02	; 2
 630:	f0 f3       	brcs	.-4      	; 0x62e <prvIdleTask+0x6>
 632:	0e 94 3d 02 	call	0x47a	; 0x47a <vPortYield>
 636:	fa cf       	rjmp	.-12     	; 0x62c <prvIdleTask+0x4>

00000638 <prvAddCurrentTaskToDelayedList>:
 638:	0f 93       	push	r16
 63a:	1f 93       	push	r17
 63c:	cf 93       	push	r28
 63e:	df 93       	push	r29
 640:	ec 01       	movw	r28, r24
 642:	00 91 07 05 	lds	r16, 0x0507	; 0x800507 <xTickCount>
 646:	10 91 08 05 	lds	r17, 0x0508	; 0x800508 <xTickCount+0x1>
 64a:	80 91 4d 05 	lds	r24, 0x054D	; 0x80054d <pxCurrentTCB>
 64e:	90 91 4e 05 	lds	r25, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 652:	02 96       	adiw	r24, 0x02	; 2
 654:	0e 94 f6 00 	call	0x1ec	; 0x1ec <uxListRemove>
 658:	c0 0f       	add	r28, r16
 65a:	d1 1f       	adc	r29, r17
 65c:	e0 91 4d 05 	lds	r30, 0x054D	; 0x80054d <pxCurrentTCB>
 660:	f0 91 4e 05 	lds	r31, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 664:	d3 83       	std	Z+3, r29	; 0x03
 666:	c2 83       	std	Z+2, r28	; 0x02
 668:	c0 17       	cp	r28, r16
 66a:	d1 07       	cpc	r29, r17
 66c:	68 f4       	brcc	.+26     	; 0x688 <prvAddCurrentTaskToDelayedList+0x50>
 66e:	60 91 4d 05 	lds	r22, 0x054D	; 0x80054d <pxCurrentTCB>
 672:	70 91 4e 05 	lds	r23, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 676:	80 91 13 05 	lds	r24, 0x0513	; 0x800513 <pxOverflowDelayedTaskList>
 67a:	90 91 14 05 	lds	r25, 0x0514	; 0x800514 <pxOverflowDelayedTaskList+0x1>
 67e:	6e 5f       	subi	r22, 0xFE	; 254
 680:	7f 4f       	sbci	r23, 0xFF	; 255
 682:	0e 94 c5 00 	call	0x18a	; 0x18a <vListInsert>
 686:	17 c0       	rjmp	.+46     	; 0x6b6 <prvAddCurrentTaskToDelayedList+0x7e>
 688:	60 91 4d 05 	lds	r22, 0x054D	; 0x80054d <pxCurrentTCB>
 68c:	70 91 4e 05 	lds	r23, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 690:	80 91 15 05 	lds	r24, 0x0515	; 0x800515 <pxDelayedTaskList>
 694:	90 91 16 05 	lds	r25, 0x0516	; 0x800516 <pxDelayedTaskList+0x1>
 698:	6e 5f       	subi	r22, 0xFE	; 254
 69a:	7f 4f       	sbci	r23, 0xFF	; 255
 69c:	0e 94 c5 00 	call	0x18a	; 0x18a <vListInsert>
 6a0:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <xNextTaskUnblockTime>
 6a4:	90 91 00 05 	lds	r25, 0x0500	; 0x800500 <xNextTaskUnblockTime+0x1>
 6a8:	c8 17       	cp	r28, r24
 6aa:	d9 07       	cpc	r29, r25
 6ac:	20 f4       	brcc	.+8      	; 0x6b6 <prvAddCurrentTaskToDelayedList+0x7e>
 6ae:	d0 93 00 05 	sts	0x0500, r29	; 0x800500 <xNextTaskUnblockTime+0x1>
 6b2:	c0 93 ff 04 	sts	0x04FF, r28	; 0x8004ff <xNextTaskUnblockTime>
 6b6:	df 91       	pop	r29
 6b8:	cf 91       	pop	r28
 6ba:	1f 91       	pop	r17
 6bc:	0f 91       	pop	r16
 6be:	08 95       	ret

000006c0 <xTaskCreate>:
 6c0:	4f 92       	push	r4
 6c2:	5f 92       	push	r5
 6c4:	6f 92       	push	r6
 6c6:	7f 92       	push	r7
 6c8:	8f 92       	push	r8
 6ca:	9f 92       	push	r9
 6cc:	af 92       	push	r10
 6ce:	bf 92       	push	r11
 6d0:	cf 92       	push	r12
 6d2:	df 92       	push	r13
 6d4:	ef 92       	push	r14
 6d6:	ff 92       	push	r15
 6d8:	0f 93       	push	r16
 6da:	cf 93       	push	r28
 6dc:	df 93       	push	r29
 6de:	4c 01       	movw	r8, r24
 6e0:	6b 01       	movw	r12, r22
 6e2:	5a 01       	movw	r10, r20
 6e4:	29 01       	movw	r4, r18
 6e6:	ca 01       	movw	r24, r20
 6e8:	0e 94 53 00 	call	0xa6	; 0xa6 <pvPortMalloc>
 6ec:	3c 01       	movw	r6, r24
 6ee:	89 2b       	or	r24, r25
 6f0:	09 f4       	brne	.+2      	; 0x6f4 <xTaskCreate+0x34>
 6f2:	d9 c0       	rjmp	.+434    	; 0x8a6 <xTaskCreate+0x1e6>
 6f4:	86 e2       	ldi	r24, 0x26	; 38
 6f6:	90 e0       	ldi	r25, 0x00	; 0
 6f8:	0e 94 53 00 	call	0xa6	; 0xa6 <pvPortMalloc>
 6fc:	ec 01       	movw	r28, r24
 6fe:	89 2b       	or	r24, r25
 700:	71 f0       	breq	.+28     	; 0x71e <xTaskCreate+0x5e>
 702:	78 8e       	std	Y+24, r7	; 0x18
 704:	6f 8a       	std	Y+23, r6	; 0x17
 706:	81 e0       	ldi	r24, 0x01	; 1
 708:	a8 1a       	sub	r10, r24
 70a:	b1 08       	sbc	r11, r1
 70c:	6a 0c       	add	r6, r10
 70e:	7b 1c       	adc	r7, r11
 710:	d6 01       	movw	r26, r12
 712:	8c 91       	ld	r24, X
 714:	89 8f       	std	Y+25, r24	; 0x19
 716:	8c 91       	ld	r24, X
 718:	81 11       	cpse	r24, r1
 71a:	05 c0       	rjmp	.+10     	; 0x726 <xTaskCreate+0x66>
 71c:	18 c0       	rjmp	.+48     	; 0x74e <xTaskCreate+0x8e>
 71e:	c3 01       	movw	r24, r6
 720:	0e 94 88 00 	call	0x110	; 0x110 <vPortFree>
 724:	c0 c0       	rjmp	.+384    	; 0x8a6 <xTaskCreate+0x1e6>
 726:	ae 01       	movw	r20, r28
 728:	46 5e       	subi	r20, 0xE6	; 230
 72a:	5f 4f       	sbci	r21, 0xFF	; 255
 72c:	f6 01       	movw	r30, r12
 72e:	31 96       	adiw	r30, 0x01	; 1
 730:	b8 e0       	ldi	r27, 0x08	; 8
 732:	cb 0e       	add	r12, r27
 734:	d1 1c       	adc	r13, r1
 736:	cf 01       	movw	r24, r30
 738:	21 91       	ld	r18, Z+
 73a:	da 01       	movw	r26, r20
 73c:	2d 93       	st	X+, r18
 73e:	ad 01       	movw	r20, r26
 740:	dc 01       	movw	r26, r24
 742:	8c 91       	ld	r24, X
 744:	88 23       	and	r24, r24
 746:	19 f0       	breq	.+6      	; 0x74e <xTaskCreate+0x8e>
 748:	ec 15       	cp	r30, r12
 74a:	fd 05       	cpc	r31, r13
 74c:	a1 f7       	brne	.-24     	; 0x736 <xTaskCreate+0x76>
 74e:	18 a2       	std	Y+32, r1	; 0x20
 750:	04 30       	cpi	r16, 0x04	; 4
 752:	08 f0       	brcs	.+2      	; 0x756 <xTaskCreate+0x96>
 754:	03 e0       	ldi	r16, 0x03	; 3
 756:	0e 8b       	std	Y+22, r16	; 0x16
 758:	6e 01       	movw	r12, r28
 75a:	b2 e0       	ldi	r27, 0x02	; 2
 75c:	cb 0e       	add	r12, r27
 75e:	d1 1c       	adc	r13, r1
 760:	c6 01       	movw	r24, r12
 762:	0e 94 a0 00 	call	0x140	; 0x140 <vListInitialiseItem>
 766:	ce 01       	movw	r24, r28
 768:	0c 96       	adiw	r24, 0x0c	; 12
 76a:	0e 94 a0 00 	call	0x140	; 0x140 <vListInitialiseItem>
 76e:	d9 87       	std	Y+9, r29	; 0x09
 770:	c8 87       	std	Y+8, r28	; 0x08
 772:	84 e0       	ldi	r24, 0x04	; 4
 774:	90 e0       	ldi	r25, 0x00	; 0
 776:	80 1b       	sub	r24, r16
 778:	91 09       	sbc	r25, r1
 77a:	9d 87       	std	Y+13, r25	; 0x0d
 77c:	8c 87       	std	Y+12, r24	; 0x0c
 77e:	db 8b       	std	Y+19, r29	; 0x13
 780:	ca 8b       	std	Y+18, r28	; 0x12
 782:	19 a2       	std	Y+33, r1	; 0x21
 784:	1a a2       	std	Y+34, r1	; 0x22
 786:	1b a2       	std	Y+35, r1	; 0x23
 788:	1c a2       	std	Y+36, r1	; 0x24
 78a:	1d a2       	std	Y+37, r1	; 0x25
 78c:	a2 01       	movw	r20, r4
 78e:	b4 01       	movw	r22, r8
 790:	c3 01       	movw	r24, r6
 792:	0e 94 96 01 	call	0x32c	; 0x32c <pxPortInitialiseStack>
 796:	99 83       	std	Y+1, r25	; 0x01
 798:	88 83       	st	Y, r24
 79a:	e1 14       	cp	r14, r1
 79c:	f1 04       	cpc	r15, r1
 79e:	19 f0       	breq	.+6      	; 0x7a6 <xTaskCreate+0xe6>
 7a0:	f7 01       	movw	r30, r14
 7a2:	d1 83       	std	Z+1, r29	; 0x01
 7a4:	c0 83       	st	Z, r28
 7a6:	0f b6       	in	r0, 0x3f	; 63
 7a8:	f8 94       	cli
 7aa:	0f 92       	push	r0
 7ac:	80 91 09 05 	lds	r24, 0x0509	; 0x800509 <uxCurrentNumberOfTasks>
 7b0:	8f 5f       	subi	r24, 0xFF	; 255
 7b2:	80 93 09 05 	sts	0x0509, r24	; 0x800509 <uxCurrentNumberOfTasks>
 7b6:	80 91 4d 05 	lds	r24, 0x054D	; 0x80054d <pxCurrentTCB>
 7ba:	90 91 4e 05 	lds	r25, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 7be:	89 2b       	or	r24, r25
 7c0:	89 f5       	brne	.+98     	; 0x824 <xTaskCreate+0x164>
 7c2:	d0 93 4e 05 	sts	0x054E, r29	; 0x80054e <pxCurrentTCB+0x1>
 7c6:	c0 93 4d 05 	sts	0x054D, r28	; 0x80054d <pxCurrentTCB>
 7ca:	80 91 09 05 	lds	r24, 0x0509	; 0x800509 <uxCurrentNumberOfTasks>
 7ce:	81 30       	cpi	r24, 0x01	; 1
 7d0:	c9 f5       	brne	.+114    	; 0x844 <xTaskCreate+0x184>
 7d2:	89 e2       	ldi	r24, 0x29	; 41
 7d4:	95 e0       	ldi	r25, 0x05	; 5
 7d6:	0e 94 92 00 	call	0x124	; 0x124 <vListInitialise>
 7da:	82 e3       	ldi	r24, 0x32	; 50
 7dc:	95 e0       	ldi	r25, 0x05	; 5
 7de:	0e 94 92 00 	call	0x124	; 0x124 <vListInitialise>
 7e2:	8b e3       	ldi	r24, 0x3B	; 59
 7e4:	95 e0       	ldi	r25, 0x05	; 5
 7e6:	0e 94 92 00 	call	0x124	; 0x124 <vListInitialise>
 7ea:	84 e4       	ldi	r24, 0x44	; 68
 7ec:	95 e0       	ldi	r25, 0x05	; 5
 7ee:	0e 94 92 00 	call	0x124	; 0x124 <vListInitialise>
 7f2:	80 e2       	ldi	r24, 0x20	; 32
 7f4:	95 e0       	ldi	r25, 0x05	; 5
 7f6:	0e 94 92 00 	call	0x124	; 0x124 <vListInitialise>
 7fa:	87 e1       	ldi	r24, 0x17	; 23
 7fc:	95 e0       	ldi	r25, 0x05	; 5
 7fe:	0e 94 92 00 	call	0x124	; 0x124 <vListInitialise>
 802:	8a e0       	ldi	r24, 0x0A	; 10
 804:	95 e0       	ldi	r25, 0x05	; 5
 806:	0e 94 92 00 	call	0x124	; 0x124 <vListInitialise>
 80a:	80 e2       	ldi	r24, 0x20	; 32
 80c:	95 e0       	ldi	r25, 0x05	; 5
 80e:	90 93 16 05 	sts	0x0516, r25	; 0x800516 <pxDelayedTaskList+0x1>
 812:	80 93 15 05 	sts	0x0515, r24	; 0x800515 <pxDelayedTaskList>
 816:	87 e1       	ldi	r24, 0x17	; 23
 818:	95 e0       	ldi	r25, 0x05	; 5
 81a:	90 93 14 05 	sts	0x0514, r25	; 0x800514 <pxOverflowDelayedTaskList+0x1>
 81e:	80 93 13 05 	sts	0x0513, r24	; 0x800513 <pxOverflowDelayedTaskList>
 822:	10 c0       	rjmp	.+32     	; 0x844 <xTaskCreate+0x184>
 824:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <xSchedulerRunning>
 828:	81 11       	cpse	r24, r1
 82a:	0c c0       	rjmp	.+24     	; 0x844 <xTaskCreate+0x184>
 82c:	e0 91 4d 05 	lds	r30, 0x054D	; 0x80054d <pxCurrentTCB>
 830:	f0 91 4e 05 	lds	r31, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 834:	96 89       	ldd	r25, Z+22	; 0x16
 836:	8e 89       	ldd	r24, Y+22	; 0x16
 838:	89 17       	cp	r24, r25
 83a:	20 f0       	brcs	.+8      	; 0x844 <xTaskCreate+0x184>
 83c:	d0 93 4e 05 	sts	0x054E, r29	; 0x80054e <pxCurrentTCB+0x1>
 840:	c0 93 4d 05 	sts	0x054D, r28	; 0x80054d <pxCurrentTCB>
 844:	80 91 01 05 	lds	r24, 0x0501	; 0x800501 <uxTaskNumber>
 848:	8f 5f       	subi	r24, 0xFF	; 255
 84a:	80 93 01 05 	sts	0x0501, r24	; 0x800501 <uxTaskNumber>
 84e:	8e 89       	ldd	r24, Y+22	; 0x16
 850:	90 91 06 05 	lds	r25, 0x0506	; 0x800506 <uxTopReadyPriority>
 854:	98 17       	cp	r25, r24
 856:	10 f4       	brcc	.+4      	; 0x85c <xTaskCreate+0x19c>
 858:	80 93 06 05 	sts	0x0506, r24	; 0x800506 <uxTopReadyPriority>
 85c:	90 e0       	ldi	r25, 0x00	; 0
 85e:	9c 01       	movw	r18, r24
 860:	22 0f       	add	r18, r18
 862:	33 1f       	adc	r19, r19
 864:	22 0f       	add	r18, r18
 866:	33 1f       	adc	r19, r19
 868:	22 0f       	add	r18, r18
 86a:	33 1f       	adc	r19, r19
 86c:	82 0f       	add	r24, r18
 86e:	93 1f       	adc	r25, r19
 870:	b6 01       	movw	r22, r12
 872:	87 5d       	subi	r24, 0xD7	; 215
 874:	9a 4f       	sbci	r25, 0xFA	; 250
 876:	0e 94 a4 00 	call	0x148	; 0x148 <vListInsertEnd>
 87a:	0f 90       	pop	r0
 87c:	0f be       	out	0x3f, r0	; 63
 87e:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <xSchedulerRunning>
 882:	88 23       	and	r24, r24
 884:	61 f0       	breq	.+24     	; 0x89e <xTaskCreate+0x1de>
 886:	e0 91 4d 05 	lds	r30, 0x054D	; 0x80054d <pxCurrentTCB>
 88a:	f0 91 4e 05 	lds	r31, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 88e:	96 89       	ldd	r25, Z+22	; 0x16
 890:	8e 89       	ldd	r24, Y+22	; 0x16
 892:	98 17       	cp	r25, r24
 894:	30 f4       	brcc	.+12     	; 0x8a2 <xTaskCreate+0x1e2>
 896:	0e 94 3d 02 	call	0x47a	; 0x47a <vPortYield>
 89a:	81 e0       	ldi	r24, 0x01	; 1
 89c:	05 c0       	rjmp	.+10     	; 0x8a8 <xTaskCreate+0x1e8>
 89e:	81 e0       	ldi	r24, 0x01	; 1
 8a0:	03 c0       	rjmp	.+6      	; 0x8a8 <xTaskCreate+0x1e8>
 8a2:	81 e0       	ldi	r24, 0x01	; 1
 8a4:	01 c0       	rjmp	.+2      	; 0x8a8 <xTaskCreate+0x1e8>
 8a6:	8f ef       	ldi	r24, 0xFF	; 255
 8a8:	df 91       	pop	r29
 8aa:	cf 91       	pop	r28
 8ac:	0f 91       	pop	r16
 8ae:	ff 90       	pop	r15
 8b0:	ef 90       	pop	r14
 8b2:	df 90       	pop	r13
 8b4:	cf 90       	pop	r12
 8b6:	bf 90       	pop	r11
 8b8:	af 90       	pop	r10
 8ba:	9f 90       	pop	r9
 8bc:	8f 90       	pop	r8
 8be:	7f 90       	pop	r7
 8c0:	6f 90       	pop	r6
 8c2:	5f 90       	pop	r5
 8c4:	4f 90       	pop	r4
 8c6:	08 95       	ret

000008c8 <vTaskStartScheduler>:
 8c8:	ef 92       	push	r14
 8ca:	ff 92       	push	r15
 8cc:	0f 93       	push	r16
 8ce:	0f 2e       	mov	r0, r31
 8d0:	fd ef       	ldi	r31, 0xFD	; 253
 8d2:	ef 2e       	mov	r14, r31
 8d4:	f4 e0       	ldi	r31, 0x04	; 4
 8d6:	ff 2e       	mov	r15, r31
 8d8:	f0 2d       	mov	r31, r0
 8da:	00 e0       	ldi	r16, 0x00	; 0
 8dc:	20 e0       	ldi	r18, 0x00	; 0
 8de:	30 e0       	ldi	r19, 0x00	; 0
 8e0:	40 e5       	ldi	r20, 0x50	; 80
 8e2:	50 e0       	ldi	r21, 0x00	; 0
 8e4:	6a e0       	ldi	r22, 0x0A	; 10
 8e6:	71 e0       	ldi	r23, 0x01	; 1
 8e8:	84 e1       	ldi	r24, 0x14	; 20
 8ea:	93 e0       	ldi	r25, 0x03	; 3
 8ec:	0e 94 60 03 	call	0x6c0	; 0x6c0 <xTaskCreate>
 8f0:	81 30       	cpi	r24, 0x01	; 1
 8f2:	81 f4       	brne	.+32     	; 0x914 <__stack+0x15>
 8f4:	f8 94       	cli
 8f6:	8f ef       	ldi	r24, 0xFF	; 255
 8f8:	9f ef       	ldi	r25, 0xFF	; 255
 8fa:	90 93 00 05 	sts	0x0500, r25	; 0x800500 <xNextTaskUnblockTime+0x1>
 8fe:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <xNextTaskUnblockTime>
 902:	81 e0       	ldi	r24, 0x01	; 1
 904:	80 93 05 05 	sts	0x0505, r24	; 0x800505 <xSchedulerRunning>
 908:	10 92 08 05 	sts	0x0508, r1	; 0x800508 <xTickCount+0x1>
 90c:	10 92 07 05 	sts	0x0507, r1	; 0x800507 <xTickCount>
 910:	0e 94 02 02 	call	0x404	; 0x404 <xPortStartScheduler>
 914:	0f 91       	pop	r16
 916:	ff 90       	pop	r15
 918:	ef 90       	pop	r14
 91a:	08 95       	ret

0000091c <vTaskSuspendAll>:
 91c:	80 91 fc 04 	lds	r24, 0x04FC	; 0x8004fc <uxSchedulerSuspended>
 920:	8f 5f       	subi	r24, 0xFF	; 255
 922:	80 93 fc 04 	sts	0x04FC, r24	; 0x8004fc <uxSchedulerSuspended>
 926:	08 95       	ret

00000928 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 928:	cf 92       	push	r12
 92a:	df 92       	push	r13
 92c:	ef 92       	push	r14
 92e:	ff 92       	push	r15
 930:	0f 93       	push	r16
 932:	1f 93       	push	r17
 934:	cf 93       	push	r28
 936:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 938:	80 91 fc 04 	lds	r24, 0x04FC	; 0x8004fc <uxSchedulerSuspended>
 93c:	81 11       	cpse	r24, r1
 93e:	99 c0       	rjmp	.+306    	; 0xa72 <xTaskIncrementTick+0x14a>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
 940:	e0 90 07 05 	lds	r14, 0x0507	; 0x800507 <xTickCount>
 944:	f0 90 08 05 	lds	r15, 0x0508	; 0x800508 <xTickCount+0x1>
 948:	8f ef       	ldi	r24, 0xFF	; 255
 94a:	e8 1a       	sub	r14, r24
 94c:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 94e:	f0 92 08 05 	sts	0x0508, r15	; 0x800508 <xTickCount+0x1>
 952:	e0 92 07 05 	sts	0x0507, r14	; 0x800507 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
 956:	e1 14       	cp	r14, r1
 958:	f1 04       	cpc	r15, r1
 95a:	b9 f4       	brne	.+46     	; 0x98a <xTaskIncrementTick+0x62>
		{
			taskSWITCH_DELAYED_LISTS();
 95c:	80 91 15 05 	lds	r24, 0x0515	; 0x800515 <pxDelayedTaskList>
 960:	90 91 16 05 	lds	r25, 0x0516	; 0x800516 <pxDelayedTaskList+0x1>
 964:	20 91 13 05 	lds	r18, 0x0513	; 0x800513 <pxOverflowDelayedTaskList>
 968:	30 91 14 05 	lds	r19, 0x0514	; 0x800514 <pxOverflowDelayedTaskList+0x1>
 96c:	30 93 16 05 	sts	0x0516, r19	; 0x800516 <pxDelayedTaskList+0x1>
 970:	20 93 15 05 	sts	0x0515, r18	; 0x800515 <pxDelayedTaskList>
 974:	90 93 14 05 	sts	0x0514, r25	; 0x800514 <pxOverflowDelayedTaskList+0x1>
 978:	80 93 13 05 	sts	0x0513, r24	; 0x800513 <pxOverflowDelayedTaskList>
 97c:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <xNumOfOverflows>
 980:	8f 5f       	subi	r24, 0xFF	; 255
 982:	80 93 02 05 	sts	0x0502, r24	; 0x800502 <xNumOfOverflows>
 986:	0e 94 f5 02 	call	0x5ea	; 0x5ea <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 98a:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <xNextTaskUnblockTime>
 98e:	90 91 00 05 	lds	r25, 0x0500	; 0x800500 <xNextTaskUnblockTime+0x1>
 992:	e8 16       	cp	r14, r24
 994:	f9 06       	cpc	r15, r25
 996:	10 f4       	brcc	.+4      	; 0x99c <xTaskIncrementTick+0x74>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 998:	d1 2c       	mov	r13, r1
 99a:	53 c0       	rjmp	.+166    	; 0xa42 <xTaskIncrementTick+0x11a>
 99c:	d1 2c       	mov	r13, r1
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
 99e:	cc 24       	eor	r12, r12
 9a0:	c3 94       	inc	r12
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 9a2:	e0 91 15 05 	lds	r30, 0x0515	; 0x800515 <pxDelayedTaskList>
 9a6:	f0 91 16 05 	lds	r31, 0x0516	; 0x800516 <pxDelayedTaskList+0x1>
 9aa:	90 81       	ld	r25, Z
 9ac:	91 11       	cpse	r25, r1
 9ae:	07 c0       	rjmp	.+14     	; 0x9be <xTaskIncrementTick+0x96>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 9b0:	8f ef       	ldi	r24, 0xFF	; 255
 9b2:	9f ef       	ldi	r25, 0xFF	; 255
 9b4:	90 93 00 05 	sts	0x0500, r25	; 0x800500 <xNextTaskUnblockTime+0x1>
 9b8:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <xNextTaskUnblockTime>
					break;
 9bc:	42 c0       	rjmp	.+132    	; 0xa42 <xTaskIncrementTick+0x11a>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
 9be:	e0 91 15 05 	lds	r30, 0x0515	; 0x800515 <pxDelayedTaskList>
 9c2:	f0 91 16 05 	lds	r31, 0x0516	; 0x800516 <pxDelayedTaskList+0x1>
 9c6:	05 80       	ldd	r0, Z+5	; 0x05
 9c8:	f6 81       	ldd	r31, Z+6	; 0x06
 9ca:	e0 2d       	mov	r30, r0
 9cc:	c6 81       	ldd	r28, Z+6	; 0x06
 9ce:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 9d0:	2a 81       	ldd	r18, Y+2	; 0x02
 9d2:	3b 81       	ldd	r19, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
 9d4:	e2 16       	cp	r14, r18
 9d6:	f3 06       	cpc	r15, r19
 9d8:	28 f4       	brcc	.+10     	; 0x9e4 <xTaskIncrementTick+0xbc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
 9da:	30 93 00 05 	sts	0x0500, r19	; 0x800500 <xNextTaskUnblockTime+0x1>
 9de:	20 93 ff 04 	sts	0x04FF, r18	; 0x8004ff <xNextTaskUnblockTime>
						break;
 9e2:	2f c0       	rjmp	.+94     	; 0xa42 <xTaskIncrementTick+0x11a>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 9e4:	8e 01       	movw	r16, r28
 9e6:	0e 5f       	subi	r16, 0xFE	; 254
 9e8:	1f 4f       	sbci	r17, 0xFF	; 255
 9ea:	c8 01       	movw	r24, r16
 9ec:	0e 94 f6 00 	call	0x1ec	; 0x1ec <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 9f0:	8c 89       	ldd	r24, Y+20	; 0x14
 9f2:	9d 89       	ldd	r25, Y+21	; 0x15
 9f4:	89 2b       	or	r24, r25
 9f6:	21 f0       	breq	.+8      	; 0xa00 <xTaskIncrementTick+0xd8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 9f8:	ce 01       	movw	r24, r28
 9fa:	0c 96       	adiw	r24, 0x0c	; 12
 9fc:	0e 94 f6 00 	call	0x1ec	; 0x1ec <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 a00:	2e 89       	ldd	r18, Y+22	; 0x16
 a02:	80 91 06 05 	lds	r24, 0x0506	; 0x800506 <uxTopReadyPriority>
 a06:	82 17       	cp	r24, r18
 a08:	10 f4       	brcc	.+4      	; 0xa0e <xTaskIncrementTick+0xe6>
 a0a:	20 93 06 05 	sts	0x0506, r18	; 0x800506 <uxTopReadyPriority>
 a0e:	30 e0       	ldi	r19, 0x00	; 0
 a10:	c9 01       	movw	r24, r18
 a12:	88 0f       	add	r24, r24
 a14:	99 1f       	adc	r25, r25
 a16:	88 0f       	add	r24, r24
 a18:	99 1f       	adc	r25, r25
 a1a:	88 0f       	add	r24, r24
 a1c:	99 1f       	adc	r25, r25
 a1e:	82 0f       	add	r24, r18
 a20:	93 1f       	adc	r25, r19
 a22:	b8 01       	movw	r22, r16
 a24:	87 5d       	subi	r24, 0xD7	; 215
 a26:	9a 4f       	sbci	r25, 0xFA	; 250
 a28:	0e 94 a4 00 	call	0x148	; 0x148 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 a2c:	e0 91 4d 05 	lds	r30, 0x054D	; 0x80054d <pxCurrentTCB>
 a30:	f0 91 4e 05 	lds	r31, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 a34:	9e 89       	ldd	r25, Y+22	; 0x16
 a36:	86 89       	ldd	r24, Z+22	; 0x16
 a38:	98 17       	cp	r25, r24
 a3a:	08 f4       	brcc	.+2      	; 0xa3e <xTaskIncrementTick+0x116>
 a3c:	b2 cf       	rjmp	.-156    	; 0x9a2 <xTaskIncrementTick+0x7a>
						{
							xSwitchRequired = pdTRUE;
 a3e:	dc 2c       	mov	r13, r12
 a40:	b0 cf       	rjmp	.-160    	; 0x9a2 <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 a42:	e0 91 4d 05 	lds	r30, 0x054D	; 0x80054d <pxCurrentTCB>
 a46:	f0 91 4e 05 	lds	r31, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 a4a:	86 89       	ldd	r24, Z+22	; 0x16
 a4c:	90 e0       	ldi	r25, 0x00	; 0
 a4e:	fc 01       	movw	r30, r24
 a50:	ee 0f       	add	r30, r30
 a52:	ff 1f       	adc	r31, r31
 a54:	ee 0f       	add	r30, r30
 a56:	ff 1f       	adc	r31, r31
 a58:	ee 0f       	add	r30, r30
 a5a:	ff 1f       	adc	r31, r31
 a5c:	8e 0f       	add	r24, r30
 a5e:	9f 1f       	adc	r25, r31
 a60:	fc 01       	movw	r30, r24
 a62:	e7 5d       	subi	r30, 0xD7	; 215
 a64:	fa 4f       	sbci	r31, 0xFA	; 250
 a66:	80 81       	ld	r24, Z
 a68:	82 30       	cpi	r24, 0x02	; 2
 a6a:	48 f0       	brcs	.+18     	; 0xa7e <xTaskIncrementTick+0x156>
			{
				xSwitchRequired = pdTRUE;
 a6c:	dd 24       	eor	r13, r13
 a6e:	d3 94       	inc	r13
 a70:	06 c0       	rjmp	.+12     	; 0xa7e <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 a72:	80 91 04 05 	lds	r24, 0x0504	; 0x800504 <uxPendedTicks>
 a76:	8f 5f       	subi	r24, 0xFF	; 255
 a78:	80 93 04 05 	sts	0x0504, r24	; 0x800504 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
 a7c:	d1 2c       	mov	r13, r1
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 a7e:	80 91 03 05 	lds	r24, 0x0503	; 0x800503 <xYieldPending>
 a82:	88 23       	and	r24, r24
 a84:	11 f0       	breq	.+4      	; 0xa8a <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
 a86:	dd 24       	eor	r13, r13
 a88:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 a8a:	8d 2d       	mov	r24, r13
 a8c:	df 91       	pop	r29
 a8e:	cf 91       	pop	r28
 a90:	1f 91       	pop	r17
 a92:	0f 91       	pop	r16
 a94:	ff 90       	pop	r15
 a96:	ef 90       	pop	r14
 a98:	df 90       	pop	r13
 a9a:	cf 90       	pop	r12
 a9c:	08 95       	ret

00000a9e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
 a9e:	df 92       	push	r13
 aa0:	ef 92       	push	r14
 aa2:	ff 92       	push	r15
 aa4:	0f 93       	push	r16
 aa6:	1f 93       	push	r17
 aa8:	cf 93       	push	r28
 aaa:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
 aac:	0f b6       	in	r0, 0x3f	; 63
 aae:	f8 94       	cli
 ab0:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
 ab2:	80 91 fc 04 	lds	r24, 0x04FC	; 0x8004fc <uxSchedulerSuspended>
 ab6:	81 50       	subi	r24, 0x01	; 1
 ab8:	80 93 fc 04 	sts	0x04FC, r24	; 0x8004fc <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 abc:	80 91 fc 04 	lds	r24, 0x04FC	; 0x8004fc <uxSchedulerSuspended>
 ac0:	81 11       	cpse	r24, r1
 ac2:	5f c0       	rjmp	.+190    	; 0xb82 <xTaskResumeAll+0xe4>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
 ac4:	80 91 09 05 	lds	r24, 0x0509	; 0x800509 <uxCurrentNumberOfTasks>
 ac8:	81 11       	cpse	r24, r1
 aca:	33 c0       	rjmp	.+102    	; 0xb32 <xTaskResumeAll+0x94>
 acc:	5d c0       	rjmp	.+186    	; 0xb88 <xTaskResumeAll+0xea>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
 ace:	d7 01       	movw	r26, r14
 ad0:	15 96       	adiw	r26, 0x05	; 5
 ad2:	ed 91       	ld	r30, X+
 ad4:	fc 91       	ld	r31, X
 ad6:	16 97       	sbiw	r26, 0x06	; 6
 ad8:	c6 81       	ldd	r28, Z+6	; 0x06
 ada:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 adc:	ce 01       	movw	r24, r28
 ade:	0c 96       	adiw	r24, 0x0c	; 12
 ae0:	0e 94 f6 00 	call	0x1ec	; 0x1ec <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 ae4:	8e 01       	movw	r16, r28
 ae6:	0e 5f       	subi	r16, 0xFE	; 254
 ae8:	1f 4f       	sbci	r17, 0xFF	; 255
 aea:	c8 01       	movw	r24, r16
 aec:	0e 94 f6 00 	call	0x1ec	; 0x1ec <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 af0:	2e 89       	ldd	r18, Y+22	; 0x16
 af2:	80 91 06 05 	lds	r24, 0x0506	; 0x800506 <uxTopReadyPriority>
 af6:	82 17       	cp	r24, r18
 af8:	10 f4       	brcc	.+4      	; 0xafe <xTaskResumeAll+0x60>
 afa:	20 93 06 05 	sts	0x0506, r18	; 0x800506 <uxTopReadyPriority>
 afe:	30 e0       	ldi	r19, 0x00	; 0
 b00:	c9 01       	movw	r24, r18
 b02:	88 0f       	add	r24, r24
 b04:	99 1f       	adc	r25, r25
 b06:	88 0f       	add	r24, r24
 b08:	99 1f       	adc	r25, r25
 b0a:	88 0f       	add	r24, r24
 b0c:	99 1f       	adc	r25, r25
 b0e:	82 0f       	add	r24, r18
 b10:	93 1f       	adc	r25, r19
 b12:	b8 01       	movw	r22, r16
 b14:	87 5d       	subi	r24, 0xD7	; 215
 b16:	9a 4f       	sbci	r25, 0xFA	; 250
 b18:	0e 94 a4 00 	call	0x148	; 0x148 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 b1c:	e0 91 4d 05 	lds	r30, 0x054D	; 0x80054d <pxCurrentTCB>
 b20:	f0 91 4e 05 	lds	r31, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 b24:	9e 89       	ldd	r25, Y+22	; 0x16
 b26:	86 89       	ldd	r24, Z+22	; 0x16
 b28:	98 17       	cp	r25, r24
 b2a:	68 f0       	brcs	.+26     	; 0xb46 <xTaskResumeAll+0xa8>
					{
						xYieldPending = pdTRUE;
 b2c:	d0 92 03 05 	sts	0x0503, r13	; 0x800503 <xYieldPending>
 b30:	0a c0       	rjmp	.+20     	; 0xb46 <xTaskResumeAll+0xa8>
 b32:	c0 e0       	ldi	r28, 0x00	; 0
 b34:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 b36:	0f 2e       	mov	r0, r31
 b38:	fa e0       	ldi	r31, 0x0A	; 10
 b3a:	ef 2e       	mov	r14, r31
 b3c:	f5 e0       	ldi	r31, 0x05	; 5
 b3e:	ff 2e       	mov	r15, r31
 b40:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
 b42:	dd 24       	eor	r13, r13
 b44:	d3 94       	inc	r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
 b46:	f7 01       	movw	r30, r14
 b48:	80 81       	ld	r24, Z
 b4a:	81 11       	cpse	r24, r1
 b4c:	c0 cf       	rjmp	.-128    	; 0xace <xTaskResumeAll+0x30>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
 b4e:	cd 2b       	or	r28, r29
 b50:	11 f0       	breq	.+4      	; 0xb56 <xTaskResumeAll+0xb8>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
 b52:	0e 94 f5 02 	call	0x5ea	; 0x5ea <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
 b56:	c0 91 04 05 	lds	r28, 0x0504	; 0x800504 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
 b5a:	cc 23       	and	r28, r28
 b5c:	51 f0       	breq	.+20     	; 0xb72 <xTaskResumeAll+0xd4>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
							{
								xYieldPending = pdTRUE;
 b5e:	d1 e0       	ldi	r29, 0x01	; 1

					if( uxPendedCounts > ( UBaseType_t ) 0U )
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
 b60:	0e 94 94 04 	call	0x928	; 0x928 <xTaskIncrementTick>
 b64:	81 11       	cpse	r24, r1
							{
								xYieldPending = pdTRUE;
 b66:	d0 93 03 05 	sts	0x0503, r29	; 0x800503 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
 b6a:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
 b6c:	c9 f7       	brne	.-14     	; 0xb60 <xTaskResumeAll+0xc2>

						uxPendedTicks = 0;
 b6e:	10 92 04 05 	sts	0x0504, r1	; 0x800504 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
 b72:	80 91 03 05 	lds	r24, 0x0503	; 0x800503 <xYieldPending>
 b76:	88 23       	and	r24, r24
 b78:	31 f0       	breq	.+12     	; 0xb86 <xTaskResumeAll+0xe8>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
 b7a:	0e 94 3d 02 	call	0x47a	; 0x47a <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
 b7e:	81 e0       	ldi	r24, 0x01	; 1
 b80:	03 c0       	rjmp	.+6      	; 0xb88 <xTaskResumeAll+0xea>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
 b82:	80 e0       	ldi	r24, 0x00	; 0
 b84:	01 c0       	rjmp	.+2      	; 0xb88 <xTaskResumeAll+0xea>
 b86:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
 b88:	0f 90       	pop	r0
 b8a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
 b8c:	df 91       	pop	r29
 b8e:	cf 91       	pop	r28
 b90:	1f 91       	pop	r17
 b92:	0f 91       	pop	r16
 b94:	ff 90       	pop	r15
 b96:	ef 90       	pop	r14
 b98:	df 90       	pop	r13
 b9a:	08 95       	ret

00000b9c <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
 b9c:	cf 93       	push	r28
 b9e:	df 93       	push	r29
 ba0:	ec 01       	movw	r28, r24
	BaseType_t xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
 ba2:	89 2b       	or	r24, r25
 ba4:	51 f0       	breq	.+20     	; 0xbba <vTaskDelay+0x1e>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
 ba6:	0e 94 8e 04 	call	0x91c	; 0x91c <vTaskSuspendAll>
				list or removed from the blocked list until the scheduler
				is resumed.

				This task cannot be in an event list as it is the currently
				executing task. */
				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
 baa:	60 e0       	ldi	r22, 0x00	; 0
 bac:	ce 01       	movw	r24, r28
 bae:	0e 94 1c 03 	call	0x638	; 0x638 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
 bb2:	0e 94 4f 05 	call	0xa9e	; 0xa9e <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
 bb6:	81 11       	cpse	r24, r1
 bb8:	02 c0       	rjmp	.+4      	; 0xbbe <vTaskDelay+0x22>
		{
			portYIELD_WITHIN_API();
 bba:	0e 94 3d 02 	call	0x47a	; 0x47a <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
 bbe:	df 91       	pop	r29
 bc0:	cf 91       	pop	r28
 bc2:	08 95       	ret

00000bc4 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 bc4:	80 91 fc 04 	lds	r24, 0x04FC	; 0x8004fc <uxSchedulerSuspended>
 bc8:	88 23       	and	r24, r24
 bca:	21 f0       	breq	.+8      	; 0xbd4 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 bcc:	81 e0       	ldi	r24, 0x01	; 1
 bce:	80 93 03 05 	sts	0x0503, r24	; 0x800503 <xYieldPending>
 bd2:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 bd4:	10 92 03 05 	sts	0x0503, r1	; 0x800503 <xYieldPending>
				ulTaskSwitchedInTime = ulTotalRunTime;
		}
		#endif /* configGENERATE_RUN_TIME_STATS */

		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();
 bd8:	a0 91 4d 05 	lds	r26, 0x054D	; 0x80054d <pxCurrentTCB>
 bdc:	b0 91 4e 05 	lds	r27, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 be0:	e0 91 4d 05 	lds	r30, 0x054D	; 0x80054d <pxCurrentTCB>
 be4:	f0 91 4e 05 	lds	r31, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 be8:	2d 91       	ld	r18, X+
 bea:	3c 91       	ld	r19, X
 bec:	87 89       	ldd	r24, Z+23	; 0x17
 bee:	90 8d       	ldd	r25, Z+24	; 0x18
 bf0:	82 17       	cp	r24, r18
 bf2:	93 07       	cpc	r25, r19
 bf4:	60 f0       	brcs	.+24     	; 0xc0e <vTaskSwitchContext+0x4a>
 bf6:	60 91 4d 05 	lds	r22, 0x054D	; 0x80054d <pxCurrentTCB>
 bfa:	70 91 4e 05 	lds	r23, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 bfe:	80 91 4d 05 	lds	r24, 0x054D	; 0x80054d <pxCurrentTCB>
 c02:	90 91 4e 05 	lds	r25, 0x054E	; 0x80054e <pxCurrentTCB+0x1>
 c06:	67 5e       	subi	r22, 0xE7	; 231
 c08:	7f 4f       	sbci	r23, 0xFF	; 255
 c0a:	0e 94 88 01 	call	0x310	; 0x310 <vApplicationStackOverflowHook>

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 c0e:	20 91 06 05 	lds	r18, 0x0506	; 0x800506 <uxTopReadyPriority>
 c12:	82 2f       	mov	r24, r18
 c14:	90 e0       	ldi	r25, 0x00	; 0
 c16:	fc 01       	movw	r30, r24
 c18:	ee 0f       	add	r30, r30
 c1a:	ff 1f       	adc	r31, r31
 c1c:	ee 0f       	add	r30, r30
 c1e:	ff 1f       	adc	r31, r31
 c20:	ee 0f       	add	r30, r30
 c22:	ff 1f       	adc	r31, r31
 c24:	e8 0f       	add	r30, r24
 c26:	f9 1f       	adc	r31, r25
 c28:	e7 5d       	subi	r30, 0xD7	; 215
 c2a:	fa 4f       	sbci	r31, 0xFA	; 250
 c2c:	30 81       	ld	r19, Z
 c2e:	31 11       	cpse	r19, r1
 c30:	11 c0       	rjmp	.+34     	; 0xc54 <vTaskSwitchContext+0x90>
 c32:	21 50       	subi	r18, 0x01	; 1
 c34:	82 2f       	mov	r24, r18
 c36:	90 e0       	ldi	r25, 0x00	; 0
 c38:	fc 01       	movw	r30, r24
 c3a:	ee 0f       	add	r30, r30
 c3c:	ff 1f       	adc	r31, r31
 c3e:	ee 0f       	add	r30, r30
 c40:	ff 1f       	adc	r31, r31
 c42:	ee 0f       	add	r30, r30
 c44:	ff 1f       	adc	r31, r31
 c46:	e8 0f       	add	r30, r24
 c48:	f9 1f       	adc	r31, r25
 c4a:	e7 5d       	subi	r30, 0xD7	; 215
 c4c:	fa 4f       	sbci	r31, 0xFA	; 250
 c4e:	30 81       	ld	r19, Z
 c50:	33 23       	and	r19, r19
 c52:	79 f3       	breq	.-34     	; 0xc32 <vTaskSwitchContext+0x6e>
 c54:	ac 01       	movw	r20, r24
 c56:	44 0f       	add	r20, r20
 c58:	55 1f       	adc	r21, r21
 c5a:	44 0f       	add	r20, r20
 c5c:	55 1f       	adc	r21, r21
 c5e:	44 0f       	add	r20, r20
 c60:	55 1f       	adc	r21, r21
 c62:	48 0f       	add	r20, r24
 c64:	59 1f       	adc	r21, r25
 c66:	da 01       	movw	r26, r20
 c68:	a7 5d       	subi	r26, 0xD7	; 215
 c6a:	ba 4f       	sbci	r27, 0xFA	; 250
 c6c:	11 96       	adiw	r26, 0x01	; 1
 c6e:	ed 91       	ld	r30, X+
 c70:	fc 91       	ld	r31, X
 c72:	12 97       	sbiw	r26, 0x02	; 2
 c74:	02 80       	ldd	r0, Z+2	; 0x02
 c76:	f3 81       	ldd	r31, Z+3	; 0x03
 c78:	e0 2d       	mov	r30, r0
 c7a:	12 96       	adiw	r26, 0x02	; 2
 c7c:	fc 93       	st	X, r31
 c7e:	ee 93       	st	-X, r30
 c80:	11 97       	sbiw	r26, 0x01	; 1
 c82:	44 5d       	subi	r20, 0xD4	; 212
 c84:	5a 4f       	sbci	r21, 0xFA	; 250
 c86:	e4 17       	cp	r30, r20
 c88:	f5 07       	cpc	r31, r21
 c8a:	29 f4       	brne	.+10     	; 0xc96 <vTaskSwitchContext+0xd2>
 c8c:	42 81       	ldd	r20, Z+2	; 0x02
 c8e:	53 81       	ldd	r21, Z+3	; 0x03
 c90:	fd 01       	movw	r30, r26
 c92:	52 83       	std	Z+2, r21	; 0x02
 c94:	41 83       	std	Z+1, r20	; 0x01
 c96:	fc 01       	movw	r30, r24
 c98:	ee 0f       	add	r30, r30
 c9a:	ff 1f       	adc	r31, r31
 c9c:	ee 0f       	add	r30, r30
 c9e:	ff 1f       	adc	r31, r31
 ca0:	ee 0f       	add	r30, r30
 ca2:	ff 1f       	adc	r31, r31
 ca4:	8e 0f       	add	r24, r30
 ca6:	9f 1f       	adc	r25, r31
 ca8:	fc 01       	movw	r30, r24
 caa:	e7 5d       	subi	r30, 0xD7	; 215
 cac:	fa 4f       	sbci	r31, 0xFA	; 250
 cae:	01 80       	ldd	r0, Z+1	; 0x01
 cb0:	f2 81       	ldd	r31, Z+2	; 0x02
 cb2:	e0 2d       	mov	r30, r0
 cb4:	86 81       	ldd	r24, Z+6	; 0x06
 cb6:	97 81       	ldd	r25, Z+7	; 0x07
 cb8:	90 93 4e 05 	sts	0x054E, r25	; 0x80054e <pxCurrentTCB+0x1>
 cbc:	80 93 4d 05 	sts	0x054D, r24	; 0x80054d <pxCurrentTCB>
 cc0:	20 93 06 05 	sts	0x0506, r18	; 0x800506 <uxTopReadyPriority>
 cc4:	08 95       	ret

00000cc6 <do_rand>:
 cc6:	8f 92       	push	r8
 cc8:	9f 92       	push	r9
 cca:	af 92       	push	r10
 ccc:	bf 92       	push	r11
 cce:	cf 92       	push	r12
 cd0:	df 92       	push	r13
 cd2:	ef 92       	push	r14
 cd4:	ff 92       	push	r15
 cd6:	cf 93       	push	r28
 cd8:	df 93       	push	r29
 cda:	ec 01       	movw	r28, r24
 cdc:	68 81       	ld	r22, Y
 cde:	79 81       	ldd	r23, Y+1	; 0x01
 ce0:	8a 81       	ldd	r24, Y+2	; 0x02
 ce2:	9b 81       	ldd	r25, Y+3	; 0x03
 ce4:	61 15       	cp	r22, r1
 ce6:	71 05       	cpc	r23, r1
 ce8:	81 05       	cpc	r24, r1
 cea:	91 05       	cpc	r25, r1
 cec:	21 f4       	brne	.+8      	; 0xcf6 <do_rand+0x30>
 cee:	64 e2       	ldi	r22, 0x24	; 36
 cf0:	79 ed       	ldi	r23, 0xD9	; 217
 cf2:	8b e5       	ldi	r24, 0x5B	; 91
 cf4:	97 e0       	ldi	r25, 0x07	; 7
 cf6:	2d e1       	ldi	r18, 0x1D	; 29
 cf8:	33 ef       	ldi	r19, 0xF3	; 243
 cfa:	41 e0       	ldi	r20, 0x01	; 1
 cfc:	50 e0       	ldi	r21, 0x00	; 0
 cfe:	0e 94 bf 06 	call	0xd7e	; 0xd7e <__divmodsi4>
 d02:	49 01       	movw	r8, r18
 d04:	5a 01       	movw	r10, r20
 d06:	9b 01       	movw	r18, r22
 d08:	ac 01       	movw	r20, r24
 d0a:	a7 ea       	ldi	r26, 0xA7	; 167
 d0c:	b1 e4       	ldi	r27, 0x41	; 65
 d0e:	0e 94 de 06 	call	0xdbc	; 0xdbc <__muluhisi3>
 d12:	6b 01       	movw	r12, r22
 d14:	7c 01       	movw	r14, r24
 d16:	ac ee       	ldi	r26, 0xEC	; 236
 d18:	b4 ef       	ldi	r27, 0xF4	; 244
 d1a:	a5 01       	movw	r20, r10
 d1c:	94 01       	movw	r18, r8
 d1e:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <__mulohisi3>
 d22:	dc 01       	movw	r26, r24
 d24:	cb 01       	movw	r24, r22
 d26:	8c 0d       	add	r24, r12
 d28:	9d 1d       	adc	r25, r13
 d2a:	ae 1d       	adc	r26, r14
 d2c:	bf 1d       	adc	r27, r15
 d2e:	b7 ff       	sbrs	r27, 7
 d30:	03 c0       	rjmp	.+6      	; 0xd38 <do_rand+0x72>
 d32:	01 97       	sbiw	r24, 0x01	; 1
 d34:	a1 09       	sbc	r26, r1
 d36:	b0 48       	sbci	r27, 0x80	; 128
 d38:	88 83       	st	Y, r24
 d3a:	99 83       	std	Y+1, r25	; 0x01
 d3c:	aa 83       	std	Y+2, r26	; 0x02
 d3e:	bb 83       	std	Y+3, r27	; 0x03
 d40:	9f 77       	andi	r25, 0x7F	; 127
 d42:	df 91       	pop	r29
 d44:	cf 91       	pop	r28
 d46:	ff 90       	pop	r15
 d48:	ef 90       	pop	r14
 d4a:	df 90       	pop	r13
 d4c:	cf 90       	pop	r12
 d4e:	bf 90       	pop	r11
 d50:	af 90       	pop	r10
 d52:	9f 90       	pop	r9
 d54:	8f 90       	pop	r8
 d56:	08 95       	ret

00000d58 <rand_r>:
 d58:	0e 94 63 06 	call	0xcc6	; 0xcc6 <do_rand>
 d5c:	08 95       	ret

00000d5e <rand>:
 d5e:	80 e0       	ldi	r24, 0x00	; 0
 d60:	91 e0       	ldi	r25, 0x01	; 1
 d62:	0e 94 63 06 	call	0xcc6	; 0xcc6 <do_rand>
 d66:	08 95       	ret

00000d68 <srand>:
 d68:	a0 e0       	ldi	r26, 0x00	; 0
 d6a:	b0 e0       	ldi	r27, 0x00	; 0
 d6c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
 d70:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
 d74:	a0 93 02 01 	sts	0x0102, r26	; 0x800102 <__data_start+0x2>
 d78:	b0 93 03 01 	sts	0x0103, r27	; 0x800103 <__data_start+0x3>
 d7c:	08 95       	ret

00000d7e <__divmodsi4>:
 d7e:	05 2e       	mov	r0, r21
 d80:	97 fb       	bst	r25, 7
 d82:	1e f4       	brtc	.+6      	; 0xd8a <__divmodsi4+0xc>
 d84:	00 94       	com	r0
 d86:	0e 94 d6 06 	call	0xdac	; 0xdac <__negsi2>
 d8a:	57 fd       	sbrc	r21, 7
 d8c:	07 d0       	rcall	.+14     	; 0xd9c <__divmodsi4_neg2>
 d8e:	0e 94 f1 06 	call	0xde2	; 0xde2 <__udivmodsi4>
 d92:	07 fc       	sbrc	r0, 7
 d94:	03 d0       	rcall	.+6      	; 0xd9c <__divmodsi4_neg2>
 d96:	4e f4       	brtc	.+18     	; 0xdaa <__divmodsi4_exit>
 d98:	0c 94 d6 06 	jmp	0xdac	; 0xdac <__negsi2>

00000d9c <__divmodsi4_neg2>:
 d9c:	50 95       	com	r21
 d9e:	40 95       	com	r20
 da0:	30 95       	com	r19
 da2:	21 95       	neg	r18
 da4:	3f 4f       	sbci	r19, 0xFF	; 255
 da6:	4f 4f       	sbci	r20, 0xFF	; 255
 da8:	5f 4f       	sbci	r21, 0xFF	; 255

00000daa <__divmodsi4_exit>:
 daa:	08 95       	ret

00000dac <__negsi2>:
 dac:	90 95       	com	r25
 dae:	80 95       	com	r24
 db0:	70 95       	com	r23
 db2:	61 95       	neg	r22
 db4:	7f 4f       	sbci	r23, 0xFF	; 255
 db6:	8f 4f       	sbci	r24, 0xFF	; 255
 db8:	9f 4f       	sbci	r25, 0xFF	; 255
 dba:	08 95       	ret

00000dbc <__muluhisi3>:
 dbc:	0e 94 13 07 	call	0xe26	; 0xe26 <__umulhisi3>
 dc0:	a5 9f       	mul	r26, r21
 dc2:	90 0d       	add	r25, r0
 dc4:	b4 9f       	mul	r27, r20
 dc6:	90 0d       	add	r25, r0
 dc8:	a4 9f       	mul	r26, r20
 dca:	80 0d       	add	r24, r0
 dcc:	91 1d       	adc	r25, r1
 dce:	11 24       	eor	r1, r1
 dd0:	08 95       	ret

00000dd2 <__mulshisi3>:
 dd2:	b7 ff       	sbrs	r27, 7
 dd4:	0c 94 de 06 	jmp	0xdbc	; 0xdbc <__muluhisi3>

00000dd8 <__mulohisi3>:
 dd8:	0e 94 de 06 	call	0xdbc	; 0xdbc <__muluhisi3>
 ddc:	82 1b       	sub	r24, r18
 dde:	93 0b       	sbc	r25, r19
 de0:	08 95       	ret

00000de2 <__udivmodsi4>:
 de2:	a1 e2       	ldi	r26, 0x21	; 33
 de4:	1a 2e       	mov	r1, r26
 de6:	aa 1b       	sub	r26, r26
 de8:	bb 1b       	sub	r27, r27
 dea:	fd 01       	movw	r30, r26
 dec:	0d c0       	rjmp	.+26     	; 0xe08 <__udivmodsi4_ep>

00000dee <__udivmodsi4_loop>:
 dee:	aa 1f       	adc	r26, r26
 df0:	bb 1f       	adc	r27, r27
 df2:	ee 1f       	adc	r30, r30
 df4:	ff 1f       	adc	r31, r31
 df6:	a2 17       	cp	r26, r18
 df8:	b3 07       	cpc	r27, r19
 dfa:	e4 07       	cpc	r30, r20
 dfc:	f5 07       	cpc	r31, r21
 dfe:	20 f0       	brcs	.+8      	; 0xe08 <__udivmodsi4_ep>
 e00:	a2 1b       	sub	r26, r18
 e02:	b3 0b       	sbc	r27, r19
 e04:	e4 0b       	sbc	r30, r20
 e06:	f5 0b       	sbc	r31, r21

00000e08 <__udivmodsi4_ep>:
 e08:	66 1f       	adc	r22, r22
 e0a:	77 1f       	adc	r23, r23
 e0c:	88 1f       	adc	r24, r24
 e0e:	99 1f       	adc	r25, r25
 e10:	1a 94       	dec	r1
 e12:	69 f7       	brne	.-38     	; 0xdee <__udivmodsi4_loop>
 e14:	60 95       	com	r22
 e16:	70 95       	com	r23
 e18:	80 95       	com	r24
 e1a:	90 95       	com	r25
 e1c:	9b 01       	movw	r18, r22
 e1e:	ac 01       	movw	r20, r24
 e20:	bd 01       	movw	r22, r26
 e22:	cf 01       	movw	r24, r30
 e24:	08 95       	ret

00000e26 <__umulhisi3>:
 e26:	a2 9f       	mul	r26, r18
 e28:	b0 01       	movw	r22, r0
 e2a:	b3 9f       	mul	r27, r19
 e2c:	c0 01       	movw	r24, r0
 e2e:	a3 9f       	mul	r26, r19
 e30:	70 0d       	add	r23, r0
 e32:	81 1d       	adc	r24, r1
 e34:	11 24       	eor	r1, r1
 e36:	91 1d       	adc	r25, r1
 e38:	b2 9f       	mul	r27, r18
 e3a:	70 0d       	add	r23, r0
 e3c:	81 1d       	adc	r24, r1
 e3e:	11 24       	eor	r1, r1
 e40:	91 1d       	adc	r25, r1
 e42:	08 95       	ret

00000e44 <_exit>:
 e44:	f8 94       	cli

00000e46 <__stop_program>:
 e46:	ff cf       	rjmp	.-2      	; 0xe46 <__stop_program>
