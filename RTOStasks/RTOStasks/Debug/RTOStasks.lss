
RTOStasks.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00800100  00000c52  00000ce6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000c52  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000043f  0080010c  0080010c  00000cf2  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000cf2  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000d24  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000210  00000000  00000000  00000d64  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002829  00000000  00000000  00000f74  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000e5c  00000000  00000000  0000379d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000014f4  00000000  00000000  000045f9  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000588  00000000  00000000  00005af0  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000e68  00000000  00000000  00006078  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001def  00000000  00000000  00006ee0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000208  00000000  00000000  00008ccf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 be 02 	jmp	0x57c	; 0x57c <__vector_11>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e2 e5       	ldi	r30, 0x52	; 82
  7c:	fc e0       	ldi	r31, 0x0C	; 12
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	ac 30       	cpi	r26, 0x0C	; 12
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	25 e0       	ldi	r18, 0x05	; 5
  8c:	ac e0       	ldi	r26, 0x0C	; 12
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ab 34       	cpi	r26, 0x4B	; 75
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 37 01 	call	0x26e	; 0x26e <main>
  9e:	0c 94 27 06 	jmp	0xc4e	; 0xc4e <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
  a6:	cf 93       	push	r28
  a8:	df 93       	push	r29
  aa:	ec 01       	movw	r28, r24
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	}
	#endif

	vTaskSuspendAll();
  ac:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
  b0:	80 91 0c 01 	lds	r24, 0x010C	; 0x80010c <__data_end>
  b4:	90 91 0d 01 	lds	r25, 0x010D	; 0x80010d <__data_end+0x1>
  b8:	89 2b       	or	r24, r25
  ba:	31 f4       	brne	.+12     	; 0xc8 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
  bc:	81 e1       	ldi	r24, 0x11	; 17
  be:	91 e0       	ldi	r25, 0x01	; 1
  c0:	90 93 0d 01 	sts	0x010D, r25	; 0x80010d <__data_end+0x1>
  c4:	80 93 0c 01 	sts	0x010C, r24	; 0x80010c <__data_end>
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
  c8:	20 91 0e 01 	lds	r18, 0x010E	; 0x80010e <xNextFreeByte>
  cc:	30 91 0f 01 	lds	r19, 0x010F	; 0x80010f <xNextFreeByte+0x1>
  d0:	ce 01       	movw	r24, r28
  d2:	82 0f       	add	r24, r18
  d4:	93 1f       	adc	r25, r19
  d6:	87 3e       	cpi	r24, 0xE7	; 231
  d8:	43 e0       	ldi	r20, 0x03	; 3
  da:	94 07       	cpc	r25, r20
  dc:	70 f4       	brcc	.+28     	; 0xfa <pvPortMalloc+0x54>
  de:	28 17       	cp	r18, r24
  e0:	39 07       	cpc	r19, r25
  e2:	70 f4       	brcc	.+28     	; 0x100 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
  e4:	c0 91 0c 01 	lds	r28, 0x010C	; 0x80010c <__data_end>
  e8:	d0 91 0d 01 	lds	r29, 0x010D	; 0x80010d <__data_end+0x1>
  ec:	c2 0f       	add	r28, r18
  ee:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
  f0:	90 93 0f 01 	sts	0x010F, r25	; 0x80010f <xNextFreeByte+0x1>
  f4:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <xNextFreeByte>
  f8:	05 c0       	rjmp	.+10     	; 0x104 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
  fa:	c0 e0       	ldi	r28, 0x00	; 0
  fc:	d0 e0       	ldi	r29, 0x00	; 0
  fe:	02 c0       	rjmp	.+4      	; 0x104 <pvPortMalloc+0x5e>
 100:	c0 e0       	ldi	r28, 0x00	; 0
 102:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
 104:	0e 94 1d 05 	call	0xa3a	; 0xa3a <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
 108:	ce 01       	movw	r24, r28
 10a:	df 91       	pop	r29
 10c:	cf 91       	pop	r28
 10e:	08 95       	ret

00000110 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
 110:	08 95       	ret

00000112 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
 112:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 114:	03 96       	adiw	r24, 0x03	; 3
 116:	92 83       	std	Z+2, r25	; 0x02
 118:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
 11a:	2f ef       	ldi	r18, 0xFF	; 255
 11c:	3f ef       	ldi	r19, 0xFF	; 255
 11e:	34 83       	std	Z+4, r19	; 0x04
 120:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 122:	96 83       	std	Z+6, r25	; 0x06
 124:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 126:	90 87       	std	Z+8, r25	; 0x08
 128:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
 12a:	10 82       	st	Z, r1
 12c:	08 95       	ret

0000012e <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
 12e:	fc 01       	movw	r30, r24
 130:	11 86       	std	Z+9, r1	; 0x09
 132:	10 86       	std	Z+8, r1	; 0x08
 134:	08 95       	ret

00000136 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 136:	cf 93       	push	r28
 138:	df 93       	push	r29
 13a:	9c 01       	movw	r18, r24
 13c:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
 13e:	dc 01       	movw	r26, r24
 140:	11 96       	adiw	r26, 0x01	; 1
 142:	cd 91       	ld	r28, X+
 144:	dc 91       	ld	r29, X
 146:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
 148:	d3 83       	std	Z+3, r29	; 0x03
 14a:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 14c:	8c 81       	ldd	r24, Y+4	; 0x04
 14e:	9d 81       	ldd	r25, Y+5	; 0x05
 150:	95 83       	std	Z+5, r25	; 0x05
 152:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
 154:	8c 81       	ldd	r24, Y+4	; 0x04
 156:	9d 81       	ldd	r25, Y+5	; 0x05
 158:	dc 01       	movw	r26, r24
 15a:	13 96       	adiw	r26, 0x03	; 3
 15c:	7c 93       	st	X, r23
 15e:	6e 93       	st	-X, r22
 160:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
 162:	7d 83       	std	Y+5, r23	; 0x05
 164:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 166:	31 87       	std	Z+9, r19	; 0x09
 168:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
 16a:	f9 01       	movw	r30, r18
 16c:	80 81       	ld	r24, Z
 16e:	8f 5f       	subi	r24, 0xFF	; 255
 170:	80 83       	st	Z, r24
}
 172:	df 91       	pop	r29
 174:	cf 91       	pop	r28
 176:	08 95       	ret

00000178 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
 178:	cf 93       	push	r28
 17a:	df 93       	push	r29
 17c:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
 17e:	48 81       	ld	r20, Y
 180:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
 182:	4f 3f       	cpi	r20, 0xFF	; 255
 184:	2f ef       	ldi	r18, 0xFF	; 255
 186:	52 07       	cpc	r21, r18
 188:	21 f4       	brne	.+8      	; 0x192 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
 18a:	fc 01       	movw	r30, r24
 18c:	a7 81       	ldd	r26, Z+7	; 0x07
 18e:	b0 85       	ldd	r27, Z+8	; 0x08
 190:	0d c0       	rjmp	.+26     	; 0x1ac <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
 192:	dc 01       	movw	r26, r24
 194:	13 96       	adiw	r26, 0x03	; 3
 196:	01 c0       	rjmp	.+2      	; 0x19a <vListInsert+0x22>
 198:	df 01       	movw	r26, r30
 19a:	12 96       	adiw	r26, 0x02	; 2
 19c:	ed 91       	ld	r30, X+
 19e:	fc 91       	ld	r31, X
 1a0:	13 97       	sbiw	r26, 0x03	; 3
 1a2:	20 81       	ld	r18, Z
 1a4:	31 81       	ldd	r19, Z+1	; 0x01
 1a6:	42 17       	cp	r20, r18
 1a8:	53 07       	cpc	r21, r19
 1aa:	b0 f7       	brcc	.-20     	; 0x198 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
 1ac:	12 96       	adiw	r26, 0x02	; 2
 1ae:	ed 91       	ld	r30, X+
 1b0:	fc 91       	ld	r31, X
 1b2:	13 97       	sbiw	r26, 0x03	; 3
 1b4:	fb 83       	std	Y+3, r31	; 0x03
 1b6:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
 1b8:	d5 83       	std	Z+5, r29	; 0x05
 1ba:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
 1bc:	bd 83       	std	Y+5, r27	; 0x05
 1be:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
 1c0:	13 96       	adiw	r26, 0x03	; 3
 1c2:	dc 93       	st	X, r29
 1c4:	ce 93       	st	-X, r28
 1c6:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
 1c8:	99 87       	std	Y+9, r25	; 0x09
 1ca:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
 1cc:	fc 01       	movw	r30, r24
 1ce:	20 81       	ld	r18, Z
 1d0:	2f 5f       	subi	r18, 0xFF	; 255
 1d2:	20 83       	st	Z, r18
}
 1d4:	df 91       	pop	r29
 1d6:	cf 91       	pop	r28
 1d8:	08 95       	ret

000001da <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
 1da:	cf 93       	push	r28
 1dc:	df 93       	push	r29
 1de:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
 1e0:	a0 85       	ldd	r26, Z+8	; 0x08
 1e2:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 1e4:	c2 81       	ldd	r28, Z+2	; 0x02
 1e6:	d3 81       	ldd	r29, Z+3	; 0x03
 1e8:	84 81       	ldd	r24, Z+4	; 0x04
 1ea:	95 81       	ldd	r25, Z+5	; 0x05
 1ec:	9d 83       	std	Y+5, r25	; 0x05
 1ee:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 1f0:	c4 81       	ldd	r28, Z+4	; 0x04
 1f2:	d5 81       	ldd	r29, Z+5	; 0x05
 1f4:	82 81       	ldd	r24, Z+2	; 0x02
 1f6:	93 81       	ldd	r25, Z+3	; 0x03
 1f8:	9b 83       	std	Y+3, r25	; 0x03
 1fa:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 1fc:	11 96       	adiw	r26, 0x01	; 1
 1fe:	cd 91       	ld	r28, X+
 200:	dc 91       	ld	r29, X
 202:	12 97       	sbiw	r26, 0x02	; 2
 204:	ce 17       	cp	r28, r30
 206:	df 07       	cpc	r29, r31
 208:	31 f4       	brne	.+12     	; 0x216 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 20a:	8c 81       	ldd	r24, Y+4	; 0x04
 20c:	9d 81       	ldd	r25, Y+5	; 0x05
 20e:	12 96       	adiw	r26, 0x02	; 2
 210:	9c 93       	st	X, r25
 212:	8e 93       	st	-X, r24
 214:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
 216:	11 86       	std	Z+9, r1	; 0x09
 218:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
 21a:	8c 91       	ld	r24, X
 21c:	81 50       	subi	r24, 0x01	; 1
 21e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
 220:	df 91       	pop	r29
 222:	cf 91       	pop	r28
 224:	08 95       	ret

00000226 <vTestTask2>:
}

static void vTestTask2( void *pvParameters )
{
	( void ) pvParameters;
	vTaskSetApplicationTaskTag( NULL, ( void * ) 0x02 );
 226:	62 e0       	ldi	r22, 0x02	; 2
 228:	70 e0       	ldi	r23, 0x00	; 0
 22a:	80 e0       	ldi	r24, 0x00	; 0
 22c:	90 e0       	ldi	r25, 0x00	; 0
 22e:	0e 94 b0 05 	call	0xb60	; 0xb60 <vTaskSetApplicationTaskTag>
	uint8_t pinmask = 0x02;
	DDRD |= pinmask;
 232:	51 9a       	sbi	0x0a, 1	; 10
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 234:	8f e9       	ldi	r24, 0x9F	; 159
 236:	9f e0       	ldi	r25, 0x0F	; 15
 238:	01 97       	sbiw	r24, 0x01	; 1
 23a:	f1 f7       	brne	.-4      	; 0x238 <vTestTask2+0x12>
 23c:	00 c0       	rjmp	.+0      	; 0x23e <vTestTask2+0x18>
 23e:	00 00       	nop
	for( ;; )
	{
		_delay_ms( 1 );   //simulate task work done
		vTaskDelay( 1 );
 240:	81 e0       	ldi	r24, 0x01	; 1
 242:	90 e0       	ldi	r25, 0x00	; 0
 244:	0e 94 9c 05 	call	0xb38	; 0xb38 <vTaskDelay>
	}
 248:	f5 cf       	rjmp	.-22     	; 0x234 <vTestTask2+0xe>

0000024a <vTestTask1>:
}

static void vTestTask1( void *pvParameters )
{
	( void ) pvParameters;
	vTaskSetApplicationTaskTag( NULL, ( void * ) 0x01 );
 24a:	61 e0       	ldi	r22, 0x01	; 1
 24c:	70 e0       	ldi	r23, 0x00	; 0
 24e:	80 e0       	ldi	r24, 0x00	; 0
 250:	90 e0       	ldi	r25, 0x00	; 0
 252:	0e 94 b0 05 	call	0xb60	; 0xb60 <vTaskSetApplicationTaskTag>
	uint8_t pinmask = 0x01; 
	DDRD |= pinmask;
 256:	50 9a       	sbi	0x0a, 0	; 10
 258:	8f e9       	ldi	r24, 0x9F	; 159
 25a:	9f e0       	ldi	r25, 0x0F	; 15
 25c:	01 97       	sbiw	r24, 0x01	; 1
 25e:	f1 f7       	brne	.-4      	; 0x25c <vTestTask1+0x12>
 260:	00 c0       	rjmp	.+0      	; 0x262 <vTestTask1+0x18>
 262:	00 00       	nop
    for( ;; )
	{
        _delay_ms( 1 );   //simulate task work done 
        vTaskDelay( 1 );
 264:	81 e0       	ldi	r24, 0x01	; 1
 266:	90 e0       	ldi	r25, 0x00	; 0
 268:	0e 94 9c 05 	call	0xb38	; 0xb38 <vTaskDelay>
	}
 26c:	f5 cf       	rjmp	.-22     	; 0x258 <vTestTask1+0xe>

0000026e <main>:
   at each corresponding event  */

void vContextSwitch();

int main( void )
{
 26e:	ef 92       	push	r14
 270:	ff 92       	push	r15
 272:	0f 93       	push	r16
	//PORTD |= 0x01;
    // create tasks and start scheduler
	xTaskCreate( vTestTask1, ( const char * ) "T1", 255, (void *)('1'), mainTEST_TASK_PRIORITY, NULL );
 274:	e1 2c       	mov	r14, r1
 276:	f1 2c       	mov	r15, r1
 278:	01 e0       	ldi	r16, 0x01	; 1
 27a:	21 e3       	ldi	r18, 0x31	; 49
 27c:	30 e0       	ldi	r19, 0x00	; 0
 27e:	4f ef       	ldi	r20, 0xFF	; 255
 280:	50 e0       	ldi	r21, 0x00	; 0
 282:	60 e0       	ldi	r22, 0x00	; 0
 284:	71 e0       	ldi	r23, 0x01	; 1
 286:	85 e2       	ldi	r24, 0x25	; 37
 288:	91 e0       	ldi	r25, 0x01	; 1
 28a:	0e 94 2c 03 	call	0x658	; 0x658 <xTaskCreate>
	xTaskCreate( vTestTask2, ( const char * ) "T2", 255, (void *)('2'), mainTEST_TASK_PRIORITY, NULL );
 28e:	22 e3       	ldi	r18, 0x32	; 50
 290:	30 e0       	ldi	r19, 0x00	; 0
 292:	4f ef       	ldi	r20, 0xFF	; 255
 294:	50 e0       	ldi	r21, 0x00	; 0
 296:	63 e0       	ldi	r22, 0x03	; 3
 298:	71 e0       	ldi	r23, 0x01	; 1
 29a:	83 e1       	ldi	r24, 0x13	; 19
 29c:	91 e0       	ldi	r25, 0x01	; 1
 29e:	0e 94 2c 03 	call	0x658	; 0x658 <xTaskCreate>
	vTaskStartScheduler();
 2a2:	0e 94 32 04 	call	0x864	; 0x864 <vTaskStartScheduler>
	return 0;
}
 2a6:	80 e0       	ldi	r24, 0x00	; 0
 2a8:	90 e0       	ldi	r25, 0x00	; 0
 2aa:	0f 91       	pop	r16
 2ac:	ff 90       	pop	r15
 2ae:	ef 90       	pop	r14
 2b0:	08 95       	ret

000002b2 <vContextSwitch>:
		vTaskDelay( 1 );
	}
}

void vContextSwitch() {
	if (PORTD == 0x01) {
 2b2:	8b b1       	in	r24, 0x0b	; 11
 2b4:	81 30       	cpi	r24, 0x01	; 1
 2b6:	19 f4       	brne	.+6      	; 0x2be <vContextSwitch+0xc>
		PORTD &= ~0x01;
 2b8:	58 98       	cbi	0x0b, 0	; 11
		PORTD |= 0x02;
 2ba:	59 9a       	sbi	0x0b, 1	; 11
 2bc:	08 95       	ret
	} else {
		PORTD &= ~0x02;
 2be:	59 98       	cbi	0x0b, 1	; 11
		PORTD |= 0x01;
 2c0:	58 9a       	sbi	0x0b, 0	; 11
 2c2:	08 95       	ret

000002c4 <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
 2c4:	31 e1       	ldi	r19, 0x11	; 17
 2c6:	fc 01       	movw	r30, r24
 2c8:	30 83       	st	Z, r19
 2ca:	31 97       	sbiw	r30, 0x01	; 1
 2cc:	22 e2       	ldi	r18, 0x22	; 34
 2ce:	20 83       	st	Z, r18
 2d0:	31 97       	sbiw	r30, 0x01	; 1
 2d2:	a3 e3       	ldi	r26, 0x33	; 51
 2d4:	a0 83       	st	Z, r26
 2d6:	31 97       	sbiw	r30, 0x01	; 1
 2d8:	60 83       	st	Z, r22
 2da:	31 97       	sbiw	r30, 0x01	; 1
 2dc:	70 83       	st	Z, r23
 2de:	31 97       	sbiw	r30, 0x01	; 1
 2e0:	10 82       	st	Z, r1
 2e2:	31 97       	sbiw	r30, 0x01	; 1
 2e4:	60 e8       	ldi	r22, 0x80	; 128
 2e6:	60 83       	st	Z, r22
 2e8:	31 97       	sbiw	r30, 0x01	; 1
 2ea:	10 82       	st	Z, r1
 2ec:	31 97       	sbiw	r30, 0x01	; 1
 2ee:	62 e0       	ldi	r22, 0x02	; 2
 2f0:	60 83       	st	Z, r22
 2f2:	31 97       	sbiw	r30, 0x01	; 1
 2f4:	63 e0       	ldi	r22, 0x03	; 3
 2f6:	60 83       	st	Z, r22
 2f8:	31 97       	sbiw	r30, 0x01	; 1
 2fa:	64 e0       	ldi	r22, 0x04	; 4
 2fc:	60 83       	st	Z, r22
 2fe:	31 97       	sbiw	r30, 0x01	; 1
 300:	65 e0       	ldi	r22, 0x05	; 5
 302:	60 83       	st	Z, r22
 304:	31 97       	sbiw	r30, 0x01	; 1
 306:	66 e0       	ldi	r22, 0x06	; 6
 308:	60 83       	st	Z, r22
 30a:	31 97       	sbiw	r30, 0x01	; 1
 30c:	67 e0       	ldi	r22, 0x07	; 7
 30e:	60 83       	st	Z, r22
 310:	31 97       	sbiw	r30, 0x01	; 1
 312:	68 e0       	ldi	r22, 0x08	; 8
 314:	60 83       	st	Z, r22
 316:	31 97       	sbiw	r30, 0x01	; 1
 318:	69 e0       	ldi	r22, 0x09	; 9
 31a:	60 83       	st	Z, r22
 31c:	31 97       	sbiw	r30, 0x01	; 1
 31e:	60 e1       	ldi	r22, 0x10	; 16
 320:	60 83       	st	Z, r22
 322:	31 97       	sbiw	r30, 0x01	; 1
 324:	30 83       	st	Z, r19
 326:	31 97       	sbiw	r30, 0x01	; 1
 328:	32 e1       	ldi	r19, 0x12	; 18
 32a:	30 83       	st	Z, r19
 32c:	31 97       	sbiw	r30, 0x01	; 1
 32e:	33 e1       	ldi	r19, 0x13	; 19
 330:	30 83       	st	Z, r19
 332:	31 97       	sbiw	r30, 0x01	; 1
 334:	34 e1       	ldi	r19, 0x14	; 20
 336:	30 83       	st	Z, r19
 338:	31 97       	sbiw	r30, 0x01	; 1
 33a:	35 e1       	ldi	r19, 0x15	; 21
 33c:	30 83       	st	Z, r19
 33e:	31 97       	sbiw	r30, 0x01	; 1
 340:	36 e1       	ldi	r19, 0x16	; 22
 342:	30 83       	st	Z, r19
 344:	31 97       	sbiw	r30, 0x01	; 1
 346:	37 e1       	ldi	r19, 0x17	; 23
 348:	30 83       	st	Z, r19
 34a:	31 97       	sbiw	r30, 0x01	; 1
 34c:	38 e1       	ldi	r19, 0x18	; 24
 34e:	30 83       	st	Z, r19
 350:	31 97       	sbiw	r30, 0x01	; 1
 352:	39 e1       	ldi	r19, 0x19	; 25
 354:	30 83       	st	Z, r19
 356:	31 97       	sbiw	r30, 0x01	; 1
 358:	30 e2       	ldi	r19, 0x20	; 32
 35a:	30 83       	st	Z, r19
 35c:	31 97       	sbiw	r30, 0x01	; 1
 35e:	31 e2       	ldi	r19, 0x21	; 33
 360:	30 83       	st	Z, r19
 362:	31 97       	sbiw	r30, 0x01	; 1
 364:	20 83       	st	Z, r18
 366:	31 97       	sbiw	r30, 0x01	; 1
 368:	23 e2       	ldi	r18, 0x23	; 35
 36a:	20 83       	st	Z, r18
 36c:	31 97       	sbiw	r30, 0x01	; 1
 36e:	40 83       	st	Z, r20
 370:	31 97       	sbiw	r30, 0x01	; 1
 372:	50 83       	st	Z, r21
 374:	31 97       	sbiw	r30, 0x01	; 1
 376:	26 e2       	ldi	r18, 0x26	; 38
 378:	20 83       	st	Z, r18
 37a:	31 97       	sbiw	r30, 0x01	; 1
 37c:	27 e2       	ldi	r18, 0x27	; 39
 37e:	20 83       	st	Z, r18
 380:	31 97       	sbiw	r30, 0x01	; 1
 382:	28 e2       	ldi	r18, 0x28	; 40
 384:	20 83       	st	Z, r18
 386:	31 97       	sbiw	r30, 0x01	; 1
 388:	29 e2       	ldi	r18, 0x29	; 41
 38a:	20 83       	st	Z, r18
 38c:	31 97       	sbiw	r30, 0x01	; 1
 38e:	20 e3       	ldi	r18, 0x30	; 48
 390:	20 83       	st	Z, r18
 392:	31 97       	sbiw	r30, 0x01	; 1
 394:	21 e3       	ldi	r18, 0x31	; 49
 396:	20 83       	st	Z, r18
 398:	86 97       	sbiw	r24, 0x26	; 38
 39a:	08 95       	ret

0000039c <xPortStartScheduler>:
 39c:	8a e7       	ldi	r24, 0x7A	; 122
 39e:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
 3a2:	81 e1       	ldi	r24, 0x11	; 17
 3a4:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
 3a8:	8b e0       	ldi	r24, 0x0B	; 11
 3aa:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
 3ae:	ef e6       	ldi	r30, 0x6F	; 111
 3b0:	f0 e0       	ldi	r31, 0x00	; 0
 3b2:	80 81       	ld	r24, Z
 3b4:	82 60       	ori	r24, 0x02	; 2
 3b6:	80 83       	st	Z, r24
 3b8:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 3bc:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 3c0:	cd 91       	ld	r28, X+
 3c2:	cd bf       	out	0x3d, r28	; 61
 3c4:	dd 91       	ld	r29, X+
 3c6:	de bf       	out	0x3e, r29	; 62
 3c8:	ff 91       	pop	r31
 3ca:	ef 91       	pop	r30
 3cc:	df 91       	pop	r29
 3ce:	cf 91       	pop	r28
 3d0:	bf 91       	pop	r27
 3d2:	af 91       	pop	r26
 3d4:	9f 91       	pop	r25
 3d6:	8f 91       	pop	r24
 3d8:	7f 91       	pop	r23
 3da:	6f 91       	pop	r22
 3dc:	5f 91       	pop	r21
 3de:	4f 91       	pop	r20
 3e0:	3f 91       	pop	r19
 3e2:	2f 91       	pop	r18
 3e4:	1f 91       	pop	r17
 3e6:	0f 91       	pop	r16
 3e8:	ff 90       	pop	r15
 3ea:	ef 90       	pop	r14
 3ec:	df 90       	pop	r13
 3ee:	cf 90       	pop	r12
 3f0:	bf 90       	pop	r11
 3f2:	af 90       	pop	r10
 3f4:	9f 90       	pop	r9
 3f6:	8f 90       	pop	r8
 3f8:	7f 90       	pop	r7
 3fa:	6f 90       	pop	r6
 3fc:	5f 90       	pop	r5
 3fe:	4f 90       	pop	r4
 400:	3f 90       	pop	r3
 402:	2f 90       	pop	r2
 404:	1f 90       	pop	r1
 406:	0f 90       	pop	r0
 408:	0f be       	out	0x3f, r0	; 63
 40a:	0f 90       	pop	r0
 40c:	08 95       	ret
 40e:	81 e0       	ldi	r24, 0x01	; 1
 410:	08 95       	ret

00000412 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
 412:	0f 92       	push	r0
 414:	0f b6       	in	r0, 0x3f	; 63
 416:	f8 94       	cli
 418:	0f 92       	push	r0
 41a:	1f 92       	push	r1
 41c:	11 24       	eor	r1, r1
 41e:	2f 92       	push	r2
 420:	3f 92       	push	r3
 422:	4f 92       	push	r4
 424:	5f 92       	push	r5
 426:	6f 92       	push	r6
 428:	7f 92       	push	r7
 42a:	8f 92       	push	r8
 42c:	9f 92       	push	r9
 42e:	af 92       	push	r10
 430:	bf 92       	push	r11
 432:	cf 92       	push	r12
 434:	df 92       	push	r13
 436:	ef 92       	push	r14
 438:	ff 92       	push	r15
 43a:	0f 93       	push	r16
 43c:	1f 93       	push	r17
 43e:	2f 93       	push	r18
 440:	3f 93       	push	r19
 442:	4f 93       	push	r20
 444:	5f 93       	push	r21
 446:	6f 93       	push	r22
 448:	7f 93       	push	r23
 44a:	8f 93       	push	r24
 44c:	9f 93       	push	r25
 44e:	af 93       	push	r26
 450:	bf 93       	push	r27
 452:	cf 93       	push	r28
 454:	df 93       	push	r29
 456:	ef 93       	push	r30
 458:	ff 93       	push	r31
 45a:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 45e:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 462:	0d b6       	in	r0, 0x3d	; 61
 464:	0d 92       	st	X+, r0
 466:	0e b6       	in	r0, 0x3e	; 62
 468:	0d 92       	st	X+, r0
	vTaskSwitchContext();
 46a:	0e 94 bf 05 	call	0xb7e	; 0xb7e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
 46e:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 472:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 476:	cd 91       	ld	r28, X+
 478:	cd bf       	out	0x3d, r28	; 61
 47a:	dd 91       	ld	r29, X+
 47c:	de bf       	out	0x3e, r29	; 62
 47e:	ff 91       	pop	r31
 480:	ef 91       	pop	r30
 482:	df 91       	pop	r29
 484:	cf 91       	pop	r28
 486:	bf 91       	pop	r27
 488:	af 91       	pop	r26
 48a:	9f 91       	pop	r25
 48c:	8f 91       	pop	r24
 48e:	7f 91       	pop	r23
 490:	6f 91       	pop	r22
 492:	5f 91       	pop	r21
 494:	4f 91       	pop	r20
 496:	3f 91       	pop	r19
 498:	2f 91       	pop	r18
 49a:	1f 91       	pop	r17
 49c:	0f 91       	pop	r16
 49e:	ff 90       	pop	r15
 4a0:	ef 90       	pop	r14
 4a2:	df 90       	pop	r13
 4a4:	cf 90       	pop	r12
 4a6:	bf 90       	pop	r11
 4a8:	af 90       	pop	r10
 4aa:	9f 90       	pop	r9
 4ac:	8f 90       	pop	r8
 4ae:	7f 90       	pop	r7
 4b0:	6f 90       	pop	r6
 4b2:	5f 90       	pop	r5
 4b4:	4f 90       	pop	r4
 4b6:	3f 90       	pop	r3
 4b8:	2f 90       	pop	r2
 4ba:	1f 90       	pop	r1
 4bc:	0f 90       	pop	r0
 4be:	0f be       	out	0x3f, r0	; 63
 4c0:	0f 90       	pop	r0

	asm volatile ( "ret" );
 4c2:	08 95       	ret

000004c4 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
 4c4:	0f 92       	push	r0
 4c6:	0f b6       	in	r0, 0x3f	; 63
 4c8:	f8 94       	cli
 4ca:	0f 92       	push	r0
 4cc:	1f 92       	push	r1
 4ce:	11 24       	eor	r1, r1
 4d0:	2f 92       	push	r2
 4d2:	3f 92       	push	r3
 4d4:	4f 92       	push	r4
 4d6:	5f 92       	push	r5
 4d8:	6f 92       	push	r6
 4da:	7f 92       	push	r7
 4dc:	8f 92       	push	r8
 4de:	9f 92       	push	r9
 4e0:	af 92       	push	r10
 4e2:	bf 92       	push	r11
 4e4:	cf 92       	push	r12
 4e6:	df 92       	push	r13
 4e8:	ef 92       	push	r14
 4ea:	ff 92       	push	r15
 4ec:	0f 93       	push	r16
 4ee:	1f 93       	push	r17
 4f0:	2f 93       	push	r18
 4f2:	3f 93       	push	r19
 4f4:	4f 93       	push	r20
 4f6:	5f 93       	push	r21
 4f8:	6f 93       	push	r22
 4fa:	7f 93       	push	r23
 4fc:	8f 93       	push	r24
 4fe:	9f 93       	push	r25
 500:	af 93       	push	r26
 502:	bf 93       	push	r27
 504:	cf 93       	push	r28
 506:	df 93       	push	r29
 508:	ef 93       	push	r30
 50a:	ff 93       	push	r31
 50c:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 510:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 514:	0d b6       	in	r0, 0x3d	; 61
 516:	0d 92       	st	X+, r0
 518:	0e b6       	in	r0, 0x3e	; 62
 51a:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
 51c:	0e 94 62 04 	call	0x8c4	; 0x8c4 <xTaskIncrementTick>
 520:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
 522:	0e 94 bf 05 	call	0xb7e	; 0xb7e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
 526:	a0 91 49 05 	lds	r26, 0x0549	; 0x800549 <pxCurrentTCB>
 52a:	b0 91 4a 05 	lds	r27, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 52e:	cd 91       	ld	r28, X+
 530:	cd bf       	out	0x3d, r28	; 61
 532:	dd 91       	ld	r29, X+
 534:	de bf       	out	0x3e, r29	; 62
 536:	ff 91       	pop	r31
 538:	ef 91       	pop	r30
 53a:	df 91       	pop	r29
 53c:	cf 91       	pop	r28
 53e:	bf 91       	pop	r27
 540:	af 91       	pop	r26
 542:	9f 91       	pop	r25
 544:	8f 91       	pop	r24
 546:	7f 91       	pop	r23
 548:	6f 91       	pop	r22
 54a:	5f 91       	pop	r21
 54c:	4f 91       	pop	r20
 54e:	3f 91       	pop	r19
 550:	2f 91       	pop	r18
 552:	1f 91       	pop	r17
 554:	0f 91       	pop	r16
 556:	ff 90       	pop	r15
 558:	ef 90       	pop	r14
 55a:	df 90       	pop	r13
 55c:	cf 90       	pop	r12
 55e:	bf 90       	pop	r11
 560:	af 90       	pop	r10
 562:	9f 90       	pop	r9
 564:	8f 90       	pop	r8
 566:	7f 90       	pop	r7
 568:	6f 90       	pop	r6
 56a:	5f 90       	pop	r5
 56c:	4f 90       	pop	r4
 56e:	3f 90       	pop	r3
 570:	2f 90       	pop	r2
 572:	1f 90       	pop	r1
 574:	0f 90       	pop	r0
 576:	0f be       	out	0x3f, r0	; 63
 578:	0f 90       	pop	r0

	asm volatile ( "ret" );
 57a:	08 95       	ret

0000057c <__vector_11>:
	 * the context is saved at the start of vPortYieldFromTick().  The tick
	 * count is incremented after the context is saved.
	 */
	ISR(TIMER1_COMPA_vect , ISR_NAKED )
	{
		vPortYieldFromTick();
 57c:	0e 94 62 02 	call	0x4c4	; 0x4c4 <vPortYieldFromTick>
		asm volatile ( "reti" );
 580:	18 95       	reti

00000582 <prvResetNextTaskUnblockTime>:
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
 582:	e0 91 11 05 	lds	r30, 0x0511	; 0x800511 <pxDelayedTaskList>
 586:	f0 91 12 05 	lds	r31, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 58a:	80 81       	ld	r24, Z
 58c:	81 11       	cpse	r24, r1
 58e:	07 c0       	rjmp	.+14     	; 0x59e <prvResetNextTaskUnblockTime+0x1c>
 590:	8f ef       	ldi	r24, 0xFF	; 255
 592:	9f ef       	ldi	r25, 0xFF	; 255
 594:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <xNextTaskUnblockTime+0x1>
 598:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <xNextTaskUnblockTime>
 59c:	08 95       	ret
 59e:	e0 91 11 05 	lds	r30, 0x0511	; 0x800511 <pxDelayedTaskList>
 5a2:	f0 91 12 05 	lds	r31, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 5a6:	05 80       	ldd	r0, Z+5	; 0x05
 5a8:	f6 81       	ldd	r31, Z+6	; 0x06
 5aa:	e0 2d       	mov	r30, r0
 5ac:	06 80       	ldd	r0, Z+6	; 0x06
 5ae:	f7 81       	ldd	r31, Z+7	; 0x07
 5b0:	e0 2d       	mov	r30, r0
 5b2:	82 81       	ldd	r24, Z+2	; 0x02
 5b4:	93 81       	ldd	r25, Z+3	; 0x03
 5b6:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <xNextTaskUnblockTime+0x1>
 5ba:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <xNextTaskUnblockTime>
 5be:	08 95       	ret

000005c0 <prvIdleTask>:
 5c0:	c5 e2       	ldi	r28, 0x25	; 37
 5c2:	d5 e0       	ldi	r29, 0x05	; 5
 5c4:	88 81       	ld	r24, Y
 5c6:	82 30       	cpi	r24, 0x02	; 2
 5c8:	f0 f3       	brcs	.-4      	; 0x5c6 <prvIdleTask+0x6>
 5ca:	0e 94 09 02 	call	0x412	; 0x412 <vPortYield>
 5ce:	fa cf       	rjmp	.-12     	; 0x5c4 <prvIdleTask+0x4>

000005d0 <prvAddCurrentTaskToDelayedList>:
 5d0:	0f 93       	push	r16
 5d2:	1f 93       	push	r17
 5d4:	cf 93       	push	r28
 5d6:	df 93       	push	r29
 5d8:	ec 01       	movw	r28, r24
 5da:	00 91 03 05 	lds	r16, 0x0503	; 0x800503 <xTickCount>
 5de:	10 91 04 05 	lds	r17, 0x0504	; 0x800504 <xTickCount+0x1>
 5e2:	80 91 49 05 	lds	r24, 0x0549	; 0x800549 <pxCurrentTCB>
 5e6:	90 91 4a 05 	lds	r25, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 5ea:	02 96       	adiw	r24, 0x02	; 2
 5ec:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
 5f0:	c0 0f       	add	r28, r16
 5f2:	d1 1f       	adc	r29, r17
 5f4:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 5f8:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 5fc:	d3 83       	std	Z+3, r29	; 0x03
 5fe:	c2 83       	std	Z+2, r28	; 0x02
 600:	c0 17       	cp	r28, r16
 602:	d1 07       	cpc	r29, r17
 604:	68 f4       	brcc	.+26     	; 0x620 <prvAddCurrentTaskToDelayedList+0x50>
 606:	60 91 49 05 	lds	r22, 0x0549	; 0x800549 <pxCurrentTCB>
 60a:	70 91 4a 05 	lds	r23, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 60e:	80 91 0f 05 	lds	r24, 0x050F	; 0x80050f <pxOverflowDelayedTaskList>
 612:	90 91 10 05 	lds	r25, 0x0510	; 0x800510 <pxOverflowDelayedTaskList+0x1>
 616:	6e 5f       	subi	r22, 0xFE	; 254
 618:	7f 4f       	sbci	r23, 0xFF	; 255
 61a:	0e 94 bc 00 	call	0x178	; 0x178 <vListInsert>
 61e:	17 c0       	rjmp	.+46     	; 0x64e <prvAddCurrentTaskToDelayedList+0x7e>
 620:	60 91 49 05 	lds	r22, 0x0549	; 0x800549 <pxCurrentTCB>
 624:	70 91 4a 05 	lds	r23, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 628:	80 91 11 05 	lds	r24, 0x0511	; 0x800511 <pxDelayedTaskList>
 62c:	90 91 12 05 	lds	r25, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 630:	6e 5f       	subi	r22, 0xFE	; 254
 632:	7f 4f       	sbci	r23, 0xFF	; 255
 634:	0e 94 bc 00 	call	0x178	; 0x178 <vListInsert>
 638:	80 91 fb 04 	lds	r24, 0x04FB	; 0x8004fb <xNextTaskUnblockTime>
 63c:	90 91 fc 04 	lds	r25, 0x04FC	; 0x8004fc <xNextTaskUnblockTime+0x1>
 640:	c8 17       	cp	r28, r24
 642:	d9 07       	cpc	r29, r25
 644:	20 f4       	brcc	.+8      	; 0x64e <prvAddCurrentTaskToDelayedList+0x7e>
 646:	d0 93 fc 04 	sts	0x04FC, r29	; 0x8004fc <xNextTaskUnblockTime+0x1>
 64a:	c0 93 fb 04 	sts	0x04FB, r28	; 0x8004fb <xNextTaskUnblockTime>
 64e:	df 91       	pop	r29
 650:	cf 91       	pop	r28
 652:	1f 91       	pop	r17
 654:	0f 91       	pop	r16
 656:	08 95       	ret

00000658 <xTaskCreate>:
 658:	4f 92       	push	r4
 65a:	5f 92       	push	r5
 65c:	6f 92       	push	r6
 65e:	7f 92       	push	r7
 660:	8f 92       	push	r8
 662:	9f 92       	push	r9
 664:	af 92       	push	r10
 666:	bf 92       	push	r11
 668:	cf 92       	push	r12
 66a:	df 92       	push	r13
 66c:	ef 92       	push	r14
 66e:	ff 92       	push	r15
 670:	0f 93       	push	r16
 672:	cf 93       	push	r28
 674:	df 93       	push	r29
 676:	4c 01       	movw	r8, r24
 678:	6b 01       	movw	r12, r22
 67a:	5a 01       	movw	r10, r20
 67c:	29 01       	movw	r4, r18
 67e:	ca 01       	movw	r24, r20
 680:	0e 94 53 00 	call	0xa6	; 0xa6 <pvPortMalloc>
 684:	3c 01       	movw	r6, r24
 686:	89 2b       	or	r24, r25
 688:	09 f4       	brne	.+2      	; 0x68c <xTaskCreate+0x34>
 68a:	db c0       	rjmp	.+438    	; 0x842 <xTaskCreate+0x1ea>
 68c:	88 e2       	ldi	r24, 0x28	; 40
 68e:	90 e0       	ldi	r25, 0x00	; 0
 690:	0e 94 53 00 	call	0xa6	; 0xa6 <pvPortMalloc>
 694:	ec 01       	movw	r28, r24
 696:	89 2b       	or	r24, r25
 698:	71 f0       	breq	.+28     	; 0x6b6 <xTaskCreate+0x5e>
 69a:	78 8e       	std	Y+24, r7	; 0x18
 69c:	6f 8a       	std	Y+23, r6	; 0x17
 69e:	81 e0       	ldi	r24, 0x01	; 1
 6a0:	a8 1a       	sub	r10, r24
 6a2:	b1 08       	sbc	r11, r1
 6a4:	6a 0c       	add	r6, r10
 6a6:	7b 1c       	adc	r7, r11
 6a8:	d6 01       	movw	r26, r12
 6aa:	8c 91       	ld	r24, X
 6ac:	89 8f       	std	Y+25, r24	; 0x19
 6ae:	8c 91       	ld	r24, X
 6b0:	81 11       	cpse	r24, r1
 6b2:	05 c0       	rjmp	.+10     	; 0x6be <xTaskCreate+0x66>
 6b4:	18 c0       	rjmp	.+48     	; 0x6e6 <xTaskCreate+0x8e>
 6b6:	c3 01       	movw	r24, r6
 6b8:	0e 94 88 00 	call	0x110	; 0x110 <vPortFree>
 6bc:	c2 c0       	rjmp	.+388    	; 0x842 <xTaskCreate+0x1ea>
 6be:	ae 01       	movw	r20, r28
 6c0:	46 5e       	subi	r20, 0xE6	; 230
 6c2:	5f 4f       	sbci	r21, 0xFF	; 255
 6c4:	f6 01       	movw	r30, r12
 6c6:	31 96       	adiw	r30, 0x01	; 1
 6c8:	b8 e0       	ldi	r27, 0x08	; 8
 6ca:	cb 0e       	add	r12, r27
 6cc:	d1 1c       	adc	r13, r1
 6ce:	cf 01       	movw	r24, r30
 6d0:	21 91       	ld	r18, Z+
 6d2:	da 01       	movw	r26, r20
 6d4:	2d 93       	st	X+, r18
 6d6:	ad 01       	movw	r20, r26
 6d8:	dc 01       	movw	r26, r24
 6da:	8c 91       	ld	r24, X
 6dc:	88 23       	and	r24, r24
 6de:	19 f0       	breq	.+6      	; 0x6e6 <xTaskCreate+0x8e>
 6e0:	ec 15       	cp	r30, r12
 6e2:	fd 05       	cpc	r31, r13
 6e4:	a1 f7       	brne	.-24     	; 0x6ce <xTaskCreate+0x76>
 6e6:	18 a2       	std	Y+32, r1	; 0x20
 6e8:	04 30       	cpi	r16, 0x04	; 4
 6ea:	08 f0       	brcs	.+2      	; 0x6ee <xTaskCreate+0x96>
 6ec:	03 e0       	ldi	r16, 0x03	; 3
 6ee:	0e 8b       	std	Y+22, r16	; 0x16
 6f0:	6e 01       	movw	r12, r28
 6f2:	b2 e0       	ldi	r27, 0x02	; 2
 6f4:	cb 0e       	add	r12, r27
 6f6:	d1 1c       	adc	r13, r1
 6f8:	c6 01       	movw	r24, r12
 6fa:	0e 94 97 00 	call	0x12e	; 0x12e <vListInitialiseItem>
 6fe:	ce 01       	movw	r24, r28
 700:	0c 96       	adiw	r24, 0x0c	; 12
 702:	0e 94 97 00 	call	0x12e	; 0x12e <vListInitialiseItem>
 706:	d9 87       	std	Y+9, r29	; 0x09
 708:	c8 87       	std	Y+8, r28	; 0x08
 70a:	84 e0       	ldi	r24, 0x04	; 4
 70c:	90 e0       	ldi	r25, 0x00	; 0
 70e:	80 1b       	sub	r24, r16
 710:	91 09       	sbc	r25, r1
 712:	9d 87       	std	Y+13, r25	; 0x0d
 714:	8c 87       	std	Y+12, r24	; 0x0c
 716:	db 8b       	std	Y+19, r29	; 0x13
 718:	ca 8b       	std	Y+18, r28	; 0x12
 71a:	1a a2       	std	Y+34, r1	; 0x22
 71c:	19 a2       	std	Y+33, r1	; 0x21
 71e:	1b a2       	std	Y+35, r1	; 0x23
 720:	1c a2       	std	Y+36, r1	; 0x24
 722:	1d a2       	std	Y+37, r1	; 0x25
 724:	1e a2       	std	Y+38, r1	; 0x26
 726:	1f a2       	std	Y+39, r1	; 0x27
 728:	a2 01       	movw	r20, r4
 72a:	b4 01       	movw	r22, r8
 72c:	c3 01       	movw	r24, r6
 72e:	0e 94 62 01 	call	0x2c4	; 0x2c4 <pxPortInitialiseStack>
 732:	99 83       	std	Y+1, r25	; 0x01
 734:	88 83       	st	Y, r24
 736:	e1 14       	cp	r14, r1
 738:	f1 04       	cpc	r15, r1
 73a:	19 f0       	breq	.+6      	; 0x742 <xTaskCreate+0xea>
 73c:	f7 01       	movw	r30, r14
 73e:	d1 83       	std	Z+1, r29	; 0x01
 740:	c0 83       	st	Z, r28
 742:	0f b6       	in	r0, 0x3f	; 63
 744:	f8 94       	cli
 746:	0f 92       	push	r0
 748:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <uxCurrentNumberOfTasks>
 74c:	8f 5f       	subi	r24, 0xFF	; 255
 74e:	80 93 05 05 	sts	0x0505, r24	; 0x800505 <uxCurrentNumberOfTasks>
 752:	80 91 49 05 	lds	r24, 0x0549	; 0x800549 <pxCurrentTCB>
 756:	90 91 4a 05 	lds	r25, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 75a:	89 2b       	or	r24, r25
 75c:	89 f5       	brne	.+98     	; 0x7c0 <xTaskCreate+0x168>
 75e:	d0 93 4a 05 	sts	0x054A, r29	; 0x80054a <pxCurrentTCB+0x1>
 762:	c0 93 49 05 	sts	0x0549, r28	; 0x800549 <pxCurrentTCB>
 766:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <uxCurrentNumberOfTasks>
 76a:	81 30       	cpi	r24, 0x01	; 1
 76c:	c9 f5       	brne	.+114    	; 0x7e0 <xTaskCreate+0x188>
 76e:	85 e2       	ldi	r24, 0x25	; 37
 770:	95 e0       	ldi	r25, 0x05	; 5
 772:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 776:	8e e2       	ldi	r24, 0x2E	; 46
 778:	95 e0       	ldi	r25, 0x05	; 5
 77a:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 77e:	87 e3       	ldi	r24, 0x37	; 55
 780:	95 e0       	ldi	r25, 0x05	; 5
 782:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 786:	80 e4       	ldi	r24, 0x40	; 64
 788:	95 e0       	ldi	r25, 0x05	; 5
 78a:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 78e:	8c e1       	ldi	r24, 0x1C	; 28
 790:	95 e0       	ldi	r25, 0x05	; 5
 792:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 796:	83 e1       	ldi	r24, 0x13	; 19
 798:	95 e0       	ldi	r25, 0x05	; 5
 79a:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 79e:	86 e0       	ldi	r24, 0x06	; 6
 7a0:	95 e0       	ldi	r25, 0x05	; 5
 7a2:	0e 94 89 00 	call	0x112	; 0x112 <vListInitialise>
 7a6:	8c e1       	ldi	r24, 0x1C	; 28
 7a8:	95 e0       	ldi	r25, 0x05	; 5
 7aa:	90 93 12 05 	sts	0x0512, r25	; 0x800512 <pxDelayedTaskList+0x1>
 7ae:	80 93 11 05 	sts	0x0511, r24	; 0x800511 <pxDelayedTaskList>
 7b2:	83 e1       	ldi	r24, 0x13	; 19
 7b4:	95 e0       	ldi	r25, 0x05	; 5
 7b6:	90 93 10 05 	sts	0x0510, r25	; 0x800510 <pxOverflowDelayedTaskList+0x1>
 7ba:	80 93 0f 05 	sts	0x050F, r24	; 0x80050f <pxOverflowDelayedTaskList>
 7be:	10 c0       	rjmp	.+32     	; 0x7e0 <xTaskCreate+0x188>
 7c0:	80 91 01 05 	lds	r24, 0x0501	; 0x800501 <xSchedulerRunning>
 7c4:	81 11       	cpse	r24, r1
 7c6:	0c c0       	rjmp	.+24     	; 0x7e0 <xTaskCreate+0x188>
 7c8:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 7cc:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 7d0:	96 89       	ldd	r25, Z+22	; 0x16
 7d2:	8e 89       	ldd	r24, Y+22	; 0x16
 7d4:	89 17       	cp	r24, r25
 7d6:	20 f0       	brcs	.+8      	; 0x7e0 <xTaskCreate+0x188>
 7d8:	d0 93 4a 05 	sts	0x054A, r29	; 0x80054a <pxCurrentTCB+0x1>
 7dc:	c0 93 49 05 	sts	0x0549, r28	; 0x800549 <pxCurrentTCB>
 7e0:	80 91 fd 04 	lds	r24, 0x04FD	; 0x8004fd <uxTaskNumber>
 7e4:	8f 5f       	subi	r24, 0xFF	; 255
 7e6:	80 93 fd 04 	sts	0x04FD, r24	; 0x8004fd <uxTaskNumber>
 7ea:	8e 89       	ldd	r24, Y+22	; 0x16
 7ec:	90 91 02 05 	lds	r25, 0x0502	; 0x800502 <uxTopReadyPriority>
 7f0:	98 17       	cp	r25, r24
 7f2:	10 f4       	brcc	.+4      	; 0x7f8 <xTaskCreate+0x1a0>
 7f4:	80 93 02 05 	sts	0x0502, r24	; 0x800502 <uxTopReadyPriority>
 7f8:	90 e0       	ldi	r25, 0x00	; 0
 7fa:	9c 01       	movw	r18, r24
 7fc:	22 0f       	add	r18, r18
 7fe:	33 1f       	adc	r19, r19
 800:	22 0f       	add	r18, r18
 802:	33 1f       	adc	r19, r19
 804:	22 0f       	add	r18, r18
 806:	33 1f       	adc	r19, r19
 808:	82 0f       	add	r24, r18
 80a:	93 1f       	adc	r25, r19
 80c:	b6 01       	movw	r22, r12
 80e:	8b 5d       	subi	r24, 0xDB	; 219
 810:	9a 4f       	sbci	r25, 0xFA	; 250
 812:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
 816:	0f 90       	pop	r0
 818:	0f be       	out	0x3f, r0	; 63
 81a:	80 91 01 05 	lds	r24, 0x0501	; 0x800501 <xSchedulerRunning>
 81e:	88 23       	and	r24, r24
 820:	61 f0       	breq	.+24     	; 0x83a <xTaskCreate+0x1e2>
 822:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 826:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 82a:	96 89       	ldd	r25, Z+22	; 0x16
 82c:	8e 89       	ldd	r24, Y+22	; 0x16
 82e:	98 17       	cp	r25, r24
 830:	30 f4       	brcc	.+12     	; 0x83e <xTaskCreate+0x1e6>
 832:	0e 94 09 02 	call	0x412	; 0x412 <vPortYield>
 836:	81 e0       	ldi	r24, 0x01	; 1
 838:	05 c0       	rjmp	.+10     	; 0x844 <xTaskCreate+0x1ec>
 83a:	81 e0       	ldi	r24, 0x01	; 1
 83c:	03 c0       	rjmp	.+6      	; 0x844 <xTaskCreate+0x1ec>
 83e:	81 e0       	ldi	r24, 0x01	; 1
 840:	01 c0       	rjmp	.+2      	; 0x844 <xTaskCreate+0x1ec>
 842:	8f ef       	ldi	r24, 0xFF	; 255
 844:	df 91       	pop	r29
 846:	cf 91       	pop	r28
 848:	0f 91       	pop	r16
 84a:	ff 90       	pop	r15
 84c:	ef 90       	pop	r14
 84e:	df 90       	pop	r13
 850:	cf 90       	pop	r12
 852:	bf 90       	pop	r11
 854:	af 90       	pop	r10
 856:	9f 90       	pop	r9
 858:	8f 90       	pop	r8
 85a:	7f 90       	pop	r7
 85c:	6f 90       	pop	r6
 85e:	5f 90       	pop	r5
 860:	4f 90       	pop	r4
 862:	08 95       	ret

00000864 <vTaskStartScheduler>:
 864:	ef 92       	push	r14
 866:	ff 92       	push	r15
 868:	0f 93       	push	r16
 86a:	0f 2e       	mov	r0, r31
 86c:	f9 ef       	ldi	r31, 0xF9	; 249
 86e:	ef 2e       	mov	r14, r31
 870:	f4 e0       	ldi	r31, 0x04	; 4
 872:	ff 2e       	mov	r15, r31
 874:	f0 2d       	mov	r31, r0
 876:	00 e0       	ldi	r16, 0x00	; 0
 878:	20 e0       	ldi	r18, 0x00	; 0
 87a:	30 e0       	ldi	r19, 0x00	; 0
 87c:	40 e5       	ldi	r20, 0x50	; 80
 87e:	50 e0       	ldi	r21, 0x00	; 0
 880:	66 e0       	ldi	r22, 0x06	; 6
 882:	71 e0       	ldi	r23, 0x01	; 1
 884:	80 ee       	ldi	r24, 0xE0	; 224
 886:	92 e0       	ldi	r25, 0x02	; 2
 888:	0e 94 2c 03 	call	0x658	; 0x658 <xTaskCreate>
 88c:	81 30       	cpi	r24, 0x01	; 1
 88e:	81 f4       	brne	.+32     	; 0x8b0 <vTaskStartScheduler+0x4c>
 890:	f8 94       	cli
 892:	8f ef       	ldi	r24, 0xFF	; 255
 894:	9f ef       	ldi	r25, 0xFF	; 255
 896:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <xNextTaskUnblockTime+0x1>
 89a:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <xNextTaskUnblockTime>
 89e:	81 e0       	ldi	r24, 0x01	; 1
 8a0:	80 93 01 05 	sts	0x0501, r24	; 0x800501 <xSchedulerRunning>
 8a4:	10 92 04 05 	sts	0x0504, r1	; 0x800504 <xTickCount+0x1>
 8a8:	10 92 03 05 	sts	0x0503, r1	; 0x800503 <xTickCount>
 8ac:	0e 94 ce 01 	call	0x39c	; 0x39c <xPortStartScheduler>
 8b0:	0f 91       	pop	r16
 8b2:	ff 90       	pop	r15
 8b4:	ef 90       	pop	r14
 8b6:	08 95       	ret

000008b8 <vTaskSuspendAll>:
 8b8:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 8bc:	8f 5f       	subi	r24, 0xFF	; 255
 8be:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <uxSchedulerSuspended>
 8c2:	08 95       	ret

000008c4 <xTaskIncrementTick>:
 8c4:	cf 92       	push	r12
 8c6:	df 92       	push	r13
 8c8:	ef 92       	push	r14
 8ca:	ff 92       	push	r15
 8cc:	0f 93       	push	r16
 8ce:	1f 93       	push	r17
 8d0:	cf 93       	push	r28
 8d2:	df 93       	push	r29
 8d4:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 8d8:	81 11       	cpse	r24, r1
 8da:	99 c0       	rjmp	.+306    	; 0xa0e <__stack+0x10f>
 8dc:	e0 90 03 05 	lds	r14, 0x0503	; 0x800503 <xTickCount>
 8e0:	f0 90 04 05 	lds	r15, 0x0504	; 0x800504 <xTickCount+0x1>
 8e4:	8f ef       	ldi	r24, 0xFF	; 255
 8e6:	e8 1a       	sub	r14, r24
 8e8:	f8 0a       	sbc	r15, r24
 8ea:	f0 92 04 05 	sts	0x0504, r15	; 0x800504 <xTickCount+0x1>
 8ee:	e0 92 03 05 	sts	0x0503, r14	; 0x800503 <xTickCount>
 8f2:	e1 14       	cp	r14, r1
 8f4:	f1 04       	cpc	r15, r1
 8f6:	b9 f4       	brne	.+46     	; 0x926 <__stack+0x27>
 8f8:	80 91 11 05 	lds	r24, 0x0511	; 0x800511 <pxDelayedTaskList>
 8fc:	90 91 12 05 	lds	r25, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 900:	20 91 0f 05 	lds	r18, 0x050F	; 0x80050f <pxOverflowDelayedTaskList>
 904:	30 91 10 05 	lds	r19, 0x0510	; 0x800510 <pxOverflowDelayedTaskList+0x1>
 908:	30 93 12 05 	sts	0x0512, r19	; 0x800512 <pxDelayedTaskList+0x1>
 90c:	20 93 11 05 	sts	0x0511, r18	; 0x800511 <pxDelayedTaskList>
 910:	90 93 10 05 	sts	0x0510, r25	; 0x800510 <pxOverflowDelayedTaskList+0x1>
 914:	80 93 0f 05 	sts	0x050F, r24	; 0x80050f <pxOverflowDelayedTaskList>
 918:	80 91 fe 04 	lds	r24, 0x04FE	; 0x8004fe <xNumOfOverflows>
 91c:	8f 5f       	subi	r24, 0xFF	; 255
 91e:	80 93 fe 04 	sts	0x04FE, r24	; 0x8004fe <xNumOfOverflows>
 922:	0e 94 c1 02 	call	0x582	; 0x582 <prvResetNextTaskUnblockTime>
 926:	80 91 fb 04 	lds	r24, 0x04FB	; 0x8004fb <xNextTaskUnblockTime>
 92a:	90 91 fc 04 	lds	r25, 0x04FC	; 0x8004fc <xNextTaskUnblockTime+0x1>
 92e:	e8 16       	cp	r14, r24
 930:	f9 06       	cpc	r15, r25
 932:	10 f4       	brcc	.+4      	; 0x938 <__stack+0x39>
 934:	d1 2c       	mov	r13, r1
 936:	53 c0       	rjmp	.+166    	; 0x9de <__stack+0xdf>
 938:	d1 2c       	mov	r13, r1
 93a:	cc 24       	eor	r12, r12
 93c:	c3 94       	inc	r12
 93e:	e0 91 11 05 	lds	r30, 0x0511	; 0x800511 <pxDelayedTaskList>
 942:	f0 91 12 05 	lds	r31, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 946:	90 81       	ld	r25, Z
 948:	91 11       	cpse	r25, r1
 94a:	07 c0       	rjmp	.+14     	; 0x95a <__stack+0x5b>
 94c:	8f ef       	ldi	r24, 0xFF	; 255
 94e:	9f ef       	ldi	r25, 0xFF	; 255
 950:	90 93 fc 04 	sts	0x04FC, r25	; 0x8004fc <xNextTaskUnblockTime+0x1>
 954:	80 93 fb 04 	sts	0x04FB, r24	; 0x8004fb <xNextTaskUnblockTime>
 958:	42 c0       	rjmp	.+132    	; 0x9de <__stack+0xdf>
 95a:	e0 91 11 05 	lds	r30, 0x0511	; 0x800511 <pxDelayedTaskList>
 95e:	f0 91 12 05 	lds	r31, 0x0512	; 0x800512 <pxDelayedTaskList+0x1>
 962:	05 80       	ldd	r0, Z+5	; 0x05
 964:	f6 81       	ldd	r31, Z+6	; 0x06
 966:	e0 2d       	mov	r30, r0
 968:	c6 81       	ldd	r28, Z+6	; 0x06
 96a:	d7 81       	ldd	r29, Z+7	; 0x07
 96c:	2a 81       	ldd	r18, Y+2	; 0x02
 96e:	3b 81       	ldd	r19, Y+3	; 0x03
 970:	e2 16       	cp	r14, r18
 972:	f3 06       	cpc	r15, r19
 974:	28 f4       	brcc	.+10     	; 0x980 <__stack+0x81>
 976:	30 93 fc 04 	sts	0x04FC, r19	; 0x8004fc <xNextTaskUnblockTime+0x1>
 97a:	20 93 fb 04 	sts	0x04FB, r18	; 0x8004fb <xNextTaskUnblockTime>
 97e:	2f c0       	rjmp	.+94     	; 0x9de <__stack+0xdf>
 980:	8e 01       	movw	r16, r28
 982:	0e 5f       	subi	r16, 0xFE	; 254
 984:	1f 4f       	sbci	r17, 0xFF	; 255
 986:	c8 01       	movw	r24, r16
 988:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
 98c:	8c 89       	ldd	r24, Y+20	; 0x14
 98e:	9d 89       	ldd	r25, Y+21	; 0x15
 990:	89 2b       	or	r24, r25
 992:	21 f0       	breq	.+8      	; 0x99c <__stack+0x9d>
 994:	ce 01       	movw	r24, r28
 996:	0c 96       	adiw	r24, 0x0c	; 12
 998:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
 99c:	2e 89       	ldd	r18, Y+22	; 0x16
 99e:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <uxTopReadyPriority>
 9a2:	82 17       	cp	r24, r18
 9a4:	10 f4       	brcc	.+4      	; 0x9aa <__stack+0xab>
 9a6:	20 93 02 05 	sts	0x0502, r18	; 0x800502 <uxTopReadyPriority>
 9aa:	30 e0       	ldi	r19, 0x00	; 0
 9ac:	c9 01       	movw	r24, r18
 9ae:	88 0f       	add	r24, r24
 9b0:	99 1f       	adc	r25, r25
 9b2:	88 0f       	add	r24, r24
 9b4:	99 1f       	adc	r25, r25
 9b6:	88 0f       	add	r24, r24
 9b8:	99 1f       	adc	r25, r25
 9ba:	82 0f       	add	r24, r18
 9bc:	93 1f       	adc	r25, r19
 9be:	b8 01       	movw	r22, r16
 9c0:	8b 5d       	subi	r24, 0xDB	; 219
 9c2:	9a 4f       	sbci	r25, 0xFA	; 250
 9c4:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
 9c8:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 9cc:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 9d0:	9e 89       	ldd	r25, Y+22	; 0x16
 9d2:	86 89       	ldd	r24, Z+22	; 0x16
 9d4:	98 17       	cp	r25, r24
 9d6:	08 f4       	brcc	.+2      	; 0x9da <__stack+0xdb>
 9d8:	b2 cf       	rjmp	.-156    	; 0x93e <__stack+0x3f>
 9da:	dc 2c       	mov	r13, r12
 9dc:	b0 cf       	rjmp	.-160    	; 0x93e <__stack+0x3f>
 9de:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 9e2:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 9e6:	86 89       	ldd	r24, Z+22	; 0x16
 9e8:	90 e0       	ldi	r25, 0x00	; 0
 9ea:	fc 01       	movw	r30, r24
 9ec:	ee 0f       	add	r30, r30
 9ee:	ff 1f       	adc	r31, r31
 9f0:	ee 0f       	add	r30, r30
 9f2:	ff 1f       	adc	r31, r31
 9f4:	ee 0f       	add	r30, r30
 9f6:	ff 1f       	adc	r31, r31
 9f8:	8e 0f       	add	r24, r30
 9fa:	9f 1f       	adc	r25, r31
 9fc:	fc 01       	movw	r30, r24
 9fe:	eb 5d       	subi	r30, 0xDB	; 219
 a00:	fa 4f       	sbci	r31, 0xFA	; 250
 a02:	80 81       	ld	r24, Z
 a04:	82 30       	cpi	r24, 0x02	; 2
 a06:	48 f0       	brcs	.+18     	; 0xa1a <__stack+0x11b>
 a08:	dd 24       	eor	r13, r13
 a0a:	d3 94       	inc	r13
 a0c:	06 c0       	rjmp	.+12     	; 0xa1a <__stack+0x11b>
 a0e:	80 91 00 05 	lds	r24, 0x0500	; 0x800500 <uxPendedTicks>
 a12:	8f 5f       	subi	r24, 0xFF	; 255
 a14:	80 93 00 05 	sts	0x0500, r24	; 0x800500 <uxPendedTicks>
 a18:	d1 2c       	mov	r13, r1
 a1a:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <xYieldPending>
 a1e:	88 23       	and	r24, r24
 a20:	11 f0       	breq	.+4      	; 0xa26 <__stack+0x127>
 a22:	dd 24       	eor	r13, r13
 a24:	d3 94       	inc	r13
 a26:	8d 2d       	mov	r24, r13
 a28:	df 91       	pop	r29
 a2a:	cf 91       	pop	r28
 a2c:	1f 91       	pop	r17
 a2e:	0f 91       	pop	r16
 a30:	ff 90       	pop	r15
 a32:	ef 90       	pop	r14
 a34:	df 90       	pop	r13
 a36:	cf 90       	pop	r12
 a38:	08 95       	ret

00000a3a <xTaskResumeAll>:
 a3a:	df 92       	push	r13
 a3c:	ef 92       	push	r14
 a3e:	ff 92       	push	r15
 a40:	0f 93       	push	r16
 a42:	1f 93       	push	r17
 a44:	cf 93       	push	r28
 a46:	df 93       	push	r29
 a48:	0f b6       	in	r0, 0x3f	; 63
 a4a:	f8 94       	cli
 a4c:	0f 92       	push	r0
 a4e:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 a52:	81 50       	subi	r24, 0x01	; 1
 a54:	80 93 f8 04 	sts	0x04F8, r24	; 0x8004f8 <uxSchedulerSuspended>
 a58:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 a5c:	81 11       	cpse	r24, r1
 a5e:	5f c0       	rjmp	.+190    	; 0xb1e <xTaskResumeAll+0xe4>
 a60:	80 91 05 05 	lds	r24, 0x0505	; 0x800505 <uxCurrentNumberOfTasks>
 a64:	81 11       	cpse	r24, r1
 a66:	33 c0       	rjmp	.+102    	; 0xace <xTaskResumeAll+0x94>
 a68:	5d c0       	rjmp	.+186    	; 0xb24 <xTaskResumeAll+0xea>
 a6a:	d7 01       	movw	r26, r14
 a6c:	15 96       	adiw	r26, 0x05	; 5
 a6e:	ed 91       	ld	r30, X+
 a70:	fc 91       	ld	r31, X
 a72:	16 97       	sbiw	r26, 0x06	; 6
 a74:	c6 81       	ldd	r28, Z+6	; 0x06
 a76:	d7 81       	ldd	r29, Z+7	; 0x07
 a78:	ce 01       	movw	r24, r28
 a7a:	0c 96       	adiw	r24, 0x0c	; 12
 a7c:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
 a80:	8e 01       	movw	r16, r28
 a82:	0e 5f       	subi	r16, 0xFE	; 254
 a84:	1f 4f       	sbci	r17, 0xFF	; 255
 a86:	c8 01       	movw	r24, r16
 a88:	0e 94 ed 00 	call	0x1da	; 0x1da <uxListRemove>
 a8c:	2e 89       	ldd	r18, Y+22	; 0x16
 a8e:	80 91 02 05 	lds	r24, 0x0502	; 0x800502 <uxTopReadyPriority>
 a92:	82 17       	cp	r24, r18
 a94:	10 f4       	brcc	.+4      	; 0xa9a <xTaskResumeAll+0x60>
 a96:	20 93 02 05 	sts	0x0502, r18	; 0x800502 <uxTopReadyPriority>
 a9a:	30 e0       	ldi	r19, 0x00	; 0
 a9c:	c9 01       	movw	r24, r18
 a9e:	88 0f       	add	r24, r24
 aa0:	99 1f       	adc	r25, r25
 aa2:	88 0f       	add	r24, r24
 aa4:	99 1f       	adc	r25, r25
 aa6:	88 0f       	add	r24, r24
 aa8:	99 1f       	adc	r25, r25
 aaa:	82 0f       	add	r24, r18
 aac:	93 1f       	adc	r25, r19
 aae:	b8 01       	movw	r22, r16
 ab0:	8b 5d       	subi	r24, 0xDB	; 219
 ab2:	9a 4f       	sbci	r25, 0xFA	; 250
 ab4:	0e 94 9b 00 	call	0x136	; 0x136 <vListInsertEnd>
 ab8:	e0 91 49 05 	lds	r30, 0x0549	; 0x800549 <pxCurrentTCB>
 abc:	f0 91 4a 05 	lds	r31, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 ac0:	9e 89       	ldd	r25, Y+22	; 0x16
 ac2:	86 89       	ldd	r24, Z+22	; 0x16
 ac4:	98 17       	cp	r25, r24
 ac6:	68 f0       	brcs	.+26     	; 0xae2 <xTaskResumeAll+0xa8>
 ac8:	d0 92 ff 04 	sts	0x04FF, r13	; 0x8004ff <xYieldPending>
 acc:	0a c0       	rjmp	.+20     	; 0xae2 <xTaskResumeAll+0xa8>
 ace:	c0 e0       	ldi	r28, 0x00	; 0
 ad0:	d0 e0       	ldi	r29, 0x00	; 0
 ad2:	0f 2e       	mov	r0, r31
 ad4:	f6 e0       	ldi	r31, 0x06	; 6
 ad6:	ef 2e       	mov	r14, r31
 ad8:	f5 e0       	ldi	r31, 0x05	; 5
 ada:	ff 2e       	mov	r15, r31
 adc:	f0 2d       	mov	r31, r0
 ade:	dd 24       	eor	r13, r13
 ae0:	d3 94       	inc	r13
 ae2:	f7 01       	movw	r30, r14
 ae4:	80 81       	ld	r24, Z
 ae6:	81 11       	cpse	r24, r1
 ae8:	c0 cf       	rjmp	.-128    	; 0xa6a <xTaskResumeAll+0x30>
 aea:	cd 2b       	or	r28, r29
 aec:	11 f0       	breq	.+4      	; 0xaf2 <xTaskResumeAll+0xb8>
 aee:	0e 94 c1 02 	call	0x582	; 0x582 <prvResetNextTaskUnblockTime>
 af2:	c0 91 00 05 	lds	r28, 0x0500	; 0x800500 <uxPendedTicks>
 af6:	cc 23       	and	r28, r28
 af8:	51 f0       	breq	.+20     	; 0xb0e <xTaskResumeAll+0xd4>
 afa:	d1 e0       	ldi	r29, 0x01	; 1
 afc:	0e 94 62 04 	call	0x8c4	; 0x8c4 <xTaskIncrementTick>
 b00:	81 11       	cpse	r24, r1
 b02:	d0 93 ff 04 	sts	0x04FF, r29	; 0x8004ff <xYieldPending>
 b06:	c1 50       	subi	r28, 0x01	; 1
 b08:	c9 f7       	brne	.-14     	; 0xafc <xTaskResumeAll+0xc2>
 b0a:	10 92 00 05 	sts	0x0500, r1	; 0x800500 <uxPendedTicks>
 b0e:	80 91 ff 04 	lds	r24, 0x04FF	; 0x8004ff <xYieldPending>
 b12:	88 23       	and	r24, r24
 b14:	31 f0       	breq	.+12     	; 0xb22 <xTaskResumeAll+0xe8>
 b16:	0e 94 09 02 	call	0x412	; 0x412 <vPortYield>
 b1a:	81 e0       	ldi	r24, 0x01	; 1
 b1c:	03 c0       	rjmp	.+6      	; 0xb24 <xTaskResumeAll+0xea>
 b1e:	80 e0       	ldi	r24, 0x00	; 0
 b20:	01 c0       	rjmp	.+2      	; 0xb24 <xTaskResumeAll+0xea>
 b22:	80 e0       	ldi	r24, 0x00	; 0
 b24:	0f 90       	pop	r0
 b26:	0f be       	out	0x3f, r0	; 63
 b28:	df 91       	pop	r29
 b2a:	cf 91       	pop	r28
 b2c:	1f 91       	pop	r17
 b2e:	0f 91       	pop	r16
 b30:	ff 90       	pop	r15
 b32:	ef 90       	pop	r14
 b34:	df 90       	pop	r13
 b36:	08 95       	ret

00000b38 <vTaskDelay>:
 b38:	cf 93       	push	r28
 b3a:	df 93       	push	r29
 b3c:	ec 01       	movw	r28, r24
 b3e:	89 2b       	or	r24, r25
 b40:	51 f0       	breq	.+20     	; 0xb56 <vTaskDelay+0x1e>
 b42:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <vTaskSuspendAll>
 b46:	60 e0       	ldi	r22, 0x00	; 0
 b48:	ce 01       	movw	r24, r28
 b4a:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <prvAddCurrentTaskToDelayedList>
 b4e:	0e 94 1d 05 	call	0xa3a	; 0xa3a <xTaskResumeAll>
 b52:	81 11       	cpse	r24, r1
 b54:	02 c0       	rjmp	.+4      	; 0xb5a <vTaskDelay+0x22>
 b56:	0e 94 09 02 	call	0x412	; 0x412 <vPortYield>
 b5a:	df 91       	pop	r29
 b5c:	cf 91       	pop	r28
 b5e:	08 95       	ret

00000b60 <vTaskSetApplicationTaskTag>:
 b60:	00 97       	sbiw	r24, 0x00	; 0
 b62:	21 f4       	brne	.+8      	; 0xb6c <vTaskSetApplicationTaskTag+0xc>
 b64:	80 91 49 05 	lds	r24, 0x0549	; 0x800549 <pxCurrentTCB>
 b68:	90 91 4a 05 	lds	r25, 0x054A	; 0x80054a <pxCurrentTCB+0x1>
 b6c:	0f b6       	in	r0, 0x3f	; 63
 b6e:	f8 94       	cli
 b70:	0f 92       	push	r0
 b72:	fc 01       	movw	r30, r24
 b74:	72 a3       	std	Z+34, r23	; 0x22
 b76:	61 a3       	std	Z+33, r22	; 0x21
 b78:	0f 90       	pop	r0
 b7a:	0f be       	out	0x3f, r0	; 63
 b7c:	08 95       	ret

00000b7e <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 b7e:	80 91 f8 04 	lds	r24, 0x04F8	; 0x8004f8 <uxSchedulerSuspended>
 b82:	88 23       	and	r24, r24
 b84:	21 f0       	breq	.+8      	; 0xb8e <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
 b86:	81 e0       	ldi	r24, 0x01	; 1
 b88:	80 93 ff 04 	sts	0x04FF, r24	; 0x8004ff <xYieldPending>
 b8c:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
 b8e:	10 92 ff 04 	sts	0x04FF, r1	; 0x8004ff <xYieldPending>
		traceTASK_SWITCHED_OUT();
 b92:	0e 94 59 01 	call	0x2b2	; 0x2b2 <vContextSwitch>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
 b96:	20 91 02 05 	lds	r18, 0x0502	; 0x800502 <uxTopReadyPriority>
 b9a:	82 2f       	mov	r24, r18
 b9c:	90 e0       	ldi	r25, 0x00	; 0
 b9e:	fc 01       	movw	r30, r24
 ba0:	ee 0f       	add	r30, r30
 ba2:	ff 1f       	adc	r31, r31
 ba4:	ee 0f       	add	r30, r30
 ba6:	ff 1f       	adc	r31, r31
 ba8:	ee 0f       	add	r30, r30
 baa:	ff 1f       	adc	r31, r31
 bac:	e8 0f       	add	r30, r24
 bae:	f9 1f       	adc	r31, r25
 bb0:	eb 5d       	subi	r30, 0xDB	; 219
 bb2:	fa 4f       	sbci	r31, 0xFA	; 250
 bb4:	30 81       	ld	r19, Z
 bb6:	31 11       	cpse	r19, r1
 bb8:	11 c0       	rjmp	.+34     	; 0xbdc <vTaskSwitchContext+0x5e>
 bba:	21 50       	subi	r18, 0x01	; 1
 bbc:	82 2f       	mov	r24, r18
 bbe:	90 e0       	ldi	r25, 0x00	; 0
 bc0:	fc 01       	movw	r30, r24
 bc2:	ee 0f       	add	r30, r30
 bc4:	ff 1f       	adc	r31, r31
 bc6:	ee 0f       	add	r30, r30
 bc8:	ff 1f       	adc	r31, r31
 bca:	ee 0f       	add	r30, r30
 bcc:	ff 1f       	adc	r31, r31
 bce:	e8 0f       	add	r30, r24
 bd0:	f9 1f       	adc	r31, r25
 bd2:	eb 5d       	subi	r30, 0xDB	; 219
 bd4:	fa 4f       	sbci	r31, 0xFA	; 250
 bd6:	30 81       	ld	r19, Z
 bd8:	33 23       	and	r19, r19
 bda:	79 f3       	breq	.-34     	; 0xbba <vTaskSwitchContext+0x3c>
 bdc:	ac 01       	movw	r20, r24
 bde:	44 0f       	add	r20, r20
 be0:	55 1f       	adc	r21, r21
 be2:	44 0f       	add	r20, r20
 be4:	55 1f       	adc	r21, r21
 be6:	44 0f       	add	r20, r20
 be8:	55 1f       	adc	r21, r21
 bea:	48 0f       	add	r20, r24
 bec:	59 1f       	adc	r21, r25
 bee:	da 01       	movw	r26, r20
 bf0:	ab 5d       	subi	r26, 0xDB	; 219
 bf2:	ba 4f       	sbci	r27, 0xFA	; 250
 bf4:	11 96       	adiw	r26, 0x01	; 1
 bf6:	ed 91       	ld	r30, X+
 bf8:	fc 91       	ld	r31, X
 bfa:	12 97       	sbiw	r26, 0x02	; 2
 bfc:	02 80       	ldd	r0, Z+2	; 0x02
 bfe:	f3 81       	ldd	r31, Z+3	; 0x03
 c00:	e0 2d       	mov	r30, r0
 c02:	12 96       	adiw	r26, 0x02	; 2
 c04:	fc 93       	st	X, r31
 c06:	ee 93       	st	-X, r30
 c08:	11 97       	sbiw	r26, 0x01	; 1
 c0a:	48 5d       	subi	r20, 0xD8	; 216
 c0c:	5a 4f       	sbci	r21, 0xFA	; 250
 c0e:	e4 17       	cp	r30, r20
 c10:	f5 07       	cpc	r31, r21
 c12:	29 f4       	brne	.+10     	; 0xc1e <vTaskSwitchContext+0xa0>
 c14:	42 81       	ldd	r20, Z+2	; 0x02
 c16:	53 81       	ldd	r21, Z+3	; 0x03
 c18:	fd 01       	movw	r30, r26
 c1a:	52 83       	std	Z+2, r21	; 0x02
 c1c:	41 83       	std	Z+1, r20	; 0x01
 c1e:	fc 01       	movw	r30, r24
 c20:	ee 0f       	add	r30, r30
 c22:	ff 1f       	adc	r31, r31
 c24:	ee 0f       	add	r30, r30
 c26:	ff 1f       	adc	r31, r31
 c28:	ee 0f       	add	r30, r30
 c2a:	ff 1f       	adc	r31, r31
 c2c:	8e 0f       	add	r24, r30
 c2e:	9f 1f       	adc	r25, r31
 c30:	fc 01       	movw	r30, r24
 c32:	eb 5d       	subi	r30, 0xDB	; 219
 c34:	fa 4f       	sbci	r31, 0xFA	; 250
 c36:	01 80       	ldd	r0, Z+1	; 0x01
 c38:	f2 81       	ldd	r31, Z+2	; 0x02
 c3a:	e0 2d       	mov	r30, r0
 c3c:	86 81       	ldd	r24, Z+6	; 0x06
 c3e:	97 81       	ldd	r25, Z+7	; 0x07
 c40:	90 93 4a 05 	sts	0x054A, r25	; 0x80054a <pxCurrentTCB+0x1>
 c44:	80 93 49 05 	sts	0x0549, r24	; 0x800549 <pxCurrentTCB>
 c48:	20 93 02 05 	sts	0x0502, r18	; 0x800502 <uxTopReadyPriority>
 c4c:	08 95       	ret

00000c4e <_exit>:
 c4e:	f8 94       	cli

00000c50 <__stop_program>:
 c50:	ff cf       	rjmp	.-2      	; 0xc50 <__stop_program>
